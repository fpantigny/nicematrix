% -*- coding: utf-8 ; -*- 
% Ce fichier doit être compilé avec LuaLaTeX uniquement.
\documentclass[dvipsnames]{article}
\usepackage{polyglossia}
\setmainlanguage{french}


\usepackage{geometry}
\geometry{left=2.8cm,right=2.8cm,top=2.5cm,bottom=2.5cm,papersize={21cm,29.7cm}}

\usepackage{array}%[=v2.5]
\usepackage{nicematrix}

\usepackage{tikz}
\usetikzlibrary
  {
    fit,
    patterns,
    arrows.meta,
    decorations.pathreplacing,
    babel,
    calligraphy
  }
 

\usepackage{enumitem}
\usepackage{siunitx}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{tocloft}
\setlength{\cftsubsecnumwidth}{3em} % for the numbers of subsections of the TOC

% On utilise \MakeShortVerb de shortvrb et pas \DefineShortVerb de fancyvrb
% car on ne veut pas que le contenu des petits éléments en verbatim soit colorié
% en gris
\usepackage{shortvrb}
\MakeShortVerb{\|}

\usepackage{fancyvrb}
\fvset{formatcom=\color{gray}}

\usepackage{titlesec}
\titlespacing*{\section}{0pt}{6.5ex plus 1ex minus .2ex}{4.3ex plus .2ex}
\titlespacing*{\subsection}{0pt}{4.5ex plus 1ex minus .2ex}{2ex plus .2ex}


\def\interitem{\vspace{7mm plus 2 mm minus 3mm}}

\usepackage{footnote}
\usepackage{booktabs}
\usepackage{varwidth}
\usepackage{tcolorbox}
\usepackage{adjustbox}
\usepackage[auto-lang=false]{lipsum}

\NewDocumentEnvironment {scope} {} {} {}

\NewDocumentCommand {\pkg} {m} {\textsf{#1}}
\NewDocumentCommand {\cls} {m} {\textsf{#1}}

\setlength{\parindent}{0pt}
\skip \footins = 2 \bigskipamount


\NewDocumentCommand{\Definition}{m}
  {{\setlength{\fboxsep}{1pt}\colorbox{gray!20}{\ttfamily \vphantom{gl}#1}}}

\NewDocumentCommand{\DefinitionCommande}{m}
  {{\setlength{\fboxsep}{1pt}\colorbox{gray!20}{\ttfamily
        \vphantom{gl}\textbackslash #1}}}


\usepackage{makeidx}
\makeindex

\def\emphase{\bgroup\color{RoyalPurple}\let\next=}

\usepackage{piton}
\PitonOptions{language = verbatim, detected-commands = {emph,textsl}, splittable = 4}
\SetPitonStyle{ Number = , Comment = }

\ExplSyntaxOn

\dim_new:N \l__pantigny_width_dim 

\keys_define:nn { pantigny }
  { width .dim_set:N = \l__pantigny_width_dim }

\NewPitonEnvironment { Code } { O { } }
  { 
    \char_set_catcode_other:N |
    \cs_set_eq:NN \emph \emphase
    \dim_zero:N \l__pantigny_width_dim 
    \keys_set:nn { pantigny } { #1 }
    \color{gray}
    \dim_compare:nNnT \l__pantigny_width_dim > \c_zero_dim 
      { 
        \PitonOptions { width = \l__pantigny_width_dim } 
        \begin{minipage}[c]{\l__pantigny_width_dim} 
      }
  }
  { \dim_compare:nNnT \l__pantigny_width_dim > \c_zero_dim 
      { \end{minipage} }
  }

\ExplSyntaxOff  
  

\NewDocumentCommand{\indexcommand}{m}{\index{#1@\texttt{\textbackslash #1}}}

\NewDocumentCommand{\indexenv}{m}{\index{#1@\texttt{\{#1\}}}}


\usepackage[hyperfootnotes = false]{hyperref}

\hypersetup
  {
    pdfinfo =
      {
        Title = L’extension nicematrix ,
        Subject = Une extension LaTeX ,
        Author = F. Pantigny
      }
}



\begin{document}


\UseName{VerbatimFootnotes}

\title{L'extension \pkg{nicematrix}
       \thanks{Ce document correspond à la version~\myfileversion\space de \pkg{nicematrix},
         en date du~\myfiledate.}}

     
\author{F. Pantigny \\ \texttt{fpantigny@wanadoo.fr}}


\maketitle

\begin{abstract}
L'extension LaTeX \pkg{nicematrix} fournit de nouveaux environnements similaires
aux environnements classiques |{tabular}|, |{array}| et |{matrix}| de
\pkg{array} et \pkg{amsmath} mais avec des fonctionnalités plus étendues.
\end{abstract}

\vspace{1cm}

\hspace{1cm}
$\begin{bNiceArray}{cccc}[first-row,first-col,
                          code-for-first-col=\color{blue}\scriptstyle,
                          code-for-first-row=\color{blue}\scriptstyle,
                          columns-width = auto]
       & C_1     & C_2    & \Cdots  & C_n    \\
L_1    & a_{11}  & a_{12}  & \Cdots  & a_{1n} \\
L_2    & a_{21}  & a_{22}  & \Cdots  & a_{2n} \\
\Vdots & \Vdots & \Vdots  & \Ddots  & \Vdots \\
L_n    & a_{n1}  & a_{n2}  & \Cdots  & a_{nn}
\end{bNiceArray}$
\hspace{2cm}
\begin{NiceTabular}[c]{lSSSS}[no-cell-nodes]
\CodeBefore
  \rowcolor{red!15}{1-2} 
  \rowcolors{3}{blue!15}{}
\Body
  \toprule
  \Block[C]{2-1}{Produit} & \multicolumn{3}{c}{dimensions (cm)} 
   & \Block[C]{2-1}{\rotate Prix} \\
  \cmidrule(rl){2-4}
   & L & l & h \\
  \midrule
  petit    & 3   & 5.5  & 1   & 30    \\
  standard & 5.5 & 8    & 1.5 & 50.5  \\
  premium  & 8.5 & 10.5 & 2   & 80    \\
  extra    & 8.5 & 10   & 1.5 & 85.5  \\
  spécial  & 12  & 12   & 0.5 & 70    \\
\bottomrule
\end{NiceTabular}



\vspace{1cm}

L'extension \pkg{nicematrix} est entièrement contenue dans le fichier
|nicematrix.sty|. Ce fichier peut être placé dans le répertoire courant ou dans
une arborescence |texmf|. Le mieux reste néanmoins d'installer \pkg{nicematrix}
avec une distribution TeX comme MiKTeX, TeX~Live ou MacTeX.

\medskip
\emph{Remarque} : Si vous utilisez un service LaTeX via Internet (ex. : Overleaf
ou TeXPage) vous pouvez télécharger le fichier |nicematrix.sty| dans le dossier
de votre projet pour bénéficier de la dernière version de
\pkg{nicematrix}.\footnote{La dernière version de |nicematrix.sty| peut être
  téléchargée sur le dépôt Github de \pkg{nicematrix} : \newline \small
  \url{https://github.com/fpantigny/nicematrix/releases}}

\medskip
Cette extension peut être utilisée avec |xelatex|, |lualatex| et |pdflatex| mais
aussi avec le cheminement classique |latex|-|dvips|-|ps2pdf| (ou Adobe
Distiller). \textsl{Néanmoins, le fichier nicematrix-french.tex de la présente
  documentation ne peut être compilé qu'avec LuaLaTeX.}

\medskip
Cette extension nécessite et charge les extensions \pkg{l3keys2e}, \pkg{array},
\pkg{amsmath} et \pkg{pgfcore} ainsi que le module \pkg{shapes} de \textsc{pgf}
(l'extension \pkg{tikz}, qui est une surcouche de \textsc{pgf}, n'est \emph{pas}
chargée). L'utilisateur final n'a qu'à charger l'extension \pkg{nicematrix} avec
l'instruction habituelle : |\usepackage{nicematrix}|.


\medskip
L'idée de \pkg{nicematrix} est de créer des nœuds \textsc{pgf} derrière les
cases et les positions des filets des tableaux créés par \pkg{array} et de les
utiliser pour développer de nouvelles fonctionnalités. Comme toujours avec
\textsc{pgf}, les coordonnées de ces nœuds sont écrites dans le fichier |aux|
pour être utilisées à la compilation suivante. C'est pourquoi l'utilisation de
\pkg{nicematrix} nécessite \textbf{plusieurs compilations
  successives}\footnote{Si vous utilisez Overleaf, Overleaf effectue
  automatiquement un nombre de compilations suffisant (en utilisant
  |latexmk|).}. L'utilisateur ne doit pas utiliser la commande |\nofiles| (qui
bloque l'écriture du fichier |aux|).

\medskip
La plupart des fonctionnalités de \pkg{nicematrix} sont accessibles sans avoir à
utiliser explicitement \textsc{pgf} ou TikZ (ce dernier n'est d'ailleurs pas
chargé par défaut).

\medskip
\indexcommand{NiceMatrixOptions}
Une commande |\NiceMatrixOptions| est fournie pour régler les options (la portée
des options fixées par cette commande est le groupe TeX courant : elles sont
semi-globales).



\newpage

\section{Les environnements de cette extension}


\indexenv{NiceTabular}
\indexenv{NiceTabular*}
\indexenv{NiceArray}
\indexenv{pNiceArray}
\indexenv{bNiceArray}
\indexenv{BNiceArray}
\indexenv{vNiceArray}
\indexenv{VNiceArray}
\indexenv{NiceMatrix}
\indexenv{pNiceMatrix}
\indexenv{bNiceMatrix}
\indexenv{BNiceMatrix}
\indexenv{vNiceMatrix}
\indexenv{VNiceMatrix}


L'extension \pkg{nicematrix} définit les nouveaux environnements suivants :

\medskip
\begin{ttfamily}
\setlength{\tabcolsep}{3mm}
\begin{tabular}{llll}
\{NiceTabular\}  & \{NiceArray\}  & \{NiceMatrix\}   \\
\{NiceTabular*\} & \{pNiceArray\} & \{pNiceMatrix\}  \\
\{NiceTabularX\} & \{bNiceArray\} & \{bNiceMatrix\}  \\
                 & \{BNiceArray\} & \{BNiceMatrix\}  \\
                 & \{vNiceArray\} & \{vNiceMatrix\}  \\
                 & \{VNiceArray\} & \{VNiceMatrix\}
\end{tabular}
\end{ttfamily}


\medskip
Les environnements |{NiceArray}|, |{NiceTabular}| et |{NiceTabular*}| sont
similaires aux environnements |{array}|, |{tabular}| et |{tabular*}| de
l'extension \pkg{array} (qui est chargée par \pkg{nicematrix}).


\medskip
Les environnements |{pNiceArray}|, |{bNiceArray}|, etc. n'ont pas d'équivalents
dans \pkg{array}.

\medskip
Les environnements |{NiceMatrix}|, |{pNiceMatrix}|, etc. sont similaires aux
environnements correspondants de l'\pkg{amsmath} (qui est chargée par
\pkg{nicematrix}) : |{matrix}|, |{pmatrix}|, etc.

\medskip
L'environnement |{NiceTabularX}| est similaire à l'environnement
|{tabularx}| de l'extension éponyme.\footnote{Néanmoins, on peut aussi utiliser
  directement les colonnes |X| dans l'environnement |{NiceTabular}|, la largeur
  souhaitée pour le tableau étant spécifiée par la clé |width|:
  cf.~p.~\pageref{colonne-X}.}


\medskip
\textbf{On conseille d'utiliser prioritairement les environnements classiques et de
n'utiliser les environnements de \pkg{nicematrix} que lorsqu'on utilise les
fonctionnalités supplémentaires offertes par ces environnements (cela permet
d'économiser la mémoire).}

\medskip
Tous les environnements de l'extension \pkg{nicematrix} acceptent, entre
crochets, une liste optionnelle de paires de la forme \textsl{clé=valeur}.
\textbf{Il doit n'y avoir aucun espace devant le crochet ouvrant (|[|) de
  cette liste d'options.}



\section{L'espace vertical entre les rangées}

\label{cell-space-limits}
\index{cell-space-top-limit}
\index{cell-space-bottom-limit}
\index{cell-space-limits}

Il est bien connu que certaines rangées\footnote{Dans ce document, on parlera de
  \emph{rangée} pour désigner uniquement les rangées horizontales. Les colonnes,
  par opposition, sont verticales.} des tableaux créés par défaut avec LaTeX
sont trop proches l'une de l'autre. On en donne ci-dessous un exemple classique.

\medskip
\begin{Code}[width=9cm]
$\begin{pmatrix}
\frac{1}{2} & -\frac{1}{2} \\
\frac{1}{3} & \frac{1}{4} \\
\end{pmatrix}$
\end{Code}
$\begin{pmatrix}
\frac{1}{2} & -\frac{1}{2} \\
\frac{1}{3} & \frac{1}{4} \\
\end{pmatrix}$

\medskip
En s'inspirant de l'extension \pkg{cellspace} qui traite de ce problème,
l'extension \pkg{nicematrix} propose deux clés \Definition{cell-space-top-limit}
et \Definition{cell-space-bottom-limit} qui sont similaires aux deux paramètres
|\cellspacetoplimit| et |\cellspacebottomlimit| proposés par \pkg{cellspace}.

\index{cellspace@\pkg{cellspace} (extension)}

Il existe aussi une clé \Definition{cell-space-limits} pour régler simultanément
les deux paramètres.

La valeur initiale de ces paramètres est $0$~pt pour que les environnements de
\pkg{nicematrix} aient par défaut le même comportement que ceux de \pkg{array}
et de l'\pkg{amsmath} mais une valeur de $1$~pt serait un bon choix. On
conseille de régler leurs valeurs avec la commande
|\NiceMatrixOptions|.\footnote{On remarquera que ces paramètres s'appliquent
  aussi aux colonnes de type |S| de \pkg{siunitx} alors que \pkg{cellspace}
  n'est pas utilisable avec ces colonnes.}

\medskip
\begin{Code}
\NiceMatrixOptions{\emph{cell-space-limits = 1pt}}
\end{Code}

\medskip

\begin{Code}[width=9cm]
$\begin{pNiceMatrix}
\frac{1}{2} & -\frac{1}{2} \\
\frac{1}{3} & \frac{1}{4} \\
\end{pNiceMatrix}$
\end{Code}
\begin{scope}
\NiceMatrixOptions{ cell-space-limits = 1pt }
$\begin{pNiceMatrix}[no-cell-nodes]
\frac{1}{2} & -\frac{1}{2} \\
\frac{1}{3} & \frac{1}{4} \\
\end{pNiceMatrix}$
\end{scope}

\bigskip
Il est également possible de changer ces paramètres pour certaines rangées du
tableau seulement grâce à la commande |\RowStyle| (cf.~p.~\pageref{RowStyle}).



\medskip
\section{La clé baseline}

\index{baseline (clé pour un environnement)}

L'extension \pkg{nicematrix} propose une option \Definition{baseline} pour la
position verticale des tableaux. Cette option |baseline| prend comme valeur un
entier qui indique le numéro de rangée dont la ligne de base servira de ligne de
base pour le tableau.

\medskip
\begin{Code}[width=9cm]
$A = \begin{pNiceMatrix}[\emph{baseline=2}]
\frac{1}{\sqrt{1+p^2}} & p & 1-p \\
1 & 1 & 1 \\
1 & p & 1+p
\end{pNiceMatrix}$
\end{Code}
$A = \begin{pNiceMatrix}[baseline=2,no-cell-nodes]
\frac{1}{\sqrt{1+p^2}} & p & 1-p \\
1 & 1 & 1 \\
1 & p & 1+p
\end{pNiceMatrix}$


\interitem L'option |baseline| peut aussi prendre les trois valeurs spéciales
|t|, |c| et |b|. Ces trois lettres peuvent aussi être utilisées de manière
absolue comme pour l'option des environnements |{tabular}| et |{array}| de
\pkg{array}. La valeur initiale de |baseline| est~|c|.


\medskip
Dans l'exemple suivant, on utilise l'option |t| (synonyme de |baseline=t|)
immédiatement après un |\item| de liste. On remarquera que la présence d'un
|\hline| initial n'empêche pas l'alignement sur la ligne de base de la première
rangée (avec |{tabular}| ou |{array}| de \pkg{array}, il faut utiliser
|\firsthline|).



\smallskip
\begin{Code}[width=9cm]
\begin{enumerate}
\item un item
\smallskip
\item \renewcommand{\arraystretch}{1.2}
$\begin{NiceArray}\emph{[t]}{lcccccc}
\hline
n   & 0 & 1 & 2 & 3 & 4  & 5 \\
u_n & 1 & 2 & 4 & 8 & 16 & 32
\hline
\end{NiceArray}$
\end{enumerate}
\end{Code}
%
\begin{minipage}{5cm}
\begin{enumerate}
\item un item
\smallskip
\item \renewcommand{\arraystretch}{1.2}
$\begin{NiceArray}[t]{lcccccc}[no-cell-nodes]
\hline
n   & 0 & 1 & 2 & 3 & 4  & 5  \\
u_n & 1 & 2 & 4 & 8 & 16 & 32 \\
\hline
\end{NiceArray}$
\end{enumerate}
\end{minipage}


\medskip
Il est également possible d'utiliser les outils de \pkg{booktabs}: |\toprule|,
|\bottomrule|, |\midrule|, etc., à condition, bien entendu, d'avoir chargé
\pkg{booktabs}.

\nobreak
\smallskip
\begin{Code}[width=9cm]
\begin{enumerate}
\item an item
\smallskip
\item
$\begin{NiceArray}[t]{lcccccc}
\emph{\toprule}
n   & 0 & 1 & 2 & 3 & 4  & 5 \\
\emph{\midrule}
u_n & 1 & 2 & 4 & 8 & 16 & 32
\emph{\bottomrule}
\end{NiceArray}$
\end{enumerate}
\end{Code}
\begin{minipage}{5cm}
\begin{enumerate}
\item an item
\smallskip
\item
$\begin{NiceArray}[t]{lcccccc}[no-cell-nodes]
\toprule
n   & 0 & 1 & 2 & 3 & 4  & 5  \\
\midrule
u_n & 1 & 2 & 4 & 8 & 16 & 32 \\
\bottomrule
\end{NiceArray}$
\end{enumerate}
\end{minipage}


\medskip
On peut aussi utiliser la clé |baseline| pour aligner une matrice sur un filet
horizontal (tracé par |\hline|). On doit pour cela donner la valeur
|line-|\textsl{i} où \textsl{i} est le numéro de la rangée qui \emph{suit} ce filet
horizontal.

\smallskip
\begin{Code}
\NiceMatrixOptions{cell-space-limits=1pt}
\end{Code}

\smallskip
\begin{Code}[width=9cm]
$A=\begin{pNiceArray}{cc|cc}\emph{[baseline=line-3]}
\dfrac{1}{A} & \dfrac{1}{B} & 0 & 0 \\
\dfrac{1}{C} & \dfrac{1}{D} & 0 & 0 \\
\hline
0 & 0 & A & B \\
0 & 0 & D & D \\
\end{pNiceArray}$
\end{Code}
\begin{scope}
\NiceMatrixOptions{cell-space-limits=1pt}
\raisebox{-5mm}{$A=\begin{pNiceArray}{cc|cc}[baseline=line-3,no-cell-nodes]
\dfrac{1}{A} & \dfrac{1}{B} & 0 & 0 \\
\dfrac{1}{C} & \dfrac{1}{D} & 0 & 0 \\
\hline
0 & 0 & A & B \\
0 & 0 & D & D \\
\end{pNiceArray}$}
\end{scope}



\section{Les blocs}

\label{Block}
\index{Blocs@\textbf{Blocs dans les tableaux}|(}
\indexcommand{Block}

\subsection{Cas général}


Dans les environnements de \pkg{nicematrix}, on peut utiliser la commande
\DefinitionCommande{Block} pour placer un élément au centre d'un rectangle de cases
fusionnées.\footnote{Les espaces situés après une commande |\Block| sont supprimés.}

La commande |\Block| doit être utilisée dans la case supérieure gauche du bloc
avec deux arguments obligatoires.

\begin{itemize}
\item Le premier argument est la taille de ce bloc avec la syntaxe $i$-$j$ où
$i$ est le nombre de rangées et $j$ le nombre de colonnes du bloc.

Si cet argument est laissé blanc, la valeur par défaut est |1-1|. Si le nombre
de rangées n'est pas indiqué, ou bien est égal à |*|, le bloc s'étend jusqu'à la
dernière rangée (idem pour les colonnes).

\item Le deuxième argument est le contenu du bloc. 

Dans |{NiceTabular}|, |{NiceTabular*}| et |{NiceTabularX}|, le contenu est
composé en mode texte tandis que, dans les autres environnements, il est composé
en mode mathématique.
\end{itemize}

\interitem
Voici un exemple d'utilisation de la commande |\Block| dans une matrice mathématique.

\medskip
\begin{Code}[width=10.6cm]
$\begin{bNiceArray}{cw{c}{1cm}c|c}[margin]
\emph{\Block{3-3}{A}} & & & 0 \\
& & & \Vdots \\
& & & 0 \\
\hline
0 & \Cdots& 0 & 0
\end{bNiceArray}$
\end{Code}
$\begin{bNiceArray}{cw{c}{1cm}c|c}[margin]
\Block[C]{3-3}{A} & & & 0 \\
& & & \Vdots \\
& & & 0 \\
\hline
0 & \Cdots& 0 & 0
\end{bNiceArray}$



\medskip
On peut souhaiter agrandir la taille du «$A$» placé dans le bloc de l'exemple
précédent. Comme il est composé en mode mathématique, on ne peut pas directement
utiliser une commande comme |\large|, |\Large| ou |\LARGE|. C'est pourquoi une
option à mettre entre chevrons est proposée par |\Block| pour spécifier du code
LaTeX qui sera inséré \emph{avant} le début du mode mathématique.\footnote{Cet
  argument entre chevrons peut aussi être utilisé pour insérer une commande de
  fonte comme |\bfseries|, ce qui peut être utile dans le cas où la commande |\\| apparaît dans le
  contenu du bloc. On peut aussi y mettre la commmande |\rotate| fournie par
  \pkg{nicematrix} (cf. partie~\ref{rotate}, p.~\pageref{rotate}).}

\medskip
\begin{Code}[width=10.6cm]
$\begin{bNiceArray}{cw{c}{1cm}c|c}[margin]
\Block{3-3}\emph{<\LARGE>{A}} & & & 0 \\
& & & \Vdots \\
& & & 0 \\
\hline
0 & \Cdots& 0 & 0
\end{bNiceArray}$
\end{Code}
$\begin{bNiceArray}{cw{c}{1cm}c|c}[margin]
\Block[C]{3-3}<\LARGE>{A} & & & 0 \\
& & & \Vdots \\
& & & 0 \\
\hline
0 & \Cdots& 0 & 0
\end{bNiceArray}$


\interitem
La commande |\Block| accepte en premier argument optionnel (entre crochets) une
liste de couples \textsl{clé=valeur}. 

\smallskip
Les premières clés sont des outils rapides pour contrôler l'apparence du bloc :

\begin{itemize}[beginpenalty=10000]
\item \index{fill!clé de \texttt{\textbackslash Block}}
la clé \Definition{fill} prend en argument une couleur et remplit le bloc
avec cette couleur ;
\item \index{opacity!clé de la commande \texttt{\textbackslash Block}}
la clé \Definition{opacity} fixe l'opacité de la couleur de remplissage donnée
par |fill| ;\footnote{Attention : cette fonctionnalité génère des
  instructions de transparence dans le \textsc{pdf} résultant et certains
  lecteurs de \textsc{pdf} n'acceptent pas la transparence.}
\item \index{draw (clé de \texttt{\textbackslash Block})}
la clé \Definition{draw} prend en argument une couleur et trace le cadre
avec cette couleur (la valeur par défaut de cette clé est la couleur courante
des filets du tableau) ;
\item \index{color!clé de \texttt{\textbackslash Block}} 
la clé \Definition{color} prend en argument une couleur et l'applique au
contenu et trace également le cadre avec cette couleur ;
\item \index{vlines!clé de \texttt{\textbackslash Block}}
\index{hvlines!clé de
  \texttt{\textbackslash Block}}
\index{hlines!clé de \texttt{\textbackslash Block}}
les clés \Definition{hlines}, \Definition{vlines} et \Definition{hvlines}
tracent les filets correspondants dans le bloc\footnote{Néanmoins, les filets ne
  sont pas tracés dans les sous-blocs du bloc, conformément à l'esprit de
  \pkg{nicematrix}: les filets ne sont pas tracés dans les blocs, sauf s'ils
  possèdent la clé |transparent| (cf.
  section~\ref{rules} p.~\pageref{rules}).} ;
\item \index{line-width (clé de \texttt{\textbackslash Block})}
la clé \Definition{line-width} fixe la largeur utilisée pour tracer les
filets (n'a d'intérêt que si |draw|, |hvlines|,
|hlines| ou |vlines| est utilisée) ;
\item \index{rounded-corners!clé de \texttt{\textbackslash Block}}
\index{Coins arrondis!pour un bloc}
la clé \Definition{rounded-corners} impose des coins arrondis (pour le
cadre dessiné par |draw| et le fond dessiné par |fill|)
avec un rayon égal à la valeur de cette clé (la valeur par défaut est
4~pt\footnote{Cette valeur par défaut est la valeur initiale des \emph{rounded
    corners} de TikZ.}). 
\end{itemize}

\medskip
Ces outils ne sont parfois pas suffisants pour contrôler l'apparence du bloc.
Les clés suivantes sont plus puissantes, mais plus difficiles d'utilisation.
Elles nécessitent également que TikZ soit chargé (par |\usepackage{tikz}|). Par
défaut, \pkg{nicematrix} ne charge pas TikZ mais uniquement \textsc{pgf}, qui
est une sous-couche de TikZ.
\begin{itemize}
\item \index{borders (clé de \texttt{\textbackslash Block})}
\index{tikzz@tikz!clé de «borders» de \texttt{\textbackslash Block}}
La clé \Definition{borders} permet de ne tracer que certaines des bordures
du bloc : cette clé prend comme valeur une liste d'éléments parmi les suivants :
|left|, |right|, |top| et |bottom| ; on peut en fait, dans la liste qui est la
valeur de la clé |borders| mettre une entrée de la forme
|tikz={|\textsl{liste}|}| où \textsl{liste} est une liste de couples
\textsl{clé=valeur} de TikZ spécifiant les caractéristiques graphiques des
traits qui seront dessinés (pour un exemple, voir p.~\pageref{ex:tiretes}).

\item \index{tikzz@tikz!clé de \texttt{\textbackslash Block}}
Quand la clé \Definition{tikz} est utilisée, le chemin TikZ correspondant
au rectangle délimitant le bloc est exécuté avec TikZ\footnote{TikZ doit être
  chargé préalablement (par défaut, \pkg{nicematrix} ne charge que
  \textsc{pgf}), faute de quoi, une erreur sera levée.} en utilisant comme
options la valeur de cette clé |tikz| (qui doit donc être une liste de clés TikZ
applicables à un chemin de TikZ). Pour des exemples d'utilisation de cette clé
|tikz|, voir p.~\pageref{ex:tikz-key}.

En fait, dans la liste des clés fournies à |tikz|, on peut mettre une clé
\Definition{offset}. Cette clé n'est pas fournie par TikZ mais par
\pkg{nicematrix}. Elle réduit le rectangle correspondant au bloc par une marge
(horizontalement et verticalement) égale à la valeur (passée à |offset|). C'est
ce rectangle réduit qui sera le chemin exécuté par TikZ avec comme options les
autres clés passées à la clé |tikz|.
\end{itemize}


\medskip
Enfin, il existe quelque clés techniques :
\begin{itemize}[beginpenalty=10000]
\item \index{name!clé de \texttt{\textbackslash Block}}
la clé \Definition{name} donne un nom au nœud TikZ rectangulaire
correspondant au bloc ; on peut utiliser ce nom avec TikZ dans le |\CodeAfter|
(cf.~p.~\pageref{code-after});
\item \index{respect-arraystretch (clé de \texttt{\textbackslash Block})}
la clé \Definition{respect-arraystretch} évite la remise à $1$ de
|\arraystretch| en début de bloc (qui a lieu par défaut) ;
\item \index{transparent (clé de \texttt{\textbackslash Block})}
Par défaut, les filets ne sont pas tracés dans les blocs (voir à ce sujet
la partie sur les filets, section~\ref{rules} p.~\pageref{rules}). Néanmoins, si
la clé \Definition{transparent} est utilisée, les filets seront tracés.\footnote{Par
ailleurs, la commande |\TikzEveryCell| disponible dans le |\CodeAfter| et le
|\CodeBefore|, ne s'applique aux blocs avec la clé |transparent|.}

Pour un exemple, voir la section~\ref{ex:tikz-key},
page~\pageref{ex:tikz-key}. 

Attention : cette clé n'implique pas du tout que le contenu du bloc sera
transparent.
\end{itemize}

Il existe aussi des clés de positionnement horizontal et vertical du bloc qui
sont décrites ci-dessous (cf. \ref{horizontal-pos-block} p.~\pageref{horizontal-pos-block}).


\interitem
\textbf{On doit remarquer que, par défaut, les blocs ne créent pas d'espace}. Il
n'y a exception que pour les blocs mono-rangée et les blocs mono-colonne dans
certaines conditions comme expliqué plus loin.


\medskip
Dans l'exemple suivant, on a dû élargir à la main les colonnes 2 et 3 (avec la
construction |w{c}{...}| de \pkg{array}).

\medskip
\begin{Code}
\begin{NiceTabular}{cw{c}{2cm}w{c}{3cm}c}
rose      & tulipe & marguerite & dahlia \\
violette
& \emph{\Block[draw=red,fill=[RGB]{204,204,255},rounded-corners]{2-2}
        {\LARGE De très jolies fleurs}}
   & & souci \\
pervenche & & & lys \\
arum      & iris & jacinthe & muguet
\end{NiceTabular}
\end{Code}


\medskip
\begin{center}
\begin{NiceTabular}{cw{c}{2cm}w{c}{3cm}c}
rose      & tulipe & marguerite & dahlia \\
violette  & \Block[C,draw=red,fill=[RGB]{204,204,255},rounded-corners]{2-2}
  {\LARGE De très jolies fleurs} & & souci \\
pervenche & & & lys \\
arum      & iris & jacinthe & muguet
\end{NiceTabular}
\end{center}


\subsection{Les blocs mono-colonne}

Les blocs mono-colonne ont un comportement spécial.
\begin{itemize}[beginpenalty=10000]
\item La largeur naturelle du contenu de ces blocs est prise en compte pour la
largeur de la colonne courante.

Dans les colonnes à largeur fixée (|p{...}|, |b{...}|, |m{...}|,
|w{...}{...}|, |W{...}{...}|, |V{...}|, similaires aux colonnes |V| de
\pkg{varwidth}, et~|X|, similaires aux colonnes |X| de \pkg{tabularx}), le contenu
du bloc est mis en forme comme un paragraphe de cette largeur.

\item La spécification d'alignement horizontal donnée par le type de colonne
(|c|, |r| ou |l|) est prise en compte pour le bloc. Pour un bloc dans une
colonne de type |p{...}|, |b{...}|, |m{...}|, |V{...}| ou |X|, c'est un
alignement |c| qui est retenu par défaut. Néanmoins, ces types de colonnes
peuvent avoir une option d'alignement (par ex. |p[l]{...}|), et dans ce cas-là,
c'est cette option d'alignement qui est transmise au bloc.

Notons enfin que le bloc peut avoir sa propre spécification d'alignement
horizontal : cf.~\ref{horizontal-pos-block} p.~\pageref{horizontal-pos-block}.

\item Les spécifications de fontes imposées à une colonne via la construction
|>{...}| dans le préambule du tableau sont prises en compte pour les
blocs mono-colonne de cette colonne (ce comportement est assez naturel).
\end{itemize}


\medskip
\begin{scope}
\hfuzz=10cm
\begin{Code}[width=12cm]
\begin{NiceTabular}{@{}>{\color{blue}}lr@{}} \hline
\Block{2-1}{Pierre}    & 12 \\
                       & 13 \\ \hline
Jacques                &  8 \\ \hline
\Block{3-1}{Stéphanie} & 18 \\
                       & 17 \\
                       & 15 \\ \hline
Amélie                 & 20 \\ \hline
Henri                  & 14 \\ \hline
\Block{2-1}{Estelle}   & 15 \\
                       & 19 \\ \hline
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{@{}>{\color{blue}}lr@{}} \hline
\Block{2-1}{Pierre}    & 12 \\
                       & 13 \\ \hline
Jacques                &  8 \\ \hline
\Block{3-1}{Stéphanie} & 18 \\
                       & 17 \\
                       & 15 \\ \hline
Amélie                 & 20 \\ \hline
Henri                  & 14 \\ \hline
\Block{2-1}{Estelle}   & 15 \\
                       & 19 \\ \hline
\end{NiceTabular}
\end{scope}


\subsection{Les blocs mono-rangée}

Pour les blocs mono-rangée, la hauteur (\emph{height}) et la profondeur
(\emph{depth}) naturelles sont prises en compte pour la hauteur et la largeur de
la rangée en cours (comme le fait la commande standard |\multicolumn| de LaTeX),
sauf lorsqu'une option de placement vertical a été utilisée pour le bloc (une
des clés |t|, |b|, |m|, |T| et |B| décrites à la partie
\ref{vertical-pos-block}, p.~\pageref{vertical-pos-block}). 


\subsection{Les blocs mono-case}

Les blocs mono-case héritent des caractéristiques des blocs mono-colonne et
des blocs mono-rangée.

\medskip
On pourrait penser que des blocs d'une seule case n'ont aucune utilité mais, en
fait, il y a plusieurs situations où leur utilisation peut présenter des avantages.

\begin{itemize}
\item Un bloc mono-case permet d'utiliser la commande |\\| pour composer le
bloc sur plusieurs lignes de texte.

\item On peut utiliser l'option d'alignement horizontal du bloc pour déroger à
  la consigne générale donnée dans le préambule pour cette colonne (cf.~\ref{horizontal-pos-block}
  p.~\pageref{horizontal-pos-block}).

\item On peut tracer un cadre autour du bloc avec la clé |draw| de la commande
|\Block| ou colorier le fond avec des bords arrondis avec les clés |fill| et
|rounded-corners|.\footnote{Pour colorier simplement le fond d'une case, il n'y a pas besoin
  d'utiliser un bloc mono-case : on peut utiliser la commande |\cellcolor|.}

\item On peut tracer une ou plusieurs bordures de la case avec la clé |borders|.
\end{itemize}

\medskip
\begin{Code}[width=10cm]
\begin{NiceTabular}{cc}
\toprule
Écrivain
& \emph{\Block[l]{}{année de\\ naissance}} \\
\midrule
Hugo & 1802 \\
Balzac & 1799 \\
\bottomrule
\end{NiceTabular}
\end{Code}
%
\begin{NiceTabular}{cc}[no-cell-nodes]
\toprule
Écrivain
& \Block[l]{}{année de\\ naissance} \\
\midrule
Hugo & 1802 \\
Balzac & 1799 \\
\bottomrule
\end{NiceTabular}

\medskip
On rappelle que si le premier argument obligatoire de |\Block| est laissé
blanc, alors le bloc est mono-case\footnote{On peut considérer que la valeur par
défaut de ce premier argument obligatoire est |1-1|.}.


\subsection{Positionnement horizontal du contenu des blocs}

\label{horizontal-pos-block}

La commande |\Block| admet les clés \Definition{l}, \Definition{c} et
\Definition{r} pour la position horizontale du contenu du bloc (calé à gauche,
centré ou bien calé à droite).

\medskip
\begin{Code}[width=10.6cm]
$\begin{bNiceArray}{cw{c}{1cm}c|c}[margin]
\Block\emph{[r]}{3-3}<\LARGE>{A} & & & 0 \\
& & & \Vdots \\
& & & 0 \\
\hline
0 & \Cdots& 0 & 0
\end{bNiceArray}$
\end{Code}
$\begin{bNiceArray}{cw{c}{1cm}c|c}[margin]
\Block[r]{3-3}<\LARGE>{A} & & & 0 \\
& & & \Vdots \\
& & & 0 \\
\hline
0 & \Cdots& 0 & 0
\end{bNiceArray}$

\bigskip
Par défaut, le positionnement horizontal des contenus des blocs est calculé sur
le \emph{contenu} des colonnes impliquées. De ce fait, dans l'exemple suivant,
l'en-tête «Premier groupe» est correctement centré même si un espacement
des colonnes a été demandé par une instruction comme |!{\qquad}| dans le
préambule (ce n'est pas le cas avec |\multicolumn|).

\medskip
\begin{center}
\begin{Code}
\begin{NiceTabular}{@{}c!{\qquad}ccc\emph{!{\qquad}}ccc@{}}
\toprule
Rang & \emph{\Block{1-3}{Premier groupe}} & & & \Block{1-3}{Deuxième groupe} \\
     & 1A & 1B & 1C & 2A & 2B & 2C \\
\midrule
 1 & 0.657 & 0.913 & 0.733 & 0.830 & 0.387 & 0.893\\
 2 & 0.343 & 0.537 & 0.655 & 0.690 & 0.471 & 0.333\\
 3 & 0.783 & 0.885 & 0.015 & 0.306 & 0.643 & 0.263\\
 4 & 0.161 & 0.708 & 0.386 & 0.257 & 0.074 & 0.336\\
\bottomrule
\end{NiceTabular}
\end{Code}
\end{center}

\medskip
\begin{center}
\begin{NiceTabular}{@{}c!{\qquad}ccc!{\qquad}ccc@{}}
\toprule
Rang & \Block{1-3}{Premier groupe} & & & \Block{1-3}{Deuxième groupe} \\
     & 1A & 1B & 1C & 2A & 2B & 2C \\
\midrule
 1 & 0.657 & 0.913 & 0.733 & 0.830 & 0.387 & 0.893\\
 2 & 0.343 & 0.537 & 0.655 & 0.690 & 0.471 & 0.333\\
 3 & 0.783 & 0.885 & 0.015 & 0.306 & 0.643 & 0.263\\
 4 & 0.161 & 0.708 & 0.386 & 0.257 & 0.074 & 0.336\\
\bottomrule
\end{NiceTabular}
\end{center}

\medskip
Pour avoir un positionnement horizontal du contenu du bloc qui s'appuie sur les
limites des colonnes du tableau LaTeX (et non sur le contenu de ces colonnes),
il faut utiliser les clés \Definition{L}, \Definition{R} et \Definition{C} de la
commande |\Block|.\footnote{On remarquera que les clés |L|, |R| et |C|
  nécessitent moins de calculs que les clés |l|, |r| et |c|. Si on tient à
  l'efficacité, on devrait écrire |\Block[C]| systématiquement par défaut.}

\medskip
Voici le même exemple avec la clé |C| pour le premier bloc.

\begin{center}
\begin{Code}
\begin{NiceTabular}{@{}c!{\qquad}ccc\emph{!{\qquad}}ccc@{}}
\toprule
Rang & \emph{\Block[C]{1-3}{Premier groupe}} & & & \Block{1-3}{Deuxième groupe} \\
     & 1A & 1B & 1C & 2A & 2B & 2C \\
\midrule
 1 & 0.657 & 0.913 & 0.733 & 0.830 & 0.387 & 0.893\\
 2 & 0.343 & 0.537 & 0.655 & 0.690 & 0.471 & 0.333\\
 3 & 0.783 & 0.885 & 0.015 & 0.306 & 0.643 & 0.263\\
 4 & 0.161 & 0.708 & 0.386 & 0.257 & 0.074 & 0.336\\
\bottomrule
\end{NiceTabular}
\end{Code}
\end{center}

\medskip
\begin{center}
\begin{NiceTabular}{@{}c!{\qquad}ccc!{\qquad}ccc@{}}[no-cell-nodes]
\toprule
Rang & \Block[C]{1-3}{Premier groupe} & & & \Block{1-3}{Deuxième groupe} \\
     & 1A & 1B & 1C & 2A & 2B & 2C \\
\midrule
 1 & 0.657 & 0.913 & 0.733 & 0.830 & 0.387 & 0.893\\
 2 & 0.343 & 0.537 & 0.655 & 0.690 & 0.471 & 0.333\\
 3 & 0.783 & 0.885 & 0.015 & 0.306 & 0.643 & 0.263\\
 4 & 0.161 & 0.708 & 0.386 & 0.257 & 0.074 & 0.336\\
\bottomrule
\end{NiceTabular}
\end{center}

\bigskip

La commande |\Block| accepte aussi les clés |p| et |j|. Avec la clé
\Definition{p}, le contenu du bloc est composé comme un paragraphe (de manière
similaire à une colonne standard de type |p|). Cette clé peut s'utiliser en
conjonction avec les clés |l|, |c| ou |r| et, alors, le paragraphe est composé
avec |\raggedright|, |\centering| ou |\raggedleft| (en fait, quand
\pkg{ragged2e} est chargée, ce sont les commandes
|\RaggedRight|, |\Centering| et |\RaggedLeft| fournies par cette extension qui
seront utilisées au lieu de |\raggedright|, |\centering| et |\raggedleft|).
Avec la clé \Definition{j} (qui force la clé |p|), le paragraphe est composé de
manière justifiée. 

\bigskip
On peut mettre un environnement |{itemize}| ou |{enumerate}| dans un bloc qui
utilise la clé |p| ou la clé |j| (dans les autres cas, on aura une erreur: 
|Not allowed in LR mode|). Dans l'exemple suivant, on a chargé l'extension
\pkg{enumitem} (pour pouvoir utiliser la clé |left| de l'environnement
|{itemize}|).

\medskip
\begin{Code}
\begin{NiceTabular}[hvlines]{ccc}
un & deux deux & trois trois \\
un & 
\Block\emph{[p,l]}{*-2}{%
\begin{itemize}[\emph{left=0pt}]
\item un deux trois quatre cinq 
\item deux 
\item trois
\end{itemize}%
} \\
un & \\
un & \\
un & \\
un & \\
un & \\
un & \\
\end{NiceTabular}
\end{Code}


\begin{center}
\begin{NiceTabular}[hvlines]{ccc}
un & deux deux & trois trois \\
un & 
\Block[p,l]{*-2}{%
\begin{itemize}[left=0pt]
\item un deux trois quatre cinq 
\item deux 
\item trois
\end{itemize}%
} \\
un & \\
un & \\
un & \\
un & \\
un & \\
un & \\
\end{NiceTabular}
\end{center}



\subsection{Positionnement vertical du contenu des blocs}


\label{vertical-pos-block}

Concernant le positionnement vertical, la commande |\Block| admet les clés
|m|, |t|, |b|, |T| et~|B|.


\begin{itemize}
\item \index{v-center (clé de \texttt{\textbackslash Block)})}
Avec la clé \Definition{m}\footnote{Cette clé a un alias : |v-center|.}, le
contenu du bloc est centré verticalement. 

\item Avec la clé \Definition{t}, la ligne de base du contenu du bloc est alignée avec la
ligne de base de la première rangée concernée par le bloc.

\item Avec la clé \Definition{b}, la ligne de base de la dernière rangée du
contenu du bloc (rappelons que le contenu du bloc peut comporter plusieurs
lignes de texte séparées par |\\|) est alignée avec la ligne de base de la
dernière des rangées du tableau impliquées dans le bloc.

\item Avec la clé \Definition{T}, le contenu du bloc est calé vers le haut.

Il n'y a pas de marge verticale. Néanmoins, le contenu du bloc est (toujours)
composé en interne dans une |{minipage}|, un |{tabular}| ou un |{array}|, ce qui
fait qu'il y a souvent déjà une marge. Si besoin est, on peut toujours ajouter
un |\strut|.

\item Avec la clé \Definition{B}, le contenu du bloc est calé vers le bas.
\end{itemize}

Quand aucune clé n'est donnée, c'est la clé |m| qui s'applique (sauf pour
les blocs mono-rangée).

\medskip
\begin{scope}
\NiceMatrixOptions{rules/color=[gray]{0.75}, hvlines}

\begin{Code}
\NiceMatrixOptions{rules/color=[gray]{0.75}, hvlines}
\end{Code}

\bigskip

\begin{Code}[width=10cm]
\begin{NiceTabular}{ccc}
\Block[fill=red!10,\emph{t},l]{4-2}{two\\lines}
 & & \Huge Un\\
 & & deux  \\
 & & trois  \\
 & & \Huge quatre  \\
text & text \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}
\Block[fill=red!10,t,l]{4-2}{two\\lines}
 & & \Huge Un\\
 & & deux  \\
 & & trois  \\
 & & \Huge quatre  \\
text & text \\
\end{NiceTabular}


\bigskip
\begin{Code}[width=10cm]
\begin{NiceTabular}{ccc}
\Block[fill=red!10,\emph{b},r]{4-2}{two\\lines}
 & & \Huge Un\\
 & & deux  \\
 & & trois  \\
 & & \Huge quatre  \\
text & text \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}
\Block[fill=red!10,b,r]{4-2}{two\\lines}
 & & \Huge Un\\
 & & deux  \\
 & & trois  \\
 & & \Huge quatre  \\
text & text \\
\end{NiceTabular}

\bigskip
\begin{Code}[width=10cm]
\begin{NiceTabular}{ccc}
\Block[fill=red!10,\emph{T},\emph{L}]{4-2}{two\\lines}
 & & \Huge Un\\
 & & deux  \\
 & & trois  \\
 & & \Huge quatre  \\
text & text \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}
\Block[fill=red!10,T,L]{4-2}{two\\lines}
 & & \Huge Un\\
 & & deux  \\
 & & trois  \\
 & & \Huge quatre  \\
text & text \\
\end{NiceTabular}


\bigskip
\begin{Code}[width=10cm]
\begin{NiceTabular}{ccc}
\Block[fill=red!10,\emph{B},\emph{R}]{4-2}{two\\lines}
 & & \Huge Un\\
 & & deux  \\
 & & trois  \\
 & & \Huge quatre  \\
text & text \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}
\Block[fill=red!10,B,R]{4-2}{two\\lines}
 & & \Huge Un\\
 & & deux  \\
 & & trois  \\
 & & \Huge quatre  \\
text & text \\
\end{NiceTabular}

\end{scope}


\subsection{\textbackslash\textbackslash\ et \& dans les blocs}

\index{ampersand-in-blocks}
\index{\&-in-blocks}

\medskip
L'extension \pkg{nicematrix} offre la possibilité d'utiliser directement |\\| et
|&| dans le contenu d'un bloc (dans le but de formater son contenu) mais il y a
quelques restrictions.

\begin{itemize}
\item On ne doit pas utiliser à la fois |&| et |\\| dans le même bloc.

\item Pour |\\|, il n'y a pas d'autres restrictions. On peut utiliser
|\\| dans un bloc pour composer du texte sur plusieurs lignes.  

\item Pour pouvoir utiliser |&|, la clé \Definition{ampersand-in-blocks} (alias:
\Definition{\&-in-blocks}) doit avoir été activée\footnote{Si ce n'est pas le cas,
  l'utilisation de |&| dans l'argument principal de la commande |\Block|
  provoquera une erreur : |! Extra alignment tab has been changed to \cr| de
  TeX.}. Le bloc est alors divisé en sous-blocs comme illustré ci-dessous.
Attention toutefois : quand |ampersand-in-blocks| est utilisée, l'argument
(principal) de la commande |\Block| est découpé syntaxiquement au niveau des
esperluettes |&|, celles entre accolades sont masquées mais pas celles dans un
environnement.\footnote{On ne peut donc pas écrire :
  |\Block[ampersand-in-blocks]{}{\begin{array}{cc}1&2\end{array}}|. Bien sûr, on
  peut le faire sans la clé |ampersand-in-blocks|.}
\end{itemize}

\bigskip
L'esperluette |&| permet de diviser horizontalement un bloc en sous-blocs
\emph{de même taille}.

\medskip
\begin{Code}[width=85mm]
\begin{NiceTabular}{ll}%
   [hvlines,\emph{ampersand-in-blocks}]
  & les cinq premiers entiers naturels \\
3 & \Block{}{un&deux&trois} \\
4 & \Block{}{un&deux&trois&quatre} \\
5 & \Block{}{un&deux&trois&quatre&cinq} \\
\end{NiceTabular}
\end{Code}
%
\begin{NiceTabular}{ll}%
   [hvlines,ampersand-in-blocks,no-cell-nodes]
  & les cinq premiers entiers naturels \\ 
3 & \Block{}{un & deux & trois} \\
4 & \Block{}{un& deux & trois & quatre} \\
5 & \Block{}{un & deux & trois & quatre & cinq} \\
\end{NiceTabular}

\medskip
Comme on le voit, chaque bloc (ici, à chaque fois mono-case) a été divisé en
sous-cases de \emph{même taille}. Dans le cas présent, on aurait peut-être
préféré le codage suivant :

\medskip
\begin{Code}[width=85mm]
\begin{NiceTabular}{lccccc}%
   [hvlines,\emph{ampersand-in-blocks}]
  & \Block{1-5}{les cinq premiers 
                 entiers naturels} \\ 
3 & \Block{1-5}{un & deux & trois} \\
4 & \Block{1-5}{un& deux & trois & quatre} \\
5 & un & deux & trois & quatre & cinq \\
\end{NiceTabular}
\end{Code}
%
\begin{NiceTabular}{lccccc}%
   [hvlines,ampersand-in-blocks,no-cell-nodes]
  & \Block{1-5}{les cinq premiers entiers naturels} \\ 
3 & \Block{1-5}{un & deux & trois} \\
4 & \Block{1-5}{un& deux & trois & quatre} \\
5 & un & deux & trois & quatre & cinq \\
\end{NiceTabular}

\medskip
Dans ce codage, il s'agit de blocs de taille |1-5| qui sont coupés en trois et
quatre sous-blocs.


\index{Blocs@\textbf{Blocs dans les tableaux}|)}

\section{Les filets horizontaux et verticaux}
\label{rules}
\index{Filets@\textbf{Filets dans les tableaux}|(}

Les techniques habituelles pour tracer des filets peuvent être utilisées dans
les environnements de \pkg{nicematrix}, à l'exception de |\vline|. Il y a
néanmoins quelques petites différences de comportement avec les environnements
classiques.


\medskip
\subsection{Quelques différences avec les environnements classiques}

\subsubsection{Les filets verticaux}

Dans les environnements de \pkg{nicematrix}, les filets verticaux spécifiés par
\verb+|+ dans le préambule des environnements ne sont jamais coupés, même en cas
de rangée incomplète ou de double filet horizontal spécifié par |\hline\hline|
(il n'y a pas besoin d'utiliser l'extension \pkg{hhline}).

\medskip
\begin{Code}[width=10cm]
\begin{NiceTabular}{|c|c|} \hline
Premier & Deuxième \\ \emph{\hline\hline}
Paul \\ \hline
Marie & Pauline \\ \hline
\end{NiceTabular}
\end{Code}
%
\begin{NiceTabular}{|c|c|}[c,no-cell-nodes] \hline
Premier & Deuxième \\ \hline\hline
Paul \\ \hline
Marie & Pauline \\ \hline
\end{NiceTabular}


\medskip
En revanche, les filets verticaux ne sont pas tracés à l'intérieur des blocs
(créés par |\Block|: cf.~p.~\pageref{Block}) ni dans les coins (dont la création
est demandée par la clé |corners|: cf.~p.~\pageref{corners}), ni dans les
éventuelles rangées extérieures (créées par les clés |first-row| et |last-row|:
cf.~p.~\pageref{exterior}). 


\medskip
\index{booktabs@\pkg{booktabs} (extension)}
Si vous utilisez \pkg{booktabs} (qui fournit |\toprule|, |\midrule|,
|\bottomrule|, etc.) et que vous tenez absolument à mettre des filets verticaux
(ce qui est contraire à l'esprit à \pkg{booktabs}), vous constaterez que les
filets tracés par \pkg{nicematrix} sont compatibles avec \pkg{booktabs}.
Remarquez que \pkg{nicematrix} ne charge \emph{pas} \pkg{booktabs}.

\medskip
\begin{Code}[width=10.5cm]
$\begin{NiceArray}{\emph{c|ccc}} \toprule
a & b & c & d \\ \midrule
1 & 2 & 3 & 4 \\
1 & 2 & 3 & 4 \\ \bottomrule
\end{NiceArray}$
\end{Code}
%
$\begin{NiceArray}{c|ccc}[no-cell-nodes]
\toprule
a & b & c & d \\
\midrule
1 & 2 & 3 & 4 \\
1 & 2 & 3 & 4 \\
\bottomrule
\end{NiceArray}$

\medskip
Il reste néanmoins possible de définir un spécificateur, nommé par
exemple~|I|, pour tracer des filets verticaux avec le comportement standard de \pkg{array}
:
%
\begin{Verbatim}
\newcolumntype{I}{!{\vrule}}
\end{Verbatim}


\subsubsection{La commande  \textbackslash cline}

\label{cline}
\index{cline@\texttt{\textbackslash cline} (commande de LaTeX)}

Les traits verticaux et horizontaux que l'on insère avec |\hline| et le
spécificateur de colonne «\verb+|+» de \pkg{array} rendent le tableau plus large
ou plus long d'une quantité égale à la largeur du trait (avec \pkg{array} et
aussi avec \pkg{nicematrix}).

\smallskip
Pour des raisons historiques, il n'en est pas de même pour la commande |\cline|,
comme on peut le voir avec l'exemple suivant.

\medskip
\begin{Code}[width=10cm]
\setlength{\arrayrulewidth}{2pt}
\begin{tabular}{cccc} \hline
A&B&C&D \\ \emph{\cline{2-2}}
A&B&C&D \\ \hline
\end{tabular}
\end{Code}
%
\begin{scope}
\setlength{\arrayrulewidth}{2pt}
\begin{tabular}[c]{cccc}
\hline
A&B&C&D \\
\cline{2-2}
A&B&C&D \\
\hline
\end{tabular}
\end{scope}

\medskip
\index{standard-cline}
Dans les environnements de \pkg{nicematrix}, cette situation est corrigée (il
est néanmoins possible de revenir au comportement par défaut de |\cline| avec la
clé \Definition{standard-cline}).

\medskip
\begin{Code}[width=10cm]
\setlength{\arrayrulewidth}{2pt}
\begin{NiceTabular}{cccc} \hline
A&B&C&D \\ \emph{\cline{2}}
A&B&C&D \\ \hline
\end{NiceTabular}
\end{Code}
%
\begin{scope}
\setlength{\arrayrulewidth}{2pt}
\begin{NiceTabular}[c]{cccc}[no-cell-nodes]
\hline
A&B&C&D \\
\cline{2}
A&B&C&D \\
\hline
\end{NiceTabular}
\end{scope}

\medskip
Dans les environnements de \pkg{nicematrix}, une instruction
|\cline{|\textsl{\texttt{i}}|}| est équivalente à
|\cline{|\textsl{\texttt{i}}|-|\textsl{\texttt{i}}|}|.

\subsection{L'épaisseur et la couleur des filets}

\indexcommand{arrayrulewidth}
\index{Couleur!des filets}
\index{width!sous-clé de «rules»} 
\index{rules (clé pour un environnement)}

Les environnements de \pkg{nicematrix} proposent une clé
\Definition{rules/width} pour fixer la largeur (on devrait plutôt dire
l'épaisseur) des filets dans l'environnement. En fait, cette clé ne fait que
fixer la valeur du paramètre dimensionnel de LaTeX |\arrayrulewidth|.

\smallskip
On sait que \pkg{colortbl} propose la commande |\arrayrulecolor| pour spécifier
la couleur de ces filets.

\smallskip
\indexcommand{arrayrulecolor} 
Avec \pkg{nicematrix}, il est possible de spécifier une couleur même si
\pkg{colortbl} n'est pas chargé. Par souci de compatibilité, la commande est
nommée également |\arrayrulecolor|. Néanmoins, \pkg{nicematrix} propose aussi
une clé \Definition{rules/color}, disponible dans |\NiceMatrixOptions| ou dans un
environnement individuel, pour fixer la couleur des filets. Cette clé fixe
localement la couleur des filets (alors que la commande |\arrayrulecolor| agit
globalement !). Elle est à privilégier.

\medskip
\begin{Code}[width=15cm]
\begin{NiceTabular}{|ccc|}[\emph{rules/color=[gray]{0.9},rules/width=1pt}]
\hline
rose & tulipe & lys \\
arum & iris & violette \\
muguet & dahlia & souci \\
\hline
\end{NiceTabular}
\end{Code}
\hspace{-5cm}
\begin{NiceTabular}{|ccc|}[rules/color=[gray]{0.9},rules/width=1pt,no-cell-nodes]
\hline
rose & tulipe & lys \\
arum & iris & violette \\
muguet & dahlia & souci \\
\hline
\end{NiceTabular}


\medskip
En fait, dans cet exemple, au lieu de |\hline|, il aurait mieux valu utiliser la
commande |\Hline|, fournie par \pkg{nicematrix} et décrite ci-dessous, car elle
garantit un meilleur résultat dans les lecteurs de PDF aux bas niveaux de zoom.



\medskip
\subsection{Les outils de nicematrix pour tracer des filets}



Les outils proposés par \pkg{nicematrix} pour tracer des filets sont les
suivants :
\begin{itemize}[beginpenalty=10000]
\item les clés |hlines|, |vlines|, |hvlines| et |hvlines-except-borders|;
\item le spécificateur «\verb+|+» dans le préambule (pour les environnements à
préambule) ;
\item \indexcommand{Hline}
la commande |\Hline|.
\end{itemize}

\medskip
\textbf{Ces outils ont en commun de ne pas tracer les filets dans les blocs ni
  dans les coins vides (quand la clé |corners| est utilisée), ni dans les
  rangées et colonnes extérieures.}
\begin{itemize}
\item Les blocs en question sont :
\begin{itemize}
\item ceux créés par la commande |\Block|\footnote{Et aussi la commande |\multicolumn| même s'il
  est recommandé d'utiliser plutôt |\Block| quand on utilise l'extension
  \pkg{nicematrix}.} de \pkg{nicematrix} présentée
p.~\pageref{Block};
\item ceux délimités implicitement par des lignes en pointillés continues, créées
par |\Cdots|, |\Vdots|, etc. : cf.~p.~\pageref{Cdots}.
\end{itemize}
\item Les coins sont créés par la clé |corners| détaillée un peu plus loin : cf.
p.~\pageref{corners}.
\item Pour les rangées et colonnes extérieures, cf. p.~\pageref{exterior}.
\end{itemize}

En particulier, cette remarque montre déjà une différence entre la commande
standard |\hline| et la commande |\Hline| proposée par \pkg{nicematrix}.

Par ailleurs, la commande |\Hline| admet entre crochets un argument optionnel
qui est une liste de couples \textsl{clé=valeur} qui décrivent un filet. Pour la
description de ces clés, voir |custom-line|,
p.~\pageref{custom-line}.\footnote{Remarque technique. Si l'utilisateur définit
  une commande par-dessus la commande |\Hline|, il doit veiller à ce qu'elle
  soit \emph{développable} au sens de TeX (en utilisant
  |\NewExpandableDocumentCommand| de LaTeX3, |\newcommand| de LaTeX ou même
  |\def| de TeX). Exemple : |\NewExpandableDocumentCommand{\RedLine}{}{\Hline[color=red]}|}

De même que la commande |\Hline|, le specificateur «\verb+|+» admet entre crochets
des options qui caractérisent le filet à tracer. 

\medskip
\begin{Code}[width=10cm]
\begin{NiceTabular}{| c | \emph{[color=blue]} c |}
\Hline
a & b \\
\emph{\Hline[color=red]}
c & d \\
\Hline
\end{NiceTabular}
\end{Code}
%
\begin{NiceTabular}{|c|[color=blue]c|}[no-cell-nodes]
\Hline
a & b \\
\Hline[color=red]
c & d \\
\Hline
\end{NiceTabular}


\medskip
\subsubsection{Les clés hlines et vlines}

\index{hlines|see{Filets}}
\index{hlines!clé pour un environnement}
\index{vlines|see{Filets}}
\index{vlines!clé pour un environnement}

\medskip
Les clés \Definition{hlines} et \Definition{vlines} (qui, bien sûr, tracent des
filets horizontaux et verticaux) prennent comme valeur une liste de numéros qui
sont les numéros des filets\footnote{Il est également possible de mettre dans la
  liste des intervalles de numéros de la forme $i$|-|$j$.} à tracer. Si aucune
valeur n'est donnée, tous les filets sont tracés.

En fait, pour les environnements avec délimiteurs (comme |{pNiceMatrix}| ou
|{bNiceArray}|), la clé |vlines| ne trace pas les filets extérieurs (ce qui est
le comportement certainement attendu).

\medskip
\begin{Code}[width=10.6cm]
$\begin{pNiceMatrix}[\emph{vlines},rules/width=0.2pt]
1 & 2 & 3 & 4 & 5 & 6 \\
1 & 2 & 3 & 4 & 5 & 6 \\
1 & 2 & 3 & 4 & 5 & 6
\end{pNiceMatrix}$
\end{Code}
$\begin{pNiceMatrix}[vlines,rules/width=0.2pt,no-cell-nodes]
1 & 2 & 3 & 4 & 5 & 6 \\
1 & 2 & 3 & 4 & 5 & 6 \\
1 & 2 & 3 & 4 & 5 & 6
\end{pNiceMatrix}$


\medskip
Même quand la clé |hlines| est utilisée, il reste possible d'utiliser
|\Hline\Hline| pour placer un filet double horizontal. De même,
on peut mettre \verb+||+ dans le préambule (d'un environnement à préambule) pour
placer un double filet vertical, même quand la clé |vlines| est utilisée.

\medskip
\begin{Code}[width=10.6cm]
$\begin{NiceArray}{c\emph{||}ccccc}[hlines,vlines]
  & a & b & c & d & e \\ \emph{\Hline\Hline}
x & 0 & 0 & 0 & 0 & 0 \\
y & 0 & 0 & 0 & 0 & 0 \\
z & 0 & 0 & 0 & 0 & 0 \\
\end{NiceArray}$
\end{Code}
$\begin{NiceArray}{c||ccccc}[hlines,vlines]
  & a & b & c & d & e \\ \Hline\Hline
x & 0 & 0 & 0 & 0 & 0 \\
y & 0 & 0 & 0 & 0 & 0 \\
z & 0 & 0 & 0 & 0 & 0 \\
\end{NiceArray}$


\subsubsection{Les clés hvlines et hvlines-except-borders}
\label{hvlines}
\index{hvlines|see{Filets}}
\index{hvlines!clé pour un environnement}
\index{hvlines-except-borders}

La clé \Definition{hvlines}, qui ne prend pas de valeur, est la conjonction des
clés |hlines| et |vlines|.

\smallskip
\begin{Code}
\begin{NiceTabular}{cccc}[\emph{hvlines},rules/color=blue,rules/width=1pt]
rose      & tulipe & marguerite & dahlia \\
violette  & \Block[draw=red]{2-2}{\LARGE fleurs}  & & souci \\
pervenche & & & lys \\
arum      & iris & jacinthe & muguet
\end{NiceTabular}
\end{Code}
%
\begin{center}
\begin{NiceTabular}{cccc}[hvlines,rules/color=blue,rules/width=1pt]
rose      & tulipe & marguerite & dahlia \\
violette  & \Block[C,draw=red]{2-2}{\LARGE fleurs}  & & souci \\
pervenche & & & lys \\
arum      & iris & jacinthe & muguet
\end{NiceTabular}
\end{center}

\medskip
On remarquera que quand la clé |rounded-corners| est utilisée pour
l'environnement |{NiceTabular}|, la clé |hvlines| trace des coins
arrondis pour le tableau : cf. partie~\ref{tabular-rounded-corners},
p.~\pageref{tabular-rounded-corners}.


\medskip
La clé \Definition{hvlines-except-borders} est similaire à la clé |hvlines| mais
ne trace pas les filets sur les bords horizontaux et verticaux du tableau. Pour
un exemple d'utilisation de cette clé, voir la partie «Exemple d'utilisation
avec \pkg{tcolorbox}» p.~\pageref{ex:tcolorbox}.


\medskip
\subsubsection{Les coins (vides)}
\label{corners}

\index{Coins (les --- vides)}
\index{corners (clé d'un environnement)}

Les quatre coins d'un tableau seront notés |NW|, |SW|, |NE| et |SE| (\emph{north
  west}, \emph{south west}, \emph{north east} et \emph{south east} en anglais).

\smallskip
Pour chacun de ces coins, on appellera \emph{coin vide} (ou tout simplement
\emph{coin}) la réunion de toutes les cases vides situées dans au moins un
rectangle entièrement constitué de cases vides partant de ce coin.\footnote{Pour
  être complet, on doit préciser que toute case située dans un bloc (même si
  elle est vide) n'est pas prise en compte pour la détermination des coins. Ce
  comportement est naturel. La définition précise de ce qui est considéré comme
  une «case vide» est donnée plus loin (cf. p.~\pageref{empty-cells}).}

\smallskip
\indexcommand{NotEmpty}
On peut néanmoins imposer à une case sans contenu d'être considérée
comme non vide par \pkg{nicematrix} avec la commande |\NotEmpty|.

\medskip
\begin{minipage}{9cm}
Dans l'exemple ci-contre (où B est au centre d'un |\Block| de taille $2\times2$),
on a colorié en bleu clair les quatre coins (vides) du tableau.
\end{minipage}\hspace{2cm}%
\begin{NiceTabular}{*{6}{c}}%
[cell-space-top-limit=3pt,hvlines,rules={color=white,width=0.1pt},no-cell-nodes]
\CodeBefore
  \rectanglecolor{blue!10}{1-1}{4-2}
  \rectanglecolor{blue!10}{1-1}{1-4}
  \rectanglecolor{blue!10}{1-6}{3-6}
  \rectanglecolor{blue!10}{7-1}{9-1}
  \rectanglecolor{blue!10}{7-5}{9-6}
\Body
  &   &   &   & A \\
  &   & A & A & A \\
  &   &   & A \\
  &   & A & A & A & A \\
A & A & A & A & A & A \\
A & A & A & A & A & A \\
  & A & A & A \\
  & \Block[C]{2-2}{B} & & A \\
  &   &   & A \\
\end{NiceTabular}

\medskip
Quand la clé \Definition{corners}\footnote{La clé \texttt{corners} dont on parle
  là n'a pas de rapport direct avec la clé \texttt{rounded-corners}, décrite
  dans la partie \ref{tabular-rounded-corners},
  p.~\pageref{tabular-rounded-corners}.} est utilisée, \pkg{nicematrix} calcule
les coins vides et ces coins sont alors pris en compte par les outils de tracés
de filets (les filets ne seront pas tracés dans ces coins vides).

\medskip
\begin{Code}[width=11cm]
\NiceMatrixOptions{cell-space-top-limit=3pt}
\begin{NiceTabular}{*{6}{c}}[\emph{corners},hvlines]
  &   &   &   & A \\
  &   & A & A & A \\
  &   &   & A \\
  &   & A & A & A & A \\
A & A & A & A & A & A \\
A & A & A & A & A & A \\
  & A & A & A \\
  & \Block{2-2}{B} & & A \\
  &   &   & A \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{*{6}{c}}[corners,hvlines,cell-space-top-limit=3pt]
  &   &   &   & A \\
  &   & A & A & A \\
  &   &   & A \\
  &   & A & A & A & A \\
A & A & A & A & A & A \\
A & A & A & A & A & A \\
  & A & A & A \\
  & \Block[C]{2-2}{B} & & A \\
  &   &   & A \\
\end{NiceTabular}

\vspace{1cm}
On peut aussi donner comme valeur à la clé |corners| une liste de coins à
prendre en considération (les coins sont notés |NW|, |SW|, |NE| et |SE| et
doivent être séparés par des virgules).

\medskip
\begin{Code}[width=11cm]
\NiceMatrixOptions{cell-space-top-limit=3pt}
\begin{NiceTabular}{*{6}{c}}[\emph{corners=NE},hvlines]
1\\
1&1\\
1&2&1\\
1&3&3&1\\
1&4&6&4&1\\
 & & & & &1
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{*{6}{c}}%
  [c,corners=NE,hvlines,cell-space-top-limit=3pt]
1\\
1&1\\
1&2&1\\
1&3&3&1\\
1&4&6&4&1\\
 & & & & &1
\end{NiceTabular}


\bigskip
$\triangleright$ Les coins sont également pris en compte par les outils de
coloriage dans le |\CodeBefore|. Ces outils ne colorient pas les cases qui sont
dans les coins (cf.~p.~\pageref{color-in-code-before}). La commande
|\TikzEveryCell| disponible dans le |\CodeAfter| et le |\CodeBefore| (cf.
p.~\pageref{TikzEveryCell}) tient également compte des coins.


\subsubsection{La commande \textbackslash diagbox}

\indexcommand{diagbox}

La commande \DefinitionCommande{diagbox} (inspirée par l'extension
\pkg{diagbox}) permet, quand elle est utilisée dans une case, de couper cette
case selon une diagonale descendante.

\medskip
\begin{Code}[width=10cm]
$\begin{NiceArray}{*{5}{c}}[hvlines]
\emph{\diagbox{x}{y}} & e & a & b & c \\
e & e & a & b & c \\
a & a & e & c & b \\
b & b & c & e & a \\
c & c & b & a & e
\end{NiceArray}$
\end{Code}
$\begin{NiceArray}{*{5}{c}}[hvlines,no-cell-nodes]
\diagbox{x}{y} & e & a & b & c \\
e & e & a & b & c \\
a & a & e & c & b \\
b & b & c & e & a \\
c & c & b & a & e
\end{NiceArray}$

\medskip
Cette commande |\diagbox| peut aussi être utilisée dans un |\Block|.


\medskip
\begin{Code}[width=10cm]
$\begin{NiceArray}{*{5}{c}}[hvlines]
\emph{\Block{2-2}{\diagbox{x}{y}}} &  & a & b & c \\
  &   & a & b & c \\
a & a & e & c & b \\
b & b & c & e & a \\
c & c & b & a & e
\end{NiceArray}$
\end{Code}
$\begin{NiceArray}{*{5}{c}}[hvlines,no-cell-nodes]
\Block{2-2}{\diagbox{x}{y}} &  & a & b & c \\
  &   & a & b & c \\
a & a & e & c & b \\
b & b & c & e & a \\
c & c & b & a & e
\end{NiceArray}$


\medskip
Mais on peut aussi utiliser |\diagbox| uniquement pour le trait diagonal et
placer les labels comme habituellement.

\medskip
\begin{Code}[width=10cm]
$\begin{NiceArray}{*{5}{c}}[hvlines]
\emph{\Block{2-2}{\diagbox{}{}}} & y & a & b & c \\
x &   & a & b & c \\
a & a & e & c & b \\
b & b & c & e & a \\
c & c & b & a & e
\end{NiceArray}$
\end{Code}
$\begin{NiceArray}{*{5}{c}}[hvlines,no-cell-nodes]
\Block{2-2}{\diagbox{}{}} & y & a & b & c \\
x &   & a & b & c \\
a & a & e & c & b \\
b & b & c & e & a \\
c & c & b & a & e
\end{NiceArray}$


\medskip
Il est de toutes manières toujours possible de tracer tous les traits souhaités
avec TikZ dans le |\CodeAfter| (ou le |\CodeBefore|) en utilisant les nœuds
PGF/TikZ créés par \pkg{nicematrix} : cf. p.~\pageref{PGF-nodes}.

\subsubsection{Commandes pour filets personnalisés}
\label{custom-line}
\index{command (clé de «custom-line»)}
\index{ccommand (clé de «custom-line»)}
\index{letter (clé de «custom-line»)}
\index{custom-line|(}


Il est en fait possible de définir des commandes et des lettres pour des filets
personnalisés avec la clé \Definition{custom-line}, utilisable dans
|\NiceMatrixOptions| ou bien dans un environnement. Cette clé prend en argument
une liste de paires de la forme \textsl{clé=valeur}. Il y a d'abord trois clés
pour spécifier les outils qui permettront d'utiliser ce nouveau type de filet.

\begin{itemize}
\item la clé \Definition{command} indique le nom (sans la contre-oblique) d'une commande
qui sera créée par \pkg{nicematrix} et que l'utilisateur pourra utiliser pour
tracer des filets horizontaux (de manière similaire à |\hline|) ; 

\item la clé \Definition{ccommand} indique le nom (sans la contre-oblique) d'une
commande qui sera créée par \pkg{nicematrix} et que l'utilisateur pourra
utiliser pour tracer des filets horizontaux partiels (de manière similaire à
|\cline|, d'où le nom |ccommand|) : l'argument de cette commande est une liste
d'intervalles de colonnes spécifiés par la syntaxe $i$ ou $i$-$j$ ;\footnote{Il
  est recommandé de n'utiliser ces commandes qu'une seule fois par rangée car
  chaque utilisation crée un espace vertical entre les rangées correspondant à
  la largeur totale du trait qui sera tracé.}

\item la clé \Definition{letter} prend en argument une lettre\footnote{Les lettres
  suivantes ne sont pas autorisées : \verb+lcrpmbVX|()[]!@<>+} qui pourra être
utilisée par l'utilisateur dans le préambule d'un environnement à préambule
(comme |{NiceTabular}|) pour spécifier un filet vertical.
\end{itemize}

\bigskip
On traite maintenant de la description du filet elle-même. Les options qui
suivent peuvent aussi s'utiliser dans l'argument optionnel d'une commande
|\Hline| individuelle ou dans l'argument optionnel d'un spécificateur «\verb+|+»
dans un préambule d'environnement.

\bigskip
Il y a trois possibilités.


\begin{itemize}
\item \emph{Première possibilité}

\nobreak
Il est possible de spécifier des filets multiples, colorés avec une couleur
entre les filets (comme on peut le faire avec \pkg{colortbl} par exemple).

\begin{itemize}
\index{multiplicity (clé de «custom-line»)}
\index{color!clé de «custom-line»}
\index{sep-color (clé de «custom-line»)}
\item la clé \Definition{multiplicity} indique le nombre de traits successifs
qui seront tracés : par exemple, une valeur de~$2$ va créer des filets doubles
comme créés en standard par |\hline\hline| ou bien \verb+||+ dans le préambule
d'un environnement ;

\item la clé \Definition{color} fixe la couleur des filets ;

\item la clé \Definition{sep-color} fixe la couleur entre deux filets consécutifs (n'a
d'intérêt que dans le cas où la clé |multiplicity| est utilisée). Le nom de
cette clé est inspirée par la commande |\doublerulesepcolor| de \pkg{colortbl}.
\end{itemize}

\medskip
Ce système permet en particulier de définir des commandes pour tracer des filets
avec une couleur spécifique (et ces filets respecteront les blocs et les coins
comme les autres filets de \pkg{nicematrix}).

\medskip
\begin{Code}
\begin{NiceTabular}{lcIcIc}\emph{[custom-line = {letter=I, color=blue}]}
\hline
          & \Block{1-3}{dimensions} \\
          & L & l & h \\
\hline
Produit A & 3 & 1 & 2 \\
Produit B & 1 & 3 & 4 \\
Produit C & 5 & 4 & 1 \\
\hline
\end{NiceTabular}
\end{Code}


\begin{center}
\begin{NiceTabular}{lcIcIc}[custom-line = {letter=I, color=blue}]
\hline
          & \Block[C]{1-3}{dimensions} \\
          & L & l & H \\
\hline
Produit A & 3 & 1 & 2 \\
Produit B & 1 & 3 & 4 \\
Produit C & 5 & 4 & 1 \\
\hline
\end{NiceTabular}
\end{center}


\bigskip
La clé |sep-color| avec la valeur |white| peut être en particulier utile en cas
de filet double au-dessus d'une case colorée (pour éviter que la couleur ne
s'applique aussi entre les deux filets).


\begin{scope}
\NiceMatrixOptions
  {
    custom-line = 
     {
       command = DoubleRule , 
       multiplicity = 2 , 
       sep-color = white
     }
  }


\begin{Code}[width=10cm]
\NiceMatrixOptions
  {
    custom-line = 
     {
       command = DoubleRule , 
       multiplicity = 2 , 
       \emph{sep-color = white}
     }
  }

\begin{NiceTabular}{ccc}
un & deux & trois \\
\emph{\DoubleRule}
quatre & \cellcolor{yellow} cinq & six \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}[no-cell-nodes]
un & deux & trois \\
\DoubleRule
quatre & \cellcolor{yellow} cinq & six \\
\end{NiceTabular}

\end{scope}


\bigskip
\item \emph{Deuxième possibilité}\par

\index{tikzz@tikz!clé de «custom-line»}
\index{total-width (clé de «custom-line»)}

\nobreak
On peut utiliser la clé \Definition{tikz} (si TikZ est chargé, \pkg{nicematrix} ne
chargeant par défaut que \textsc{pgf}). Dans ce cas-là, le filet est tracé
directement avec TikZ en utilisant comme paramètres la valeur de la clé |tikz|
qui doit être une liste de couples \textsl{clé=valeur} applicables à un chemin
TikZ.

Par défaut, aucune réservation de place n'est faite pour le filet qui sera tracé
avec TikZ. On peut demander une réservation (horizontale pour un filet vertical
et verticale pour un filet horizontal) avec la clé \Definition{total-width} qui
est donc en quelque sorte la largeur du filet qui sera tracé (cette largeur
n'est \emph{pas} calculée à partir des caractéristiques fournies par la clé
|tikz|).

\bigskip
Voici ce que l'on obtient avec la clé |dotted| de TikZ.

\begin{Code}
\NiceMatrixOptions
  {
    custom-line = 
     {
       letter = I , 
       \emph{tikz = dotted ,
       total-width = \pgflinewidth}
     }
  }

\begin{NiceTabular}{cIcIc}
un & deux & trois \\
quatre & cinq & six \\
sept & huit & neuf
\end{NiceTabular}
\end{Code}

\begin{center}
\NiceMatrixOptions
  {
    custom-line = 
     {
       letter = I , 
       tikz = dotted ,
       total-width = \pgflinewidth
     }
  }
\begin{NiceTabular}{cIcIc}[no-cell-nodes]
un & deux & trois \\
quatre & cinq & six \\
sept & huit & neuf
\end{NiceTabular}
\end{center}

\medskip
\item \emph{Troisième possibilité} : la clé \Definition{dotted}
\label{dotted}
\index{dotted (clé de «custom-line»)}
\indexcommand{hdottedline}
\indexcommand{cdottedline}

\nobreak
Comme on le voit dans l'exemple précédent, les pointillés tracés par la clé
|dotted| de TikZ ne sont pas ronds. C'est pourquoi l'extension \pkg{nicematrix}
propose dans la clé |custom-line| une clé |dotted| qui va tracer des pointillés
ronds. La valeur initiale de la clé |total-width| est, dans ce cas-là, égale au
diamètre des points (l'utilisateur peut quand même utiliser la clé |total-width|
pour en changer la valeur). Ces pointillés ronds sont aussi utilisés par
\pkg{nicematrix} pour des lignes en pointillés continues créées entre deux
composantes de la matrice par |\Cdots|, |\Vdots|, etc. (voir
p.~\pageref{Cdots}).

\medskip
L'extension \pkg{nicematrix} prédéfinit en fait les commandes
\DefinitionCommande{hdottedline} et \DefinitionCommande{cdottedline} et la
lettre «|:|» pour ces filets en pointillés.\footnote{Néanmoins, l'utilisateur
  peut écraser ces définitions de |\hdottedline|, |\cdottedline| et de «|:|»
  avec |custom-line| s'il le souhaite (par exemple pour les remplacer par des
  lignes en tiretés).}

\smallskip
\begin{Code}
\emph{% présent dans nicematrix.sty}
\NiceMatrixOptions
  { 
    custom-line = 
      { 
        letter = : , 
        command = hdottedline , 
        ccommand = cdottedline ,
        dotted 
      }
  } 
\end{Code}

\bigskip
Il est donc possible d'utiliser les commandes |\hdottedline| et |\cdottedline|
pour tracer des filets horizontaux en pointillés.

\medskip
\begin{Code}[width=9.5cm]
\begin{pNiceMatrix}
1 & 2 & 3 & 4 & 5 \\
\emph{\hdottedline}
6 & 7 & 8 & 9 & 10 \\
\emph{\cdottedline{1,4-5}}
11 & 12 & 13 & 14 & 15
\end{pNiceMatrix}
\end{Code}
$\begin{pNiceMatrix}[no-cell-nodes]
1 & 2 & 3 & 4 & 5 \\
\hdottedline
6 & 7 & 8 & 9 & 10 \\
\cdottedline{1,4-5}
11 & 12 & 13 & 14 & 15
\end{pNiceMatrix}$


\medskip
Dans les environnements avec un préambule explicite (comme |{NiceTabular}|,
|{NiceArray}|, etc.), il est possible de dessiner un trait vertical en
pointillés avec le spécificateur «|:|».

\medskip
\begin{Code}[width=9.5cm]
\begin{pNiceArray}{cccc\emph{:}c}
1 & 2 & 3 & 4 & 5 \\
6 & 7 & 8 & 9 & 10 \\
11 & 12 & 13 & 14 & 15
\end{pNiceArray}
\end{Code}
$\begin{pNiceArray}{cccc:c}[no-cell-nodes]
1 & 2 & 3 & 4 & 5 \\
6 & 7 & 8 & 9 & 10 \\
11 & 12 & 13 & 14 & 15
\end{pNiceArray}$
\end{itemize}


\index{custom-line|)}
\index{Filets@\textbf{Filets dans les tableaux}|)}

\section{Les couleurs de fond des rangées et des colonnes}

\index{Couleur!de fond pour les cases}

\subsection{Utilisation de colortbl}

\index{colortbl@\pkg{colortbl} (extension)}

Rappelons que l'extension \pkg{colortbl} peut être chargée directement par
|\usepackage{colortbl}| ou en chargeant l'extension \pkg{xcolor} avec l'option
\texttt{table} : |\usepackage[table]{xcolor}|.

\medskip
Il y a néanmoins deux inconvénients :
\begin{itemize}[beginpenalty=10000]
\item L'extension \pkg{colortbl} patche \pkg{array}, ce qui entraîne des
incompatibilités (par exemple avec la commande |\hdotsfor|).

\item L'extension \pkg{colortbl} construit le tableau rangée par rangée, en
alternant rectangles colorés, filets et contenu des cases. Le \textsc{pdf}
résultant déroute certains lecteurs de \textsc{pdf} et on a parfois des artefacts
d'affichage.

\begin{itemize}
\item Certains filets semblent disparaître. Ce phénomène est dû au fait que les
lecteurs de PDF donnent souvent la priorité aux éléments graphiques qui ont été
tracés postérieurement (conformément à l'esprit du «modèle du peintre» de
PostScript et PDF). De ce point de vue, MuPDF (qui est utilisé par exemple par
SumatraPDF) donne de meilleurs résultats que Adobe Reader.

\item Une fine ligne blanche semble apparaître entre deux cases de même
couleur. Ce phénomène se produit quand chaque case est coloriée avec sa
propre instruction |fill| (opérateur |fill| de PostScript noté |f| en PDF).
C'est le cas avec \pkg{colortbl} avec lequel chaque case est coloriée
individuellement, même si on utilise |\columncolor| ou |\rowcolor|.

Concernant ce phénomène, Adobe Reader donne de meilleurs résultats que
MuPDF (les versions récentes de MuPDF semblent avoir résolu ce problème).
\end{itemize}

L'extension \pkg{nicematrix} propose des outils qui permettent d'éviter ces
inconvénients.
\end{itemize}

\subsection{Les outils de nicematrix dans le \textbackslash CodeBefore}

\label{color-in-code-before}
\index{code-before!clé pour un environnement}
\index{CodeBefore@\texttt{\textbackslash CodeBefore}...\texttt{\textbackslash Body}}
\index{Body@\texttt{\textbackslash Body}|see{\texttt{\textbackslash CodeBefore}}}

L'extension \pkg{nicematrix} propose des outils pour tracer d'abord les
rectangles colorés, puis le contenu des cases et les filets. Cette manière de
faire est plus dans l'esprit du «modèle du peintre» des formats PostScript et
\textsc{pdf} et convient donc mieux aux lecteurs de \textsc{pdf}. L'inconvénient
est qu'elle nécessite plusieurs compilations successives.\footnote{Si vous
  utilisez Overleaf, Overleaf effectue automatiquement un nombre de compilations
  suffisant (en utilisant |latexmk|).}

\medskip
L'extension \pkg{nicematrix} fournit une clé |code-before| pour du code qui sera
exécuté avant le tracé du tableau. Une syntaxe alternative est proposée : on
peut placer le contenu de ce |code-before| entre les mots-clés |\CodeBefore| et
|\Body| juste au début de l'environnement.

\smallskip
\begin{Code}
\begin{pNiceArray}{\textsl{preamble}}
\emph{\CodeBefore [\textsl{options}]}
  \textsl{instructions du code-before}
\emph{\Body}
  \textsl{contenu de l’environnement}
\end{pNiceArray}
\end{Code}

\smallskip
L'argument optionnel entre crochets est une liste de couples \textsl{clé=valeur}
qui seront présentées au fur et à mesure (les clés disponibles sont
  \texttt{create-cell-nodes}, \texttt{sub-matrix} (et ses sous-clés) et
  \texttt{delimiters/color}).

\smallskip
De nouvelles commandes sont disponibles dans ce |\CodeBefore|: |\cellcolor|,
|\rectanglecolor|, |\rowcolor|, |\columncolor|, |\rowcolors|, |\rowlistcolors|,
|\chessboardcolors| et |\arraycolor|.\footnote{On pourra remarquer que, dans le
  |\CodeBefore|, des nœuds PGF-TikZ de la forme \verb+(i-|j)+ correspondant à la
  position des filets éventuels sont également accessibles : cf.
  p.~\pageref{nodes-i}.}

Les noms de certaines de ces commandes sont inspirés des noms des commandes de
\pkg{colortbl}.

\label{code-before}
\index{cellcolor@\texttt{\textbackslash cellcolor}!commande du
  \texttt{\textbackslash CodeBefore}} 
\index{rectanglecolor@\texttt{\textbackslash rectanglecolor} (commande du
  \texttt{\textbackslash CodeBefore})}
\index{rowcolor@\texttt{\textbackslash rowcolor}!commande du \texttt{\textbackslash CodeBefore}}
\index{columncolor@\texttt{\textbackslash columncolor}!commande du
  \texttt{\textbackslash CodeBefore}}
\index{rowcolors@\texttt{\textbackslash rowcolors} (commande du \texttt{\textbackslash CodeBefore})}
\index{rowlistcolor@\texttt{\textbackslash rowlistcolors} (commande du
  \texttt{\textbackslash CodeBefore})}
\index{chessboardcolors@\texttt{\textbackslash chessboardcolors}!(commande
  du \texttt{\textbackslash CodeBefore})}
\index{arraycolor@\texttt{\textbackslash arraycolor} (commande du \texttt{\textbackslash
  CodeBefore)}}



\medskip
Ces commandes ne colorient pas les cases qui se trouvent dans les «coins» si la
clé |corners| a été utilisée. La description de cette clé a été faite
p.~\pageref{corners}.

\medskip
Ces commandes respectent les coins arrondis si la clé |rounded-corners| (décrite
à la partie \ref{tabular-rounded-corners}, p.~\pageref{tabular-rounded-corners})
a été utilisée.

\medskip
Toutes ces commandes acceptent un argument optionnel, entre crochets et en
première position. Cet argument optionel peut contenir deux éléments (séparés
par une virgule) :
\begin{itemize}[beginpenalty=10000]
\item le modèle colorimétrique (|RGB|, |rgb|, |HTML|, etc.) comme spécifié par
l'extension \pkg{xcolor} ;
\item \index{opacity!clé des commandes comme\newline \texttt{\textbackslash
    rowcolor}, etc.}
une spécification d'opacité selon la forme \texttt{opacity =
  \textsl{valeur}}.\footnote{Attention : cette fonctionnalité génère des instructions de
  transparence dans le \textsc{pdf} résultant et certains lecteurs de
  \textsc{pdf} n'acceptent pas la transparence.}
\end{itemize}


\medskip
On détaille maintenant ces différentes commandes.

\medskip
\begin{itemize}[beginpenalty=10000]
\item La commande \Definition{\textbackslash cellcolor} tient son nom de la
commande |\cellcolor| de \pkg{colortbl}.

Elle prend en arguments obligatoires une couleur et une liste de cases sous le
format $i$-$j$ où $i$ est le numéro de rangée et $j$ le numéro de colonne. Malgré
son nom, elle peut aussi colorier une rangée avec la syntaxe $i$- ou bien une
colonne avec la syntaxe~-$j$.

\medskip
\begin{scope}
\hfuzz=10cm
\begin{Code}[width=10cm]
\begin{NiceTabular}{ccc}[hvlines]
\CodeBefore
  \emph{\cellcolor[HTML]{FFFF88}{3-1,2-2,-3}}
\Body
a & b & c \\ 
e & f & g \\ 
h & i & j \\ 
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}[hvlines,no-cell-nodes]
\CodeBefore
  \cellcolor[HTML]{FFFF88}{3-1,2-2,-3}
\Body
a & b & c \\ 
e & f & g \\ 
h & i & j \\ 
\end{NiceTabular}
\end{scope}


\medskip
\item La commande \Definition{\textbackslash rectanglecolor} prend trois
arguments obligatoires. Le premier est la couleur, les deux suivants fournissent
la case en haut à gauche et la case en bas à droite du rectangle.

\medskip
\begin{scope}
\hfuzz=10cm
\begin{Code}[width=10cm]
\begin{NiceTabular}{ccc}[hvlines]
\CodeBefore
  \emph{\rectanglecolor{blue!15}{2-2}{3-3}}
\Body
a & b & c \\ 
e & f & g \\ 
h & i & j \\ 
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}[hvlines,no-cell-nodes]
\CodeBefore
  \rectanglecolor{blue!15}{2-2}{3-3}
\Body
a & b & c \\ 
e & f & g \\ 
h & i & j \\ 
\end{NiceTabular}
\end{scope}


\medskip
\item La commande \Definition{\textbackslash arraycolor} prend en argument
obligatoire une couleur et colorie tout le tableau (sauf les éventuelles rangées
et colonnes extérieures: cf.~p.~\pageref{exterior}) avec cette couleur. Ce n'est
qu'un cas particulier de la commande |\rectanglecolor|.

\medskip
\item \label{chessboardcolors}%
La commande \Definition{\textbackslash chessboardcolors} prend en arguments
obligatoires deux couleurs et colorie les cases en quinconces avec les deux
couleurs.

\medskip
\begin{scope}
\hfuzz=10cm
\begin{Code}[width=9cm]
$\begin{pNiceMatrix}[r,margin]
\CodeBefore
  \emph{\chessboardcolors{red!15}{blue!15}}
\Body
1 & -1 & 1 \\
-1 & 1 & -1 \\
1 & -1 & 1
\end{pNiceMatrix}$
\end{Code}
$\begin{pNiceMatrix}[baseline=1, r, margin,no-cell-nodes]
\CodeBefore
  \chessboardcolors{red!15}{blue!15}
\Body
1 & -1 & 1 \\
-1 & 1 & -1 \\
1 & -1 & 1
\end{pNiceMatrix}$
\end{scope}

\medskip
On a utilisé la clé |r| qui impose que toutes les colonnes soient alignées à
droite (cf. p.~\pageref{columns-type}).


\medskip
\item La commande \Definition{\textbackslash rowcolor} doit son nom à la
commande |\rowcolor| de \pkg{colortbl}. Son premier argument obligatoire est la
couleur et le deuxième est une liste de numéros de rangées ou bien d'intervalles
de rangées sous la forme $a$-$b$ (un intervalle de la forme $a$- représente
toutes les rangées à partir de la rangée~$a$).

\medskip

\begin{scope}
\hfuzz=10cm
\begin{Code}[width=9cm]
$\begin{NiceArray}{lll}[hvlines]
\CodeBefore
  \emph{\rowcolor{red!15}{1,3-5,8-}}
\Body
a_1 & b_1 & c_1 \\
a_2 & b_2 & c_2 \\
a_3 & b_3 & c_3 \\
a_4 & b_4 & c_4 \\
a_5 & b_5 & c_5 \\
a_6 & b_6 & c_6 \\
a_7 & b_7 & c_7 \\
a_8 & b_8 & c_8 \\
a_9 & b_9 & c_9 \\
a_{10} & b_{10} & c_{10} \\
\end{NiceArray}$
\end{Code}
%
$\begin{NiceArray}{lll}[baseline=4,hvlines,no-cell-nodes]
\CodeBefore
  \rowcolor{red!15}{1,3-5,8-}
\Body
a_1 & b_1 & c_1 \\
a_2 & b_2 & c_2 \\
a_3 & b_3 & c_3 \\
a_4 & b_4 & c_4 \\
a_5 & b_5 & c_5 \\
a_6 & b_6 & c_6 \\
a_7 & b_7 & c_7 \\
a_8 & b_8 & c_8 \\
a_9 & b_9 & c_9 \\
a_{10} & b_{10} & c_{10} \\
\end{NiceArray}$
\end{scope}



\medskip
\item La commande \Definition{\textbackslash columncolor} doit son nom à la
commande |\columncolor| de \pkg{colortbl}. Sa syntaxe est similaire à celle de
|\rowcolor|.

\medskip
\item La commande \Definition{\textbackslash rowcolors} (avec un \emph{s}) doit
son nom à la commande |\rowcolors| de \pkg{colortbl}. Le \emph{s} rappelle qu'il
y a deux couleurs. Elle colorie alternativement les rangées avec les deux
couleurs à partir de la rangée dont le numéro est donné en premier argument
(obligatoire), comme le fait la commande |\rowcolors| de \pkg{xcolor}. L'un des
deux arguments de couleur peut être vide (et alors aucune couleur n'est
appliquée dans les rangées correspondantes).

En fait, le premier argument (obligatoire) peut, plus généralement, contenir
une liste d'intervalles correspondant à l'ensemble des rangées sur lesquelles
portera l'effet de |\rowcolors| (un intervalle de la forme $i$ désigne en fait
l'intervalle constitué de toutes les rangées du tableau à partir de la rangée~$i$).


\medskip
La commande |\rowcolors| accepte une liste de couples
\textsl{clé=valeur} comme argument optionnel en dernière position (l'argument
optionnel en première position correspond à l'espace colorimétrique). Les clés
disponibles sont |cols|, |restart| et |respect-blocks|.
\index{cols (clé de \texttt{\textbackslash rowcolors} du
  \texttt{\textbackslash CodeBefore})}
\index{restart (clé de \texttt{\textbackslash rowcolors} du
  \texttt{\textbackslash CodeBefore})}
\index{respect-blocks (clé de \texttt{\textbackslash rowcolors} du\newline
  \texttt{\textbackslash CodeBefore})}
\begin{itemize}
\item La clé \Definition{cols} décrit un ensemble de colonnes sur lesquelles
portera l'effet de |\rowcolors|. Cet ensemble de colonnes est une liste
d'intervalles de la forme $i$|-|$j$ (où $i$ et $j$ peuvent être remplacés par
|*|).

\item Avec la clé \Definition{restart}, chacun des intervalles de rangées
spécifié par le premier argument de |\rowcolors| recommence avec la même
couleur.\footnote{Autrement, la couleur d'une rangée ne dépend que de la parité
  de son numéro absolu.}

\item Avec la clé \Definition{respect-blocks}, qui est de type booléen, les
«rangées» colorées alternativement peuvent s'étendre sur plusieurs rangées
réelles du tableau pour englober les blocs (créés par la commande |\Block| :
cf.~p.~\pageref{Block}).
\end{itemize}

\medskip
\begin{scope}
\hfuzz=10cm
\begin{Code}[width=9cm]
\begin{NiceTabular}{clr}[hvlines]
\CodeBefore
  \emph{\rowcolors[gray]{2}{0.8}{}[cols=2-3,restart]}
\Body
\Block{1-*}{Résultats} \\
\Block{2-1}{A}& Pierre & 12 \\
              & Jacques & 8 \\
\Block{4-1}{B}& Stéphanie & 18 \\
              & Amélie & 20 \\
              & Henri & 14 \\
              & Estelle & 15
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{clr}[hvlines,baseline=2,no-cell-nodes]
\CodeBefore
  \rowcolors[gray]{2}{0.8}{}[cols=2-3,restart]
\Body
\Block{1-*}{Résultats} \\
\Block{2-1}{A}& Pierre & 12 \\
              & Jacques & 8 \\
\Block{4-1}{B}& Stéphanie & 18 \\
              & Amélie & 20 \\
              & Henri & 14 \\
              & Estelle & 15
\end{NiceTabular}
\end{scope}


\vspace{1cm}

\begin{scope}
\hfuzz=10cm
\begin{Code}[width=11cm]
\begin{NiceTabular}{lr}[hvlines]
\CodeBefore
  \emph{\rowcolors{1}{blue!10}{}[respect-blocks]}
\Body
\Block{2-1}{Pierre}    & 12 \\
                       & 13 \\
Jacques                &  8 \\
\Block{3-1}{Stéphanie} & 18 \\
                       & 17 \\
                       & 15 \\
Amélie                 & 20 \\
Henri                  & 14 \\
\Block{2-1}{Estelle}   & 15 \\
                       & 19
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{lr}[hvlines,baseline=c]
\CodeBefore
  \rowcolors{1}{blue!10}{}[respect-blocks]
\Body
\Block{2-1}{Pierre}    & 12 \\
                       & 13 \\
Jacques                &  8 \\
\Block{3-1}{Stéphanie} & 18 \\
                       & 17 \\
                       & 15 \\
Amélie                 & 20 \\
Henri                  & 14 \\
\Block{2-1}{Estelle}   & 15 \\
                       & 19
\end{NiceTabular}
\end{scope}

\medskip
\item L'extension \pkg{nicematrix} propose aussi une commande
\Definition{\textbackslash rowlistcolors}. Cette commande généralise la commande
|\rowcolors|: au lieu de prendre deux arguments successifs pour les couleurs,
elle prend un seul argument qui est une \emph{liste} de couleurs séparées par
des virgules. Dans cette liste, le symbole |=| représente une couleur identique
à la précédente.

\smallskip
\begin{Code}[width=10cm]
\begin{NiceTabular}{c}
\CodeBefore
  \emph{\rowlistcolors{1}{red!15,blue!15,green!15}}
\Body
Mathilde \\
Pierre \\
Paul \\
Amélie \\
Jacques \\
Antoine \\
Stéphanie \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{c}
\CodeBefore
  \rowlistcolors{1}{red!15,blue!15,green!15}
\Body
Mathilde \\
Pierre \\
Paul \\
Amélie \\
Jacques \\
Antoine \\
Stéphanie \\
\end{NiceTabular}

\bigskip
On peut aussi utiliser dans la commande |\rowlistcolors| une série de couleurs
définie par la commande |\definecolorseries| de \pkg{xcolor} (et initialisée
avec |\resetcolorseries|\footnote{Pour l'initialisation, on a
  utilisé dans l'exemple qui suit le compteur LaTeX |iRow| (qui correspond en
  interne au compteur TeX |\c@iRow|) qui, quand il est utilisé
  dans le |\CodeBefore| (ou le |\CodeAfter|) désigne le nombre de rangées du
  tableau : cf~p.~\pageref{iRow}. Cela permet un ajustement de la gradation des
  couleurs à la taille du tableau.}).

\index{definecolorseries@\texttt{\textbackslash definecolorseries}
  (commande de \pkg{xcolor})}
\index{resetcolorseries@\texttt{\textbackslash resetcolorseries}
  (commande de \pkg{xcolor})}

\smallskip
\begin{Code}[width=12cm]
\begin{NiceTabular}{c}
\CodeBefore
   \emph{\definecolorseries{BlueWhite}{rgb}{last}{blue}{white}
   \resetcolorseries{\value{iRow}}{BlueWhite}
   \rowlistcolors{1}{BlueWhite!!+}}
\Body
Mathilde \\
Pierre \\
Paul \\
Amélie \\
Jacques \\
Antoine \\
Stéphanie \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{c}[no-cell-nodes]
\CodeBefore
   \definecolorseries{BlueWhite}{rgb}{last}{blue}{white}
   \resetcolorseries[\value{iRow}]{BlueWhite}
   \rowlistcolors{1}{BlueWhite!!+}
\Body
Mathilde \\
Pierre \\
Paul \\
Amélie \\
Jacques \\
Antoine \\
Stéphanie \\
\end{NiceTabular}

\end{itemize}


\vspace{1cm}
On rappelle que toutes les commandes de coloriage que l'on vient de décrire ne
colorient pas les cases qui sont dans les «coins». Dans l'exemple suivant, on
utilise la clé |corners| pour demander de considérer le coin \emph{north east} (NE).

\medskip
\index{corners (clé d'un environnement)|textit}
\begin{Code}[width=15cm]
\begin{NiceTabular}{cccccc}
 [\emph{corners=NE},margin,hvlines,first-row,first-col]
\CodeBefore
  \emph{\rowlistcolors{1}{blue!15, }}
\Body
  & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
0 & 1 \\
1 & 1 & 1 \\
2 & 1 & 2 & 1 \\
3 & 1 & 3 & 3 & 1 \\
4 & 1 & 4 & 6 & 4 & 1 \\
5 & 1 & 5 & 10 & 10 & 5 & 1 \\
6 & 1 & 6 & 15 & 20 & 15 & 6 & 1 \\
\end{NiceTabular}
\end{Code}
\hspace{-6cm}
\begin{NiceTabular}{ccccccc}%
  [corners=NE,margin,hvlines,first-row,first-col]
\CodeBefore
  \rowlistcolors{1}{blue!15, }
\Body
  & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
0 & 1 \\
1 & 1 & 1 \\
2 & 1 & 2 & 1 \\
3 & 1 & 3 & 3 & 1 \\
4 & 1 & 4 & 6 & 4 & 1 \\
5 & 1 & 5 & 10 & 10 & 5 & 1 \\
6 & 1 & 6 & 15 & 20 & 15 & 6 & 1 \\
\end{NiceTabular}


\medskip
L'exemple précédent utilise les clés |first-row| et |first-col| qui sont
décrites dans la partie sur les rangées et colonnes «extérieures»
(cf.~p.~\pageref{exterior}).

Comme on le voit, \emph{par défaut}, les commandes de coloriage décrites précédemment ne
s'appliquent pas dans ces rangées et colonnes «extérieures».  

Mais on peut \emph{quand même} colorier dans ces rangées et colonnes en
donnant aux commandes précédentes les numéros explicites de ces rangées et
colonnes extérieures.

Dans l'exemple suivant, on demande explicitement le coloriage de la colonne~$0$
(qui est la «première colonne» et qui existe du fait de la clé |first-col|).

\medskip
\begin{Code}[width=15cm]
\begin{NiceTabular}{cccccc}[\emph{corners=NE},margin,hvlines,first-row,first-col]
\CodeBefore
  \rowlistcolors{1}{blue!15, }
  \emph{\columncolor{red!15}{0}}
\Body
  & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
0 & 1 \\
1 & 1 & 1 \\
2 & 1 & 2 & 1 \\
3 & 1 & 3 & 3 & 1 \\
4 & 1 & 4 & 6 & 4 & 1 \\
5 & 1 & 5 & 10 & 10 & 5 & 1 \\
6 & 1 & 6 & 15 & 20 & 15 & 6 & 1 \\
\end{NiceTabular}
\end{Code}
\hspace{-6cm}
\begin{NiceTabular}{ccccccc}%
   [corners=NE,margin,hvlines,first-row,first-col]
\CodeBefore
  \rowlistcolors{1}{blue!15, }
  \columncolor{red!15}{0}
\Body
  & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
0 & 1 \\
1 & 1 & 1 \\
2 & 1 & 2 & 1 \\
3 & 1 & 3 & 3 & 1 \\
4 & 1 & 4 & 6 & 4 & 1 \\
5 & 1 & 5 & 10 & 10 & 5 & 1 \\
6 & 1 & 6 & 15 & 20 & 15 & 6 & 1 \\
\end{NiceTabular}



\bigskip
On remarquera que ces commandes sont compatibles avec les commandes de
\pkg{booktabs} (|\toprule|, |\midrule|, |\bottomrule|, etc). Néanmoins,
l'extension \pkg{booktabs} n'est \emph{pas} chargée par \pkg{nicematrix}.

\medskip
\index{rotate@\texttt{\textbackslash rotate}|textit}
\begin{scope}
\hfuzz=10cm
\begin{Code}[width=8.5cm]
\begin{NiceTabular}{lSSSS}
\CodeBefore
  \rowcolor{red!15}{1-2}
  \rowcolors{3}{blue!15}{}
\Body
\emph{\toprule}
\Block[C]{2-1}{Produit} &
\Block{1-3}{dimensions (cm)} & & &
\Block{2-1}{\rotate Prix} \\
\emph{\cmidrule(rl){2-4}}
 & L & l & h \\
\emph{\midrule}
petit    & 3   & 5.5  & 1   & 30    \\
moyen    & 5.5 & 8    & 1.5 & 50.5  \\
premium  & 8.5 & 10.5 & 2   & 80    \\
extra    & 8.5 & 10   & 1.5 & 85.5  \\
spécial  & 12  & 12   & 0.5 & 70    \\
\emph{\bottomrule}
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}[c]{lSSSS}[no-cell-nodes]
\CodeBefore
  \rowcolor{red!15}{1-2}
  \rowcolors{3}{blue!15}{}
\Body
\toprule
\Block[C]{2-1}{Produit} &
\Block{1-3}{dimensions (cm)} & & &
\Block{2-1}{\rotate Prix} \\
\cmidrule(rl){2-4}
 & L & l & h \\
\midrule
petit    & 3   & 5.5  & 1   & 30    \\
moyen    & 5.5 & 8    & 1.5 & 50.5  \\
premium  & 8.5 & 10.5 & 2   & 80    \\
extra    & 8.5 & 10   & 1.5 & 85.5  \\
spécial  & 12  & 12   & 0.5 & 70    \\
\bottomrule
\end{NiceTabular}
\end{scope}

\index{S (les colonnes S de \pkg{siunitx})|textit}

\medskip
On a utilisé le type de colonne |S| de \pkg{siunitx} (qu'il faut avoir chargé).


\bigskip
\index{EmptyRow@\texttt{\textbackslash EmptyRow} (commande du
  \texttt{\textbackslash CodeBefore})}
\index{EmptyColumn@\texttt{\textbackslash EmptyColumn} (commande du
  \texttt{\textbackslash CodeBefore})}

\colorbox{yellow!50}{\textbf{Nouveau 7.1}}

\nobreak
\smallskip
On peut aussi, dans le |\CodeBefore|, utiliser les commandes
\DefinitionCommande{EmptyColumn} et \DefinitionCommande{EmptyRow}. La commande
|\EmptyColumn| prend en argument une liste de numéros de colonnes et impose qu'aucun
coloriage ni tracé de filets n'aura lieu dans les colonnes correspondantes. La
commande |\EmptyRow| est similaire.


\medskip
\begin{Code}[width=10cm]
\begin{NiceTabular}{ccccc}[hvlines,no-cell-nodes]
\CodeBefore
  \rowcolor{blue!15}{1}
  \emph{\EmptyColumn{3}}
\Body
  un & deux && trois & quatre \\
  un & \Block{}{deux\\ lignes} && trois & quatre \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccccc}[hvlines,no-cell-nodes]
\CodeBefore
  \rowcolor{blue!15}{1}
  \EmptyColumn{3}
\Body
  un & deux && trois & quatre \\
  un & \Block{}{deux\\ lignes} && trois & quatre \\
\end{NiceTabular}






\subsection{Outils de coloriage en tableau}

\index{cellcolor@\texttt{\textbackslash cellcolor}!commande en tableau}
\index{rowcolor@\texttt{\textbackslash rowcolor}!commande en tableau}
\index{columncolor@\texttt{\textbackslash columncolor}!commande dans le
  préambule d'un environnement} 

L'extension \pkg{nicematrix} propose aussi des commandes de coloriage à utiliser
directement dans le tableau (comme celles de l'extension \pkg{colortbl}).

Les commandes sont les suivantes (les trois premières sont inspirées par les
commandes similaires de \pkg{colortbl}).
\begin{itemize}[beginpenalty=10000]
\item \DefinitionCommande{cellcolor} qui colorie la case courante\footnote{Cette
  commande |\cellcolor| supprimera les espaces qui la suivent (ce que ne fait
  pas la commande |\cellcolor| de \pkg{colortbl}). De plus, si on définit une
  fonction au-dessus de |\cellcolor|, il faudra une fonction protégée au sens de
TeX (alors que si c'était la commande |\cellcolor| de \pkg{colortbl}, il
faudrait au contaire une fonction \emph{fully expandable}).} ;
\item \DefinitionCommande{rowcolor} à utiliser dans une case et qui colorie le
reste de la rangée;\footnote{Si vous souhaitez une commande pour colorier les
  $n$~rangées suivantes, considérez la commande |\RowStyle| et sa clé
  |fill|, p.~\pageref{RowStyle}.} 
\item \DefinitionCommande{columncolor} à utiliser dans le préambule du tableau
de la même manière que la commande homonyme de \pkg{colortbl} (néanmoins,
contrairement à la commande |\columncolor| de \pkg{colortbl}, celle de
\pkg{nicematrix} peut apparaître à l'intérieur d'une autre commande, elle-même
utilisée dans le préambule; en revanche, elle ne prend pas les deux arguments
optionnels à la fin entre crochets pour du débord comme la commande de
\pkg{colortbl}) ;
\item \DefinitionCommande{rowcolors} qui prend pour arguments deux couleurs et
colorie la suite du tableau avec ces deux couleurs ;
\item \DefinitionCommande{rowlistcolors} qui prend pour argument une liste de
couleurs et colorie la suite du tableau avec ces couleurs.\footnote{Quand la
  commande |\rowlistcolors| (ou la commande |\rowcolors|) est utilisée dans une
  case de la colonne~$j$, le coloriage ne s'applique que sur les colonnes
  au-delà de~$j$ (à dessein).}
\end{itemize}
Ces commandes sont compatibles avec les commandes pour les \emph{overlays} de
Beamer (comme |\only|, etc.)

\medskip
\begin{Code}
\NewDocumentCommand { \Blue } { } {\emph{\columncolor{blue!15}}}
\begin{NiceTabular}{>{\Blue}c>{\Blue}cc}
\toprule
\emph{\rowcolor{red!15}}
Nom & Prénom & Année de naissance \\
\midrule
Achard & Jacques & 5 juin 1962 \\
Lefebvre & Mathilde & 23 mai 1988 \\
Vanesse & Stéphanie & 30 octobre 1994 \\
Dupont & Chantal & 15 janvier 1998 \\
\bottomrule
\end{NiceTabular}
\end{Code}


\begin{center}
\NewDocumentCommand { \Blue } { } {\columncolor{blue!15}}
\begin{NiceTabular}{>{\Blue}c>{\Blue}cc}[no-cell-nodes]
\toprule
\rowcolor{red!15}
Nom & Prénom & Année de naissance \\
\midrule
Achard & Jacques & 5 juin 1962 \\
Lefebvre & Mathilde & 23 mai 1988 \\
Vanesse & Stéphanie & 30 octobre 1994 \\
Dupont & Chantal & 15 janvier 1998 \\
\bottomrule
\end{NiceTabular}
\end{center}



\bigskip
Chaque utilisation de |\rowlistcolors| (et de |\rowcolors| qui en est un cas
particulier) met un terme aux éventuels schémas\footnote{On a écrit
  \emph{schémas} au pluriel car on peut avoir plusieurs schémas en cours s'ils
  portent sur des colonnes différentes.} de coloriage en cours qui auraient été
spécifiés par une commande |\rowlistcolors| précédente.

En particulier, on peut engager un coloriage des rangées avec
|\rowlistcolors{...}| et l'arrêter par un |\rowlistcolors{}| avec argument vide.

\bigskip
\begin{Code}[width=10cm]
\begin{NiceTabular}{c}[hvlines]
un \\
deux \\
\emph{\rowlistcolors{red!15}}
trois \\
quatre \\
cinq \\
\emph{\rowlistcolors{}}
six \\
sept \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{c}[hvlines,no-cell-nodes]
un \\
deux \\
\rowlistcolors{red!15}
trois \\
quatre \\
cinq \\
\rowlistcolors{}
six \\
sept \\
\end{NiceTabular}

\subsection{La couleur spécial «nocolor»}

\index{nocolor}

L'extension \pkg{nicematrix} propose la couleur spéciale \Definition{nocolor}
utilisable dans toutes les commandes de coloriage fournies par \pkg{nicematrix}
(dans le |\CodeBefore| ou bien dans le tableau proprement dit).

Les cases marquées par cette couleur ne seront pas coloriées, quelles que soient
les autres commandes de coloriage qui auraient pu s'appliquer à ces cases. 

La couleur |nocolor| fournit donc un moyen commode de faire des exceptions à
l'action d'une commande de coloriage générale.


\section{La commande \textbackslash RowStyle}

\label{RowStyle}
\indexcommand{RowStyle}
\index{cell-space-top-limit}
\index{cell-space-bottom-limit}
\index{cell-space-limits}


La commande \DefinitionCommande{RowStyle} prend en argument des instructions de
mise en forme qui seront appliquées à chacune des cases restantes sur la rangée
en cours.

\medskip
Elle prend aussi en premier argument optionnel, entre crochets, une liste de
couples \textsl{clé=valeur}.
\begin{itemize}[beginpenalty=10000]
\item \index{nb-rows (clé de \texttt{\textbackslash RowStyle})}
La clé \Definition{nb-rows} indique le nombre de rangées consécutives concernées par
les spécifications de cette commande (une valeur |*| signifie que toutes les
rangées restantes seront concernées).
\item Les clés \Definition{cell-space-top-limit}, \Definition{cell-space-bottom-limit}
et \Definition{cell-space-limits} sont disponibles avec le même effet que les
clés globales de même nom (cf. p.~\pageref{cell-space-limits}).

\item 
\index{rowcolor (clé de \texttt{\textbackslash RowStyle})}
\index{fill!clé de \texttt{\textbackslash RowStyle}} 
\index{opacity!clé de \texttt{\textbackslash RowStyle}} 
\index{rounded-corners!clé de \texttt{\textbackslash RowStyle}}
La clé \Definition{fill} (alias : \Definition{rowcolor}) fixe la couleur de fond
et la clé \Definition{opacity}\footnote{Attention : cette clé génère des
  instructions de transparence dans le \textsc{pdf} résultant et certains
  lecteurs de \textsc{pdf} n'acceptent pas la transparence.} l'opacité de cette
couleur de fond. Si la clé \Definition{rounded-corners} est utilisée, ce fond
aura des coins arrondis.

\item 
\index{color!clé de \texttt{\textbackslash RowStyle}} 
La clé \Definition{color} fixe la couleur du texte.\footnote{La clé |color|
  utilise la commande |\color| mais insère aussi une instruction |\leavevmode|
  devant. Cela évite un espace vertical parasite dans les cases qui
  correspondent à des colonnes de type |p|, |b|, |m|, et |X| (qui débutent en
  mode vertical de LaTeX). Pour les colonnes de type |V| (de \pkg{varwidth}),
  cela ne suffit malheureusement pas sauf si on utilise LuaLaTeX avec
  \pkg{luacolor} (cf. question 460489 sur TeX StackExchange).}

\item \index{bold (clé de \texttt{\textbackslash RowStyle})}
La clé \Definition{bold} impose des caractères gras aux éléments de la rangée, qu'ils
soient en mode texte ou bien en mode mathématique.
\end{itemize}

\medskip
\begin{Code}[width=12cm]
\begin{NiceTabular}{cccc}
\hline
\emph{\RowStyle[cell-space-limits=3pt]{\rotate}}
premier & deuxième & troisième & quatrième \\
\emph{\RowStyle[nb-rows=2,color=white,fill=blue!50]{\sffamily}}
1 & 2 & 3 & 4 \\
I & II & III & IV 
\end{NiceTabular}
\end{Code}
\index{rotate@\texttt{\textbackslash rotate}|textit}
\begin{NiceTabular}{cccc}[no-cell-nodes]
\hline
\RowStyle[cell-space-limits=3pt]{\rotate}
premier & deuxième & troisième & quatrième \\
\RowStyle[nb-rows=2,color=white,fill=blue!50]{\sffamily}
1 & 2 & 3 & 4 \\
I & II & III & IV \\
\end{NiceTabular}

\medskip
La commande |\rotate| est présentée p.~\pageref{rotate}.




\section{La largeur des colonnes}
\label{width}
\index{Largeur@\textbf{Largeur des colonnes}|(}

\subsection{Techniques de base}

Dans les environnements avec un préambule explicite (comme |{NiceTabular}|,
|{NiceArray}|, etc.), il est possible de fixer la largeur d'une colonne avec les
lettres classiques |w|, |W|, |p|, |b| et |m| de l'extension \pkg{array}.

\medskip
\begin{Code}[width=9cm]
\begin{NiceTabular}{\emph{W{c}{2cm}}cc}[hvlines]
Paris  & New York & Madrid \\
Berlin & London   & Roma    \\
Rio    & Tokyo    & Oslo
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{W{c}{2cm}cc}[hvlines,no-cell-nodes]
Paris  & New York & Madrid \\
Berlin & London   & Roma    \\
Rio    & Tokyo    & Oslo
\end{NiceTabular}


\medskip
\index{columns-width}
Dans les environnements de \pkg{nicematrix}, il est aussi possible de fixer la
largeur \emph{minimale} de toutes les colonnes (à l'exception des éventuelles
colonnes extérieures: cf. p.~\pageref{exterior}) directement avec l'option
\Definition{columns-width}.

\medskip
\begin{Code}[width=10cm]
$\begin{pNiceMatrix}[\emph{columns-width = 1cm}]
1  & 12 & -123 \\
12 & 0  & 0    \\
4  & 1  & 2
\end{pNiceMatrix}$
\end{Code}
$\begin{pNiceMatrix}[columns-width = 1cm,no-cell-nodes]
1  & 12 & -123 \\
12 & 0  & 0    \\
4  & 1  & 2
\end{pNiceMatrix}$

\medskip
Notez que l'espace inséré entre deux colonnes (égal à 2 |\tabcolsep| dans
|{NiceTabular}| et à 2 |\arraycolsep| dans les autres environnements) n'est pas
supprimé (il est évidemment possible de le supprimer en mettant |\tabcolsep| ou
|\arraycolsep| à~$0$ avant).

\medskip
Il est possible de donner la valeur spéciale \Definition{auto} à l'option
|columns-width|: toutes les colonnes du tableau auront alors une largeur égale à
la largeur de la case la plus large du tableau.\footnote{Le résultat est atteint
  dès la première compilation (mais PGF-TikZ écrivant des informations dans le
  fichier |aux|, un message demandant une deuxième compilation
  apparaîtra).}

\nobreak
\medskip
\begin{Code}[width=10cm]
$\begin{pNiceMatrix}[\emph{columns-width = auto}]
1  & 12 & -123 \\
12 & 0  & 0    \\
4  & 1  & 2
\end{pNiceMatrix}$
\end{Code}
$\begin{pNiceMatrix}[columns-width = auto,no-cell-nodes]
1  & 12 & -123 \\
12 & 0  & 0    \\
4  & 1  & 2
\end{pNiceMatrix}$

\medskip
Sans surprise, il est possible de fixer la largeur minimale de toutes les
colonnes de tous les tableaux dans une certaine portion de document avec la
commande |\NiceMatrixOptions|.

\nobreak
\medskip
\begin{Code}[width=8.5cm]
\emph{\NiceMatrixOptions{columns-width=10mm}}
$\begin{pNiceMatrix}
a & b \\ c & d
\end{pNiceMatrix}
=
\begin{pNiceMatrix}
1   & 1245 \\ 345 & 2
\end{pNiceMatrix}$
\end{Code}
\begin{scope}
\NiceMatrixOptions{columns-width=10mm}
$\begin{pNiceMatrix}[no-cell-nodes]
a & b \\
c & d
\end{pNiceMatrix}
=
\begin{pNiceMatrix}[no-cell-nodes]
1   & 1245 \\
345 & 2
\end{pNiceMatrix}$
\end{scope}


\medskip
\index{NiceMatrixBlock@\texttt{\{NiceMatrixBlock\}}}
\index{auto-columns-width!(clé de \texttt{\{NiceMatrixBlock\}})}
Mais il est aussi possible de fixer une zone dans laquelle toutes les matrices
auront leurs colonnes de la même largeur, égale à la largeur de la case la plus
large de toutes les matrices de la zone. Cette construction utilise
l'environnement |{NiceMatrixBlock}| avec l'option
|auto-columns-width|\footnote{Pour le moment, c'est le seul usage de
  l'environnement |{NiceMatrixBlock}| mais il pourrait y en avoir davantage dans
  le futur.}. L'environnement |{NiceMatrixBlock}| n'a pas de rapport direct avec
la commande |\Block| présentée précédemment dans ce document
(cf.~p.~\pageref{Block}).

\medskip
\begin{Code}[width=8.5cm]
\emph{\begin{NiceMatrixBlock}[auto-columns-width]}
$\begin{array}{c}
\begin{bNiceMatrix}
 9 & 17 \\ -2 & 5
 \end{bNiceMatrix} \\ \\
\begin{bNiceMatrix}
 1   & 1245345 \\  345 & 2
\end{bNiceMatrix} \\
\end{array}$
\emph{\end{NiceMatrixBlock}}
\end{Code}
\begin{NiceMatrixBlock}[auto-columns-width]
$\begin{array}{c}
\begin{bNiceMatrix}
 9 & 17 \\ -2 & 5
 \end{bNiceMatrix} \\ \\
\begin{bNiceMatrix}
 1   & 1245345 \\  345 & 2
\end{bNiceMatrix} \\
\end{array}$ 
\end{NiceMatrixBlock}


\subsection{Les colonnes X}

\label{colonne-X}
\index{tabularx@\pkg{tabularx} (extension)}
\index{NiceTabularX@\texttt{\{NiceTabularX\}}}
\index{X (les colonnes X)}
\index{width!clé de \texttt{\{NiceTabular\}}}

L'environnement |{NiceTabular}| propose aussi des colonnes |X| similaires à
celles proposées par l'environnement |{tabularx}| de l'extension éponyme.

La valeur requise par la largeur du tableau peut être passée en argument de la
clé \Definition{width} (dans |{NiceTabular}| ou dans |\NiceMatrixOptions|). La
valeur initiale de ce paramètre est |\linewidth| (et non |\textwidth|).

Pour se rapprocher davantage de l'environnement |{tabularx}|, \pkg{nicematrix}
propose aussi un environnement \Definition{\{NiceTabularX\}} avec une syntaxe
similaire à celle de |{tabularx}|, c'est-à-dire que la largeur voulue pour le
tableau est spécifiée en premier argument (obligatoire).


Comme avec les extensions \pkg{tabu}\footnote{L'extension \pkg{tabu} est
  maintenant considérée comme obsolète.} et \pkg{tabularray}, le spécificateur |X|
accepte entre crochets un argument optionnel qui est une liste de clés.
\begin{itemize}[beginpenalty=10000]
\item On peut spécifier un poids pour la colonne en mettant directement un
nombre positif comme argument du spécificateur |X|. Par exemple, une colonne
|X[2]| aura une largeur double de celle d'une colonne |X| (qui a un poids de
1).\footnote{Les valeurs négatives pour les poids, comme proposées par
  \pkg{tabu} (maintenant obsolète), ne sont \emph{pas} prises en charge par
  \pkg{nicematrix}. Si une telle valeur est utilisée, une erreur sera levée.}
\item On peut spécifier l'alignement horizontal avec une des lettres |l|, |c| et
|r| (qui insèrent respectivement |\raggedright|, |\centering| et |\raggedleft|
suivi de |\arraybackslash|).\footnote{En fait, quand \pkg{ragged2e} est chargée,
ce sont les commandes |\RaggedRight|, |\Centering| et |\RaggedLeft| de
\pkg{ragged2e} qui sont utilisées, pour un meilleur résultat.}
\item On peut spécifier l'alignement vertical avec l'une des lettres |t| (alias
|p|), |m| et |b| (qui construisent respectivement des colonnes de types |p|, |m|
et |b|). La valeur initiale est |t|.
\end{itemize}

\begin{Code}
\begin{NiceTabular}\emph{[width=9cm]{X[c,m]X[0.5,c,m]}}[hvlines]
Un texte relativement long qui tient sur plusieurs lignes. &
Un texte relativement long qui tient sur plusieurs lignes. \\
Un texte plus court. & Un texte plus court.
\end{NiceTabular}
\end{Code}


\begin{center}
\begin{NiceTabular}[width=9cm]{X[c,m]X[0.5,c,m]}[hvlines]
Un texte relativement long qui tient sur plusieurs lignes. &
Un texte relativement long qui tient sur plusieurs lignes. \\
Un texte plus court. & Un texte plus court.
\end{NiceTabular}
\end{center}

\subsection{Les colonnes V de varwidth}

\label{varwidth}
\index{varwidth@\pkg{varwidth} (extension)}
\index{V (les colonnes V de \pkg{varwidth})}

Rappelons d'abord le fonctionnement d'un environnement |{varwidth}| de
l'extension éponyme \pkg{varwidth}. Un tel environnement est similaire à
l'environnement classique |{minipage}| mais la largeur indiquée (en argument)
n'est que la largeur \emph{maximale} de la boîte créée. Dans le cas général, la
largeur d'une boîte |{varwidth}| est la largeur naturelle de son contenu.

\smallskip
Cela est illustré avec les exemples suivants :

\medskip
\begin{Code}[width=6cm]
\fbox{%
\begin{\emph{varwidth}}{8cm}
\begin{itemize}
\item premier item
\item deuxième item
\end{itemize}
\end{\emph{varwidth}}}
\end{Code}
\fbox{\begin{varwidth}{8cm}
\begin{itemize}
\item premier item
\item deuxième item
\end{itemize}
\end{varwidth}}

\bigskip
\begin{Code}[width=6cm]
\fbox{%
\begin{\emph{minipage}}{8cm}
\begin{itemize}
\item premier item
\item deuxième item
\end{itemize}
\end{\emph{minipage}}}
\end{Code}
\fbox{\begin{minipage}{8cm}
\begin{itemize}
\item premier item
\item deuxième item
\end{itemize}
\end{minipage}}

\bigskip
L'extension \pkg{varwidth} définit également le type de colonne |V|. Une colonne
|V{|$\langle$\textsl{dim}$\rangle$|}| encapsule toutes ses cases dans une
|{varwidth}| d'argument $\langle$\textsl{dim}$\rangle$ (et effectue quelques
réglages supplémentaires).

\medskip
Lorsque l'extension \pkg{varwidth} est chargée, ces colonnes |V| de
\pkg{varwidth} sont prises en charge par \pkg{nicematrix}. 

\medskip
\begin{Code}
\begin{NiceTabular}[corners=NW,hvlines]{\emph{V{3cm}V{3cm}V{3cm}}}
& un texte & un très très très très long texte \\
un très très très très long texte \\
un très très très très long texte 
\end{NiceTabular}
\end{Code}

\medskip
\begin{center}
\begin{NiceTabular}[corners=NW,hvlines]{V{3cm}V{3cm}V{3cm}}
& un texte & un très très très très long texte \\
un très très très très long texte \\
un très très très très long texte 
\end{NiceTabular}
\end{center}


Dans le cadre de
\pkg{nicematrix}, l'un des intérêts des colonnes de type |V| par rapport aux
colonnes de type |p|, |m| ou |b| est que, pour les cases d'une telle colonne,
le nœud PGF-TikZ créé pour le contenu d'une telle case a une largeur ajustée
au contenu de la case en question : cf. p.~\pageref{node-V}. 


\medskip
Les colonnes |V| de \pkg{nicematrix} acceptent les clés |t|, |p|, |m|, |b|, |l|,
|c| et |r| proposées par les colonnes~|X|: voir leur description à la section~\ref{colonne-X},
p.~\pageref{colonne-X}. 

\medskip
Remarquons que l'extension \pkg{varwidth} a quelques problèmes (au moins dans sa
version 0.92). Par exemple, avec LuaLaTeX, elle ne fonctionne pas si le contenu
commence par une instruction |\color|.

\index{Largeur@\textbf{Largeur des colonnes}|)}




\medskip
\section{Les rangées et colonnes extérieures}

\index{first-row}
\index{last-row}
\index{first-col}
\index{last-col}

Les environnements de \pkg{nicematrix} permettent de composer des rangées et des
colonnes «extérieures» grâce aux options \Definition{first-row},
\Definition{last-row}, \Definition{first-col} et \Definition{last-col}. C'est
particulièrement intéressant pour les matrices (mathématiques).
\label{exterior}

Si elle est présente, la «première rangée» (extérieure) est numérotée par~$0$
(et non $1$). Il en est de même pour la «première colonne».

\begin{Code}
$\begin{pNiceMatrix}[\emph{first-row,last-row,first-col,last-col},nullify-dots]
       & C_1    & \Cdots &        & C_4    &        \\
L_1    & a_{11} & a_{12} & a_{13} & a_{14} & L_1    \\
\Vdots & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
       & a_{31} & a_{32} & a_{33} & a_{34} &        \\
L_4    & a_{41} & a_{42} & a_{43} & a_{44} & L_4    \\
       & C_1    & \Cdots &        & C_4    &
\end{pNiceMatrix}$
\end{Code}
%
\[\begin{pNiceMatrix}[first-row,last-row=5,first-col,last-col=5,nullify-dots]
       & C_1    & \Cdots &        & C_4    &        \\
L_1    & a_{11} & a_{12} & a_{13} & a_{14} & L_1    \\
\Vdots & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
       & a_{31} & a_{32} & a_{33} & a_{34} &        \\
L_4    & a_{41} & a_{42} & a_{43} & a_{44} & L_4    \\
       & C_1    & \Cdots &        & C_4    &
\end{pNiceMatrix}\]

\medskip
Les lignes pointillées ont été tracées avec les outils qui seront présentés p.~\pageref{Cdots}.


\medskip
Il y a plusieurs remarques à formuler.
%
\begin{itemize}[beginpenalty=10000]
\item Si on utilise un environnement avec préambule explicite (|{NiceTabular}|,
|{NiceArray}| ou l'une de ses variantes), on ne doit pas mettre dans ce
préambule de spécification de colonne pour les éventuelles première et dernière
colonne : ce sera automatiquement (et nécessairement) une colonne |r| pour la
première colonne et une colonne |l| pour la dernière.\footnote{Si on souhaite
  une colonne extérieure avec un autre type d'alignement, on aura intérêt à
  considérer la commande |\SubMatrix| disponible dans le |\CodeAfter| et le
  |\CodeBefore| (cf. p.~\pageref{sub-matrix}) ou bien voir à insérer des délimiteurs
  directement dans le préambule du tableau (cf. p.~\pageref{delimiters-in-preamble}).}

\item On peut se demander comment \pkg{nicematrix} détermine le nombre de
rangées et de colonnes nécessaires à la composition de la «dernière rangée» et
de la «dernière colonne».

\begin{itemize}
\item Dans le cas d'un environnement avec préambule, comme |{NiceTabular}| ou
|{pNiceArray}|, le nombre de colonnes se déduit évidemment du préambule.

\item Dans le cas où l'option |light-syntax| (cf. p. \pageref{light-syntax}) est
utilisée, \pkg{nicematrix} profite du fait que cette option nécessite de toutes
manières le chargement complet du contenu de l'environnement (d'où
l'impossibilité de mettre du verbatim dans ce cas-là) avant composition du
tableau. L'analyse du contenu de l'environnement donne le nombre de rangées
et de colonnes.

\item Dans les autres cas, \pkg{nicematrix} détermine le nombre de rangées et de
colonnes à la première compilation et l'écrit dans le fichier |aux| pour
pouvoir l'utiliser à la compilation suivante.

\textsl{Néanmoins, il est possible de donner le numéro de la dernière rangée et
  le numéro de la dernière colonne en arguments des options |last-row| et
  |last-col|, ce qui permettra d'accélérer le processus complet de compilation.}
C'est ce que nous ferons dans la suite.
\end{itemize}

\end{itemize}

\medskip
\index{code-for-first-row}
\index{code-for-first-col}
\index{code-for-last-row}
\index{code-for-last-col}

On peut contrôler l'apparence de ces rangées et colonnes avec les options
\Definition{code-for-first-row}, \Definition{code-for-last-row},
\Definition{code-for-first-col} et \Definition{code-for-last-col}. Ces options
sont des listes de tokens qui seront insérées au début de chaque case de la
rangée ou de la colonne considérée.

\bigskip
\begin{Code}
\NiceMatrixOptions{\emph{code-for-first-row} = \color{red},
                   \emph{code-for-first-col} = \color{blue},
                   \emph{code-for-last-row} = \color{green},
                   \emph{code-for-last-col} = \color{magenta}}
$\begin{pNiceArray}{cc|cc}[first-row,last-row=5,first-col,last-col,nullify-dots]
       & C_1    & \Cdots &        & C_4    &        \\
L_1    & a_{11} & a_{12} & a_{13} & a_{14} & L_1    \\
\Vdots & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
\hline
       & a_{31} & a_{32} & a_{33} & a_{34} &        \\
L_4    & a_{41} & a_{42} & a_{43} & a_{44} & L_4    \\
       & C_1    & \Cdots &        & C_4    &
\end{pNiceArray}$
\end{Code}

\begin{scope}
\NiceMatrixOptions{code-for-first-row = \color{red},
                   code-for-first-col = \color{blue},
                   code-for-last-row = \color{green},
                   code-for-last-col = \color{magenta}}
\begin{displaymath}
\begin{pNiceArray}{cc|cc}[first-row,last-row=5,first-col,last-col,nullify-dots]
       & C_1    & \multicolumn{1}{c}{\Cdots} &        & C_4    &        \\
L_1    & a_{11} & a_{12} & a_{13} & a_{14} & L_1    \\
\Vdots & a_{21} & a_{22} & a_{23} & a_{24} & \Vdots \\
\hline
       & a_{31} & a_{32} & a_{33} & a_{34} &        \\
L_4    & a_{41} & a_{42} & a_{43} & a_{44} & L_4    \\
       & C_1    & \multicolumn{1}{c}{\Cdots} &        & C_4    &
\end{pNiceArray}
\end{displaymath}
\end{scope}



\emph{Remarques}
\begin{itemize}[beginpenalty=10000]
\item Comme on peut le voir dans l'exemple précédent, les filets horizontaux et
verticaux ne s'étendent pas dans les rangées et colonnes extérieures. Cette
remarque s'applique aussi aux filets définis par les outils de personnalisation
de \pkg{nicematrix} (cf. la clé |custom-line| p.~\pageref{custom-line}).

\item Une spécification de couleur présente dans |code-for-first-row| s'applique
à une ligne pointillée tracée dans cette «première rangée» (sauf si une valeur a
été donnée à |xdots/color|). Idem pour les autres.
\item Sans surprise, une éventuelle option |columns-width| (décrite
p.~\pageref{width}) ne s'applique pas à la «première colonne» ni à la «dernière
colonne».
\item Pour des raisons techniques, il n'est pas possible d'utiliser l'option de
la commande |\\| après la «première rangée» ou avant la «dernière rangée». Le
placement des délimiteurs serait erroné. Pour contourner cette restriction, on
pourra envisager d'utiliser la commande |\SubMatrix| dans le |\CodeAfter| (cf.
p.~\pageref{sub-matrix}).
\end{itemize}





\section{Les lignes en pointillés continues}

\label{Cdots}
\index{Pointillés@\textbf{Pointillés (lignes en ---)}|(}
\index{Lignes en pointillés|see{Pointillés}}
\indexcommand{Ldots}
\indexcommand{Cdots}
\index{Ddots@\texttt{\textbackslash Ddots}|textbf}
\index{Iddots@\texttt{\textbackslash Iddots}|textbf}
\indexcommand{Vdots}
\index{mathdots@\pkg{mathdots} (extension)}
\index{xdots (et ses sous-clés)}

À l'intérieur des environnements de l'extension \pkg{nicematrix}, de nouvelles
commandes sont définies : \DefinitionCommande{Ldots},
\DefinitionCommande{Cdots}, \DefinitionCommande{Vdots},
\DefinitionCommande{Ddots} et \DefinitionCommande{Iddots}. 
Ces commandes sont conçues pour être utilisées à la place de |\dots|, |\cdots|,
|\vdots|, |\ddots| et |\iddots|.\footnote{La commande |\iddots|, définie par
  \pkg{nicematrix}, est une variante de |\ddots| avec les points allant vers le
  haut. Si \pkg{mathdots} est chargée, la version de \pkg{mathdots} est
  utilisée. Elle correspond à la commande |\adots| de \pkg{unicode-math}.}
\newcounter{fniddots} \setcounter{fniddots}{\thefootnote}

\smallskip
Chacune de ces commandes doit être utilisée seule dans la case du tableau et
elle trace une ligne en pointillés entre les premières cases non
vides\footnote{La définition précise de ce qui est considéré comme une «case
  vide» est donnée plus loin (cf. p.~\pageref{empty-cells}).} situées de part et
d'autre de la case courante. Bien entendu, pour |\Ldots| et |\Cdots|, c'est une
ligne horizontale ; pour |\Vdots|, c'est une ligne verticale et pour |\Ddots| et
|\Iddots|, ce sont des lignes diagonales. On peut changer la couleur d'une ligne
avec l'option~|color|.\footnote{Il est aussi possible de changer la couleur de
  toutes ces lignes pointillées avec l'option |xdots/color| (\textsl{xdots} pour
  rappeler que cela s'applique à |\Cdots|, |\Ldots|, |\Vdots|, etc.) : cf.
  p.~\pageref{customization}. }

\nobreak
\medskip
\begin{Code}[width=10cm]
\begin{bNiceMatrix}
a_1      & \Cdots &        & & a_1     \\
\Vdots   & a_2    & \Cdots & & a_2     \\
         & \Vdots & \emph{\Ddots[color=red]} \\
\\
a_1      & a_2    &        & & a_n
\end{bNiceMatrix}
\end{Code}
$\begin{bNiceMatrix}
a_1      & \Cdots &        & & a_1   \\
\Vdots   & a_2    & \Cdots & & a_2   \\
         & \Vdots & \Ddots[color=red] \\
\\
a_1      & a_2    &        & & a_n
\end{bNiceMatrix}$


\interitem Pour représenter la matrice nulle, on peut choisir d'utiliser le
codage suivant :

\nobreak
\medskip
\begin{Code}[width=10cm]
\begin{bNiceMatrix}
0      & \Cdots & 0      \\
\Vdots &        & \Vdots \\
0      & \Cdots & 0
\end{bNiceMatrix}
\end{Code}
$\begin{bNiceMatrix}
0      & \Cdots & 0      \\
\Vdots &        & \Vdots \\
0      & \Cdots & 0
\end{bNiceMatrix}$

\medskip
On peut néanmoins souhaiter une matrice plus grande. Habituellement, dans un tel
cas, les utilisateurs de LaTeX ajoutent une nouvelle ligne et une nouvelle
colonne. Il est possible d'utiliser la même méthode avec \pkg{nicematrix}
:

\nobreak
\medskip
\begin{Code}[width=10cm]
\begin{bNiceMatrix}
0      & \Cdots & \Cdots & 0      \\
\Vdots &        &        & \Vdots \\
\Vdots &        &        & \Vdots \\
0      & \Cdots & \Cdots & 0
\end{bNiceMatrix}
\end{Code}
$\begin{bNiceMatrix}
0      & \Cdots &        & 0      \\
\Vdots &        &        &        \\
       &        &        & \Vdots \\
0      &        & \Cdots & 0
\end{bNiceMatrix}$

\medskip
Dans la première colonne de cet exemple, il y a deux instructions |\Vdots| mais,
bien entendu, une seule ligne en pointillés sera tracée.

\medskip
En fait, dans cet exemple, il aurait été possible de tracer la même matrice plus
rapidement avec le codage suivant (parmi d'autres) :

\nobreak
\medskip
\begin{Code}[width=10cm]
\begin{bNiceMatrix}
0       & \Cdots &        & 0      \\
\Vdots  &        &        &        \\
        &        &        & \Vdots \\
0       &        & \Cdots & 0
\end{bNiceMatrix}
\end{Code}
$\begin{bNiceMatrix}
0       & \Cdots &        & 0      \\
\Vdots  &        &        &        \\
        &        &        & \Vdots \\
0       &        & \Cdots & 0
\end{bNiceMatrix}$

\medskip
Il y a aussi d'autres moyens de changer la taille d'une matrice. On pourrait
vouloir utiliser l'argument optionnel de la commande~|\\| pour l'espacement
vertical et la commande~|\hspace*| dans une case pour l'espacement
horizontal.\footnote{Dans \pkg{nicematrix}, il faut utiliser |\hspace*| et non
  |\hspace| car \pkg{nicematrix} utilise \pkg{array}. Remarquons aussi que l'on
  peut également régler la largeur des colonnes en utilisant l'environnement
  |{NiceArray}| (ou une de ses variantes) avec une colonne de type~|w| ou |W|:
  cf. p.~\pageref{width}}

\indexcommand{Hspace}
Toutefois, une commande~|\hspace*| pourrait interférer dans la construction des
lignes en pointillés. C'est pourquoi l'extension \pkg{nicematrix} fournit une
commande~|\Hspace| qui est une variante de |\hspace| transparente pour la
construction des lignes en pointillés de \pkg{nicematrix}.

\nobreak
\medskip
\begin{Code}[width=10cm]
\begin{bNiceMatrix}
0      & \Cdots & \emph{\Hspace*{1cm}} & 0      \\
\Vdots &        &               & \Vdots \\\emph{[1cm]}
0      & \Cdots &               & 0
\end{bNiceMatrix}
\end{Code}
$\begin{bNiceMatrix}
0      & \Cdots & \Hspace*{1cm} & 0      \\
\Vdots &        &               & \Vdots \\[1cm]
0      & \Cdots &               & 0
\end{bNiceMatrix}$

\subsection{L'option nullify-dots}

\index{nullify-dots}

Considérons la matrice suivante qui a été composée classiquement avec
l'environnement |{pmatrix}| de \pkg{amsmath}.

\nobreak
\medskip
\begin{Code}[width=10cm]
$A = \begin{pmatrix}
h & i & j & k & l & m \\
x &   &   &   &   & x
\end{pmatrix}$
\end{Code}
$A = \begin{pmatrix}
h & i & j & k & l & m \\
x   &     &     &    &     & x
\end{pmatrix}$


\medskip
Si nous ajoutons des instructions |\ldots| dans la seconde rangée, la géométrie
de la matrice est modifiée.

\nobreak
\medskip
\begin{Code}[width=10cm]
$B = \begin{pmatrix}
h & i & j & k & l & m \\
x & \ldots & \ldots  & \ldots & \ldots & x
\end{pmatrix}$
\end{Code}
$B = \begin{pmatrix}
h & i & j & k & l & m \\
x   & \ldots   & \ldots  & \ldots & \ldots & x
\end{pmatrix}$

\medskip
Par défaut, avec \pkg{nicematrix}, si nous remplaçons |{pmatrix}| par
|{pNiceMatrix}| et |\ldots| par |\Ldots|, la géométrie de la matrice n'est pas
changée.

\nobreak
\medskip
\begin{Code}[width=10cm]
$C = \begin{pNiceMatrix}
h & i & j & k & l & m \\
x & \Ldots & \Ldots & \Ldots & \Ldots & x
\end{pNiceMatrix}$
\end{Code}
$C = \begin{pNiceMatrix}
h & i & j & k & l & m \\
x & \Ldots & \Ldots  & \Ldots & \Ldots & x
\end{pNiceMatrix}$

\medskip
On pourrait toutefois préférer la géométrie de la première matrice $A$ et
vouloir avoir la même géométrie avec une ligne en pointillés continue dans la
seconde rangée. C'est possible en utilisant l'option \Definition{nullify-dots}
(et une seule instruction |\Ldots| suffit).

\nobreak
\medskip
\begin{Code}[width=10cm]
$D = \begin{pNiceMatrix}[\emph{nullify-dots}]
h & i & j & k & l & m \\
x & \Ldots & & & & x
\end{pNiceMatrix}$
\end{Code}
$D = \begin{pNiceMatrix}[nullify-dots]
h & i & j & k & l & m \\
x & \Ldots & &  &  & x
\end{pNiceMatrix}$

\medskip
L'option |nullify-dots| «smashe» les instructions |\Ldots| (et ses variantes)
horizontalement mais aussi verticalement.

\medskip
\textbf{Attention} : la clé |nullify-dots| a un nom qui peut prêter à confusion ; 
elle n'implique pas que la ligne en pointillés ne sera pas tracée ! 


\subsection{Les commandes \textbackslash Hdotsfor et \textbackslash Vdotsfor}

\indexcommand{Hdotsfor}
\indexcommand{Vdotsfor}

Certaines personnes utilisent habituellement la commande |\hdotsfor| de
l'extension \pkg{amsmath} pour tracer des lignes en pointillés horizontales dans
une matrice. Dans les environnements de \pkg{nicematrix}, il convient d'utiliser
\DefinitionCommande{Hdotsfor} à la place pour avoir les lignes en pointillés
similaires à toutes celles tracées par l'extension \pkg{nicematrix}.

Comme avec les autres commandes de \pkg{nicematrix} (comme |\Cdots|, |\Ldots|,
|\Vdots|, etc.), la ligne en pointillés tracée par |\Hdotsfor| s'étend jusqu'au
contenu des cases de part et d'autre.

\medskip
\begin{Code}[width=7cm]
$\begin{pNiceMatrix}
1 & 2 & 3 & 4 & 5 \\
1 & \emph{\Hdotsfor{3}} & 5 \\
1 & 2 & 3 & 4 & 5 \\
1 & 2 & 3 & 4 & 5
\end{pNiceMatrix}$
\end{Code}
$\begin{pNiceMatrix}
1 & 2 & 3 & 4 & 5 \\
1 & \Hdotsfor{3} & 5 \\
1 & 2 & 3 & 4 & 5 \\
1 & 2 & 3 & 4 & 5
\end{pNiceMatrix}$

\medskip
Néanmoins, si ces cases sont vides, la ligne en pointillés s'étend seulement
dans les cases spécifiées par l'argument de |\Hdotsfor| (par conception).

\medskip
\begin{Code}[width=7cm]
$\begin{pNiceMatrix}
1 & 2 & 3 & 4 & 5 \\
  & \emph{\Hdotsfor{3}} \\
1 & 2 & 3 & 4 & 5 \\
1 & 2 & 3 & 4 & 5
\end{pNiceMatrix}$
\end{Code}
$\begin{pNiceMatrix}
1 & 2 & 3 & 4 & 5 \\
  & \Hdotsfor{3} \\
1 & 2 & 3 & 4 & 5 \\
1 & 2 & 3 & 4 & 5
\end{pNiceMatrix}$

\medskip
\emph{Remarque} : Contrairement à la commande |\hdotsfor| de \pkg{amsmath}, la
commande |\Hdotsfor| est utilisable même lorsque l'extension
\pkg{colortbl}\footnote{On rappelle que lorsque l'extension \pkg{xcolor} est
  chargée avec l'option |table|, l'extension \pkg{colortbl} est chargée.} est
chargée (néanmoins, dans le cadre de \pkg{nicematrix}, le chargement de
\pkg{colortbl} est déconseillé puisque nicematrix propose ses propres commandes
pour le coloriage des tableaux: cf. p.~\pageref{color-in-code-before}).

\medskip
L'extension \pkg{nicematrix} propose aussi une commande
\DefinitionCommande{Vdotsfor} similaire à |\Hdotsfor| mais traçant des lignes
verticales.

\medskip
L'exemple suivant utilise à la fois |\Hdotsfor| et |\Vdotsfor|:

\smallskip
\begin{scope}
\small
\begin{Code}
\begin{bNiceMatrix}
C[a_1,a_1] & \Cdots & C[a_1,a_n]
  & \hspace*{20mm} & C[a_1,a_1^{(p)}] & \Cdots & C[a_1,a_n^{(p)}] \\
\Vdots & \Ddots & \Vdots
  & \emph{\Hdotsfor{1}} & \Vdots & \Ddots & \Vdots \\
C[a_n,a_1] & \Cdots & C[a_n,a_n]
  & & C[a_n,a_1^{(p)}] & \Cdots & C[a_n,a_n^{(p)}] \\
\rule{0pt}{15mm}\NotEmpty  & \emph{\Vdotsfor{1}} & & \Ddots & & \emph{\Vdotsfor{1}} \\
C[a_1^{(p)},a_1] & \Cdots & C[a_1^{(p)},a_n]
  & & C[a_1^{(p)},a_1^{(p)}] & \Cdots & C[a_1^{(p)},a_n^{(p)}] \\
\Vdots & \Ddots & \Vdots
  & \emph{\Hdotsfor{1}} & \Vdots & \Ddots & \Vdots \\
C[a_n^{(p)},a_1] & \Cdots & C[a_n^{(p)},a_n]
  & & C[a_n^{(p)},a_1^{(p)}] & \Cdots & C[a_n^{(p)},a_n^{(p)}]
\end{bNiceMatrix}
\end{Code}
\end{scope}


\[\begin{bNiceMatrix}
C[a_1,a_1] & \Cdots & C[a_1,a_n] & \hspace*{20mm} & C[a_1,a_1^{(p)}] & \Cdots & C[a_1,a_n^{(p)}] \\
\Vdots & \Ddots & \Vdots & \Hdotsfor{1} &  \Vdots & \Ddots & \Vdots \\
C[a_n,a_1] & \Cdots & C[a_n,a_n] & & C[a_n,a_1^{(p)}] & \Cdots & C[a_n,a_n^{(p)}] \\
\rule{0pt}{15mm}\NotEmpty & \Vdotsfor{1} & & \Ddots & & \Vdotsfor{1} \\
C[a_1^{(p)},a_1] & \Cdots & C[a_1^{(p)},a_n] & & C[a_1^{(p)},a_1^{(p)}] & \Cdots & C[a_1^{(p)},a_n^{(p)}] \\
\Vdots & \Ddots & \Vdots & \Hdotsfor{1} & \Vdots & \Ddots & \Vdots \\
C[a_n^{(p)},a_1] & \Cdots & C[a_n^{(p)},a_n] & & C[a_n^{(p)},a_1^{(p)}] & \Cdots & C[a_n^{(p)},a_n^{(p)}]
\end{bNiceMatrix}\]



\subsection{Comment créer les lignes en pointillés de manière transparente}

\index{renew-matrix}
\index{renew-dots}

Si on a un document déjà tapé qui contient un grand nombre de matrices avec des
points de suspension, on peut souhaiter utiliser les lignes pointillées de
\pkg{nicematrix} sans avoir à modifier chaque matrice. Pour cela,
\pkg{nicematrix} propose deux options |renew-dots| et
|renew-matrix|.\footnote{Comme toutes les autres options, les options
  |renew-dots| et |renew-matrix| peuvent être fixées avec la commande
  |\NiceMatrixOptions|, mais ces deux options-là peuvent aussi être passées en option du
  |\usepackage|.}

\smallskip

\begin{itemize}
\item L'option \Definition{renew-dots}

\nobreak
Avec cette option, les commandes |\ldots|, |\cdots|, |\vdots|, |\ddots|,
|\iddots|\footnotemark[\thefniddots] et |\hdotsfor| sont redéfinies dans les
environnements de \pkg{nicematrix} et agissent alors comme |\Ldots|, |\Cdots|,
|\Vdots|, |\Ddots|, |\Iddots| et |\Hdotsfor| ; la commande |\dots| (points de
suspension «automatiques» de |amsmath|) est aussi redéfinie et se comporte comme
|\Ldots|.

\item L'option \Definition{renew-matrix}

\nobreak
Avec cette option, l'environnement |{matrix}| est redéfini et se comporte comme
|{NiceMatrix}| et il en est de même pour les cinq variantes.
\end{itemize}

\medskip
Par conséquent, avec les options |renew-dots| et |renew-matrix|, un code
classique donne directement le résultat fourni par \pkg{nicematrix}.

\nobreak
\medskip
\begin{scope}
\NiceMatrixOptions{renew-dots,renew-matrix}
\begin{Code}[width=10cm]
\emph{\NiceMatrixOptions{renew-dots,renew-matrix}}
\begin{pmatrix}
1      & \cdots & \cdots & 1      \\
0      & \ddots &        & \vdots \\
\vdots & \ddots & \ddots & \vdots \\
0      & \cdots & 0      & 1
\end{pmatrix}
\end{Code}
$\begin{pmatrix}
1      & \cdots & \cdots & 1      \\
0      & \ddots &        & \vdots \\
\vdots & \ddots & \ddots & \vdots \\
0      & \cdots & 0      & 1
\end{pmatrix}$
\end{scope}


\subsection{Les labels des lignes en pointillés}

Les commandes |\Ldots|, |\Cdots|, |\Vdots|, |\Ddots|, |\Iddots|, |\Hdotsfor| et
|\Vdotsfor| (ainsi que la commande |\line| dans le |\CodeAfter| décrite
p.~\pageref{line-in-code-after}) peuvent en fait prendre deux arguments
optionnels spécifiés par les caractères |_| et |^| pour des labels situés
au-dessous et au-dessus de la ligne. Les arguments sont composés en mode
mathématique avec |\scriptstyle|.

\smallskip
La version 6.22 de \pkg{nicematrix} a introduit un nouveau label spécifié par le
caractère~«|:|» pour un label situé \emph{sur} la ligne elle-même. Ce label est
en fait composé sur un fond blanc qui est superposé sur la ligne en pointillés
(voir un exemple p.~\pageref{ex:colon}).

\bigskip
\begin{Code}[width=10cm]
$\begin{bNiceMatrix}
1 & \hspace*{1cm}           & 0 \\[8mm]
  & \emph{\Ddots^{n \text{ fois}}} &    \\
0 &                         & 1
\end{bNiceMatrix}$
\end{Code}
$\begin{bNiceMatrix}
1 & \hspace*{1cm}           & 0 \\[8mm]
  & \Ddots^{n \text{ fois}} &   \\
0 &                         & 1
\end{bNiceMatrix}$



\bigskip
Avec la clé \Definition{horizontal-label}, le label reste
horizontal.

\nobreak
\smallskip
\begin{Code}[width=10cm]
$\begin{bNiceMatrix}
1 & \hspace*{1cm}           & 0 \\[8mm]
  & \emph{\Ddots[horizontal-label]^{n \text{ fois}}} & \\
0 &                         & 1
\end{bNiceMatrix}$
\end{Code}
$\begin{bNiceMatrix}
1 & \hspace*{1cm}           & 0 \\[8mm]
  & \Ddots[horizontal-label]^{n \text{ fois}} & \\
0 &                         & 1
\end{bNiceMatrix}$



\subsection{Personnalisation des lignes en pointillés}

\label{customization}
\index{color!clé des lignes pointillées}
\index{radius (clé des lignes pointillées)}
\index{inter (clé des lignes pointillées)}
\index{line-style (clé des lignes pointillées)}
\index{shorten (clé des lignes pointillées)}
\index{shorten-end (clé des lignes pointillées)}
\index{shorten-start (clé des lignes pointillées)}
\index{horizontal-label(s) (clé des lignes pointillées)}


Les lignes pointillées tracées par |\Ldots|, |\Cdots|, |\Vdots|, |\Ddots|,
|\Iddots|, |\Hdotsfor| et |\Vdotsfor| (ainsi que par la commande |\line| dans le
|\CodeAfter| décrite p.~\pageref{line-in-code-after}) peuvent être paramétrées
par les options suivantes (que l'on met entre crochets après la commande) :
%
\begin{itemize}[beginpenalty=10000]
\item |horizontal-label(s)| ;
\item |color| ;
\item |radius| ; 
\item |shorten-start|, |shorten-end| et |shorten| ;
\item |inter| ;
\item |line-style|.
\end{itemize}

\smallskip
Pour une commande individuelle, on peut utiliser \Definition{horizontal-label}
au singulier.

\smallskip
Ces options peuvent aussi être fixées avec |\NiceMatrixOptions| ou bien au
niveau d'un environnement mais elles doivent alors être préfixées par |xdots|
(\textsl{xdots} pour rappeler que cela s'applique à |\Cdots|, |\Ldots|,
|\Vdots|, etc.), ce qui fait que leurs noms deviennent :
%
\begin{itemize}[beginpenalty=10000]
\item |xdots/horizontal-labels| ;
\item |xdots/color| ;
\item |xdots/radius| ;
\item |xdots/shorten-start|, |xdots/shorten-end| et |xdots/shorten| ;
\item |xdots/inter| ; 
\item |xdots/line-style|.
\end{itemize}
%
Pour la clarté, dans la suite, on utilisera ces noms-là.

\bigskip
La clé \Definition{xdots/horizontal-labels} demande que les labels (introduits
par |_|, |^| et |:|) restent horizontaux.

\medskip
L'option \Definition{xdots/color} indique bien entendu la couleur de la ligne
tracée. On peut définir une couleur «à la volée» 
(ex. : |xdots/color = { [RGB]{204,204,255} }|). On remarquera que les
lignes tracées dans les rangées et colonnes extérieures (décrites plus loin)
bénéficient d'un régime spécial : cf. p.~\pageref{exterior}.

\medskip
L'option \Definition{radius} correspond au rayon des points circulaires qui sont
tracés. La valeur initiale est $0.53$~pt.

\medskip
Les clés \Definition{xdots/shorten-start} et \Definition{xdots/shorten-end}
indiquent la marge qui est laissée aux deux extrémités de la ligne. La clé
\Definition{xdots/shorten} fixe les deux clés simultanément. La valeur initiale
de $0.3$~em (il est conseillé d'utiliser une unité de mesure dépendante de la
fonte courante).\footnote{En fait, quand on utilise ces clés au niveau de
  |\NiceMatrixOptions| ou bien d'un environnement, seules les extrémités des
  lignes qui s'arrêtent au niveau d'un contenu non vide de case sont concernées.
  Quand on les utilise sur une commande |\Cdots| (ou |\Vdots|, etc.), toutes les 
  extrémités sont concernées.}

\medskip
L'option \Definition{xdots/inter} indique la distance entre deux points. La
valeur initiale est $0.45$~em (il est conseillé d'utiliser une unité de mesure
dépendante de la fonte courante).

\medskip
\textbf{L'option \Definition{xdots/line-style}}

\nobreak
\smallskip
Il faut savoir que, par défaut, les lignes de TikZ tracées avec le paramètre
|dotted| sont composées de points carrés et non pas ronds.\footnote{La raison de
  départ est que le format \textsc{pdf} comporte un système de description de
  lignes en tiretés, qui, puisqu'il est incorporé dans le \textsc{pdf}, est
  affiché très rapidement par les lecteurs de \textsc{pdf}. Il est facile à
  partir de ce type de ligne de créer des lignes de points carrés alors qu'une
  ligne de points ronds doit être construite explicitement point par point. Voir
néanmoins à l'adresse suivante pour un moyen d'avoir un style de pointillés
ronds avec TikZ :\newline \small
\url{https://tex.stackexchange.com/questions/52848}}


\begin{Code}[width=9cm]
\tikz \draw [dotted] (0,0) -- (5,0) ;
\end{Code}
\tikz \draw [dotted] (0,0) -- (5,0) ;

\medskip
Voulant proposer des lignes avec des points ronds dans le style de celui de
|\ldots| (au moins celui des fontes \emph{Computer Modern}), l'extension
\pkg{nicematrix} contient en interne son propre système de ligne en pointillés
(qui, au passage, n'utilise que \pkg{pgf} et non \pkg{tikz}). Ce style est
appelé le style |standard|. Cette valeur est la valeur initiale du paramètre
|xdots/line-style|.

\medskip
Néanmoins (quand TikZ est chargé), on peut utiliser pour |xdots/line-style|
n'importe quel style proposé par TikZ, c'est-à-dire n'importe quelle suite
d'options TikZ applicables à un chemin (à l'exception de «|color|»,
«|shorten >|» et «|shorten <|»).

\medskip
Voici par exemple une matrice tridiagonale avec le style |loosely dotted|
:

\nobreak
\medskip
\begin{Code}
$\begin{pNiceMatrix}[nullify-dots,\emph{xdots/line-style=loosely dotted}]
a      & b      & 0      &        & \Cdots & 0      \\
b      & a      & b      & \Ddots &        & \Vdots \\
0      & b      & a      & \Ddots &        &        \\
       & \Ddots & \Ddots & \Ddots &        & 0      \\
\Vdots &        &        &        &        & b      \\
0      & \Cdots &        & 0      & b      & a
\end{pNiceMatrix}$
\end{Code}


\[\begin{pNiceMatrix}[nullify-dots,xdots/line-style=loosely dotted]
a      & b      & 0      &        & \Cdots & 0      \\
b      & a      & b      & \Ddots &        & \Vdots \\
0      & b      & a      & \Ddots &        &        \\
       & \Ddots & \Ddots & \Ddots &        & 0      \\
\Vdots &        &        &        &        & b      \\
0      & \Cdots &        & 0      & b      & a
\end{pNiceMatrix}\]




\subsection{Les commandes \textbackslash Hbrace et \textbackslash Vbrace}

\colorbox{yellow!50}{\textbf{Nouveau 7.1}}

\label{Hbrace}
\indexcommand{Hbrace}
\indexcommand{Vbrace}
\index{brace (nicematrix/brace est un style TikZ\newline utilisé par \textbackslash
  Hbrace et \textbackslash Vbrace)}


\smallskip
Puisque, comme dit dans la partie précédente, il est possible d'utiliser, avec
les commandes |\Cdots|, |\Ldots|, |\Vdots|, etc. n'importe quel style de ligne
fourni par TikZ, on peut envisager de tracer des accolades avec la décoration
|brace| fournie par la bibliothèque \pkg{decorations.pathreplacing} de TikZ.


\smallskip
Pour faciliter cet usage, \pkg{nicematrix} propose les deux commandes
\DefinitionCommande{Hbrace} et \DefinitionCommande{Vbrace}. 
Celles-ci ne sont disponibles que si TikZ, ainsi que sa bibliothèque
\pkg{decorations.pathreplacing}, ont été chargées (avant ou après le chargement
de \pkg{nicematrix}). Si elles ne sont pas chargées, une erreur (non fatale) sera
levée. 
\begin{Verbatim}
\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\end{Verbatim}

\medskip
Les commandes |\Hbrace| et |\Vbrace| ont la même syntaxe. Elles prennent trois
arguments:

\begin{itemize}[beginpenalty=10000]
\item un premier argument optionnel (entre crochets) pour une liste de couples
\textsl{clé=valeur} : les clés autorisées sont |color|, |horizontal-label|,
|shorten|, |shorten-start| et |shorten-end|.

\item un deuxième argument, obligatoire, qui est le nombre de colonnes (pour
|\Hbrace|) ou de rangées (pour |\Vbrace|) sur lesquelles l'accolade va s'étendre.

\item un troisième argument, obligatoire, qui est le label de l'accolade.
\end{itemize}

Concernant la commande |\Hbrace|, son comportement vis à vis des esperluettes
(|&|) est le même que celui des commandes |\multicolumn|, |\hdotsfor|,
|\Hdotsfor|, etc. : on ne doit mettre qu'une seule esperluette après la
commande, même si l'accolade s'étend sur plusieurs colonnes.

\bigskip
\begin{Code}[width=11.2cm]
$\begin{NiceArray}{ccccc}%
  [ hvlines ,
    first-row ,
    last-row = 6,
    first-col ,
    last-col ,
    xdots/horizontal-labels ]
& \emph{\Hbrace{3}{p}} & \emph{\Hbrace{2}{q}} \\
\emph{\Vbrace{3}{p}} & 1 & 1 & 134 & 1 & 1 & \emph{\Vbrace{3}{p}} \\
& 1 & 1 & 134 & 1 & 1 \\
& 1 & 1 & 13456 & 1 & 1 \\
\emph{\Vbrace{2}{q}} & 1 & 1 & 134 & 1 & 1 & \emph{\Vbrace{2}{q}}\\
& 1 & 1 & 134 & 1 & 1 \\
& \emph{\Hbrace{3}{p}} & \emph{\Hbrace[color=blue]{2}{q}} \\
\end{NiceArray}$
\end{Code}
$\begin{NiceArray}{ccccc}%
  [
    hvlines ,
    first-row ,
    last-row = 6,
    first-col ,
    last-col ,
    xdots/horizontal-labels 
  ]
& \Hbrace{3}{p} & \Hbrace{2}{q} \\
\Vbrace{3}{p} & 1 & 1 & 134 & 1 & 1 & \Vbrace{3}{p} \\
& 1 & 1 & 134 & 1 & 1 \\
& 1 & 1 & 13456 & 1 & 1 \\
\Vbrace{2}{q}& 1 & 1 & 134 & 1 & 1 & \Vbrace{2}{q}\\
& 1 & 1 & 134 & 1 & 1 \\
& \Hbrace{3}{p} & \Hbrace[color=blue]{2}{q} \\
\end{NiceArray}$


\medskip
Le style TikZ utilisé par \pkg{nicematrix} pour tracer ces accolades est appelé 
\Definition{nicematrix/brace}. Voici la valeur initiale de ce style :

\begin{Code}
\emph{decoration = { brace , raise = -0.15 em } , }
\emph{decorate }
\end{Code}

L'utilisateur final peut changer ce style TikZ à sa guise (en respectant la
structure avec les clés |decorate| et |decoration|).


\medskip
Pour un autre exemple d'utilisation de |\Hbrace| et |\Vbrace|, voir la partie
«Des lignes pointillées qui ne sont plus pointillées»,
p.~\pageref{ex:no-longer-dotted-rules}.

\subsection{Les lignes pointillées et les filets}

\label{dotted-and-rules}

Les lignes pointillées délimitent des blocs virtuels qui ont le même
comportement vis à vis des filets que les blocs créés par |\Block| (les filets
spécifiés par le spécificateur \verb+|+ dans le préambule, la commande |\Hline|,
les clés |vlines|, |hlines|, |hvlines| et |hvlines-except-borders| et les outils
créés par |custom-line| ne sont pas tracés dans les blocs).\footnote{En revanche, la commande |\line| dans le |\CodeAfter|
  (cf.~p.~\pageref{line-in-code-after}) ne crée pas de bloc.}

\medskip
\begin{Code}[width=10.6cm]
$\begin{bNiceMatrix}[margin,\emph{hvlines}]
\Block{3-3}<\LARGE>{A} & & & 0 \\
& \hspace*{1cm} & & \Vdots \\
& & & 0 \\
0 & \Cdots& 0 & 0
\end{bNiceMatrix}$
\end{Code}
$\begin{bNiceMatrix}[margin,hvlines]
\Block[C]{3-3}<\LARGE>{A} & & & 0 \\
& \hspace*{1cm} & & \Vdots \\
& & & 0 \\
0 & \Cdots& 0 & 0
\end{bNiceMatrix}$

\index{Pointillés@\textbf{Pointillés (lignes en ---)}|)}





\section{Délimiteurs dans le préambule de l'environnement}



\index{blkarray@\pkg{blkarray} (extension)}
\index{delimiteurs@délimiteurs dans les préambules}

Pour les environnements à préambule (|{NiceArray}|, |{pNiceArray}|, etc.), il
est possible de placer des délimiteurs verticaux directement dans le
préambule.\footnote{Cette syntaxe est inspirée de l'extension \pkg{blkarray}.}
\label{delimiters-in-preamble}%

\smallskip
\index{left@\texttt{\textbackslash left} : utilisé par \pkg{nicematrix}\newline
  pour des délimiteurs\newline dans les préambules}
\index{right@\texttt{\textbackslash right} : utilisé par
  \pkg{nicematrix}\newline pour des délimiteurs\newline dans les préambules} Les
délimiteurs ouvrants doivent être précédés du mot-clé \DefinitionCommande{left}
et les délimiteurs fermants du mot-clé \DefinitionCommande{right}. Les mots-clés
|\left| et |\right| n'ont pas d'obligation à être utilisés par paires.

\smallskip
Tous les délimiteurs extensibles de LaTeX peuvent être utilisés. 

\medskip
Voici un exemple qui utilise |\lgroup| et |\rgroup|.

\medskip
\begin{Code}
$\begin{NiceArray}{\emph{\left\lgroup} ccc\emph{\right\rgroup} l}
1 & 2 & 3 &  
4 & 1 & 6 & 
7 & 8 & 9 & \scriptstyle L_3 \gets L_3 + L_1 + L_2
\end{NiceArray}$
\end{Code}

\[\begin{NiceArray}{\left\lgroup ccc\right\rgroup l}
1 & 2 & 3 &  \\
4 & 1 & 6 &  \\
7 & 8 & 9 & \scriptstyle L_3 \gets L_3 + L_1 + L_2
\end{NiceArray}\]

\medskip
Pour cet exemple, on aurait aussi pu utiliser |{NiceArrayWithDelims}| 
(cf. la partie \ref{NiceArrayWithDelims}, p.~\pageref{NiceArrayWithDelims})
et la clé |last-col| (cf. p.~\pageref{exterior}).

\bigskip
Il y a un cas particulier : pour les délimiteurs |(|, |[| et |\{|\footnote{ Pour
  les accolades, la protection par la contre-oblique est obligatoire (c'est
  pourquoi on a écrit |\{|).}, et les délimiteurs fermants correspondants, les
préfixes |\left| et |\right| sont facultatifs.\footnote{Pour les délimiteurs
  \texttt{[} et \texttt{]}, les préfixes restent obligatoires en cas de conflit
  de notation avec des crochets d'options de certains descripteurs de
  colonnes.}


\bigskip
Voici un exemple avec un délimiteur |\{| à gauche dans un |{NiceTabular}| (on
remarquera la compatibilité avec la clé |t|).

\smallskip
\begin{Verbatim}
On définit $f$ par\quad
\begin{NiceTabular}[t]{\{ll}
$f(x) = 0$ & si $x$ est négatif \\
$f(x) = 1-e^x$ & si $x$ est positif 
\end{NiceTabular}
\end{Verbatim}

\smallskip
\begin{center}
On définit $f$ par\quad
\begin{NiceTabular}[t]{\{ll}[no-cell-nodes]
$f(x) = 0$ & si $x$ est négatif \\
$f(x) = 1-e^x$ & si $x$ est positif 
\end{NiceTabular}
\end{center}

\bigskip
Dans le cas de deux délimiteurs successifs (nécessairement un fermant suivi d'un
ouvrant pour une autre sous-matrice) un espace égal à |\enskip| est inséré
automatiquement.

\medskip
\begin{Code}
$\begin{pNiceArray}{\emph{(c)(c)(c)}}
a_{11} & a_{12}                                     & a_{13} \\
a_{21} & \displaystyle \int_0^1\dfrac{1}{x^2+1}\,dx & a_{23} \\
a_{31} & a_{32}                                     & a_{33}
\end{pNiceArray}$
\end{Code}

\[\begin{pNiceArray}{(c)(c)(c)}
a_{11} & a_{12}                                     & a_{13} \\
a_{21} & \displaystyle \int_0^1\dfrac{1}{x^2+1}\,dx & a_{23} \\
a_{31} & a_{32}                                     & a_{33}
\end{pNiceArray}\]


\bigskip
Pour des constructions plus complexes, avec en particulier des délimiteurs ne
couvrant pas toutes les rangées, on aura intérêt à considérer la commande
|\SubMatrix| disponible dans le |\CodeAfter| et le |\CodeBefore|: voir la
partie~\ref{sub-matrix}, p.~\pageref{sub-matrix}. 




\section{Le \textbackslash CodeAfter}

\index{CodeAfter@\texttt{\textbackslash CodeAfter}|(}
\index{code-after}

\label{code-after}
On a présenté p.~\pageref{code-before} la clé |code-before|. Il existe en fait
une clé similaire \Definition{code-after} qui peut être utilisée pour indiquer
du code qui sera exécuté \emph{après} la construction du tableau.

\medskip
\index{sub-matrix (clé de \texttt{\textbackslash CodeAfter}, avec sous-clés)}
Pour améliorer la lisibilité du code, une syntaxe alternative est proposée : on
peut spécifier les instructions du |code-after| à la fin de l'environnement,
après le mot-clé \DefinitionCommande{CodeAfter} (la clé |code-after| reste bien
sûr obligatoire dans |\AutoNiceMatrix| et les commandes similaires). Bien que ce
soit un mot-clé, |\CodeAfter| accepte quand même un argument optionnel (entre
crochets).\footnote{Les clés autorisées dans cet argument optionnel sont les
  suivantes : |delimiters/color|, |rules| et ses sous-clés, |sub-matrix| (en
  lien avec la commande |\SubMatrix|) et ses sous-clés et |xdots| (pour la
  commande |\line|) et ses sous-clés.} 


\medskip
Les utilisateurs expérimentés peuvent, en particulier, utiliser les nœuds
PGF-TikZ créés par \pkg{nicematrix} dans le |\CodeAfter|. Ces nœuds sont décrits
à partir de la page \pageref{PGF-nodes}.

\medskip
Par ailleurs, plusieurs commandes spéciales sont disponibles dans le
|\CodeAfter| : |\line|, |\SubMatrix|, |\OverBrace|, |\UnderBrace| et
|\TikzEveryCell|. On va maintenant détailler ces commandes.

\medskip
On veillera à éviter les espaces parasites dans ce |\CodeAfter|.\footnote{Voir
  \url{https://tex.stackexchange.com/questions/52848}} 

\subsection{La commande \textbackslash line dans le \textbackslash CodeAfter}

\label{line-in-code-after}
\index{line@\texttt{\textbackslash line} (commande du
  \texttt{\textbackslash CodeAfter})}
La commande \DefinitionCommande{line} permet de tracer directement des lignes en
pointillés entre les cases. Elle prend deux arguments correspondant aux cases ou
blocs à relier. Chacun de ces deux arguments peut être :
\begin{itemize}[beginpenalty=10000]
\item une spécification de case de la forme $i$-$j$ où $i$ est le numéro de
rangée et $j$ est le numéro de colonne ; 
\item le nom d'un bloc (créé avec la commande |\Block| en utilisant la clé
|name| de cette commande).
\end{itemize}
 Les options disponibles pour personnaliser les lignes pointillées créées par
|\Cdots|, |\Vdots|, etc. peuvent aussi être passées à cette commande (cf.
p.~\pageref{customization}).

\medskip
Cette commande peut par exemple être utilisée pour tracer une ligne entre deux
cases adjacentes.

\medskip
\begin{Code}[width=11cm]
\NiceMatrixOptions{xdots/shorten = 0.6 em}
\begin{pNiceMatrix}
I       & 0      & \Cdots  & 0      \\
0       & I      & \Ddots  & \Vdots \\
\Vdots  & \Ddots & I       & 0      \\
0       & \Cdots & 0       & I
\emph{\CodeAfter \line{2-2}{3-3}}
\end{pNiceMatrix}
\end{Code}
\begin{scope}
\NiceMatrixOptions{xdots/shorten = 0.6 em}
$\begin{pNiceMatrix}
I       & 0      & \Cdots  & 0     \\
0       & I      & \Ddots  & \Vdots\\
\Vdots  &\Ddots  & I       & 0     \\
0       &\Cdots  & 0       & I
\CodeAfter \line{2-2}{3-3}
\end{pNiceMatrix}$
\end{scope}

\medskip
Elle peut aussi être utilisée pour tracer une ligne diagonale non parallèle aux
autres lignes diagonales (par défaut, les lignes tracées par |\Ddots| sont
«parallélisées» : cf.~p.~\pageref{parallelization}).

\medskip
\begin{Code}
\begin{bNiceMatrix}
1      & \Cdots &   & 1      & 2      & \Cdots          & 2      \\
0      & \Ddots &   & \Vdots & \Vdots & \hspace*{2.5cm} & \Vdots \\
\Vdots & \Ddots &   &        &        &                 &        \\
0      & \Cdots & 0 & 1      & 2      & \Cdots          & 2
\emph{\CodeAfter \line[shorten=6pt]{1-5}{4-7}}
\end{bNiceMatrix}
\end{Code}
\[\begin{bNiceMatrix}
1      & \Cdots &   & 1      & 2      & \Cdots          & 2      \\
0      & \Ddots &   & \Vdots & \Vdots & \hspace*{2.5cm} & \Vdots \\
\Vdots & \Ddots &   &        &        &                 &        \\
0      & \Cdots & 0 & 1      & 2      & \Cdots          & 2
\CodeAfter \line[shorten=6pt]{1-5}{4-7}
\end{bNiceMatrix}\]




\subsection{La commande \textbackslash SubMatrix dans le \textbackslash
  CodeAfter (et le \textbackslash CodeBefore)}

\label{sub-matrix}
\index{SubMatrix@\texttt{\textbackslash SubMatrix} (commande du 
\texttt{\textbackslash CodeAfter}\newline et du 
\texttt{\textbackslash CodeBefore})|textbf}

La commande \DefinitionCommande{SubMatrix} permet de positionner des délimiteurs
sur une partie du tableau, partie qui est considérée comme une sous-matrice. La
commande |\SubMatrix| prend cinq arguments :
\begin{itemize}[beginpenalty=10000]
\item le premier argument est le délimiteur gauche qui peut être n'importe
quel délimiteur extensible de LaTeX : |(|, |[|, |\{|, |\langle|, |\lgroup|,
|\lfloor|, etc. mais aussi le délimiteur nul |.| ;
\item le deuxième argument est le coin supérieur gauche de la sous-matrice avec
la syntaxe $i$|-|$j$ où $i$ est le numéro de rangée et $j$ le numéro de colonne
(le spécificateur |last| est utilisable) ;
\item le troisième argument est le coin inférieur droit avec la même syntaxe ;
\item la quatrième argument est le délimiteur droit ;
\item le cinquième argument, optionnel, entre crochets, est une liste de couples
\textsl{clé=valeur}.\footnote{Il n'y a pas d'argument optionnel entre crochets en première
position car un crochet ouvrant juste après |\SubMatrix| doit pouvoir être
interprété comme le premier argument (obligatoire) de |\SubMatrix|: ce
crochet est alors le délimiteur gauche de la sous-matrice (ex. :
|\SubMatrix[{2-2}{4-7}]|).}
\end{itemize}

On remarquera que la commande |\SubMatrix| trace les délimiteurs \emph{après} la
construction de la matrice : aucun espace n'est inséré par la commande
|\SubMatrix|. C'est pourquoi, dans l'exemple suivant, on a utilisé la clé
|margin| et on a inséré à la main de l'espace entre la troisième et la quatrième
colonne avec |@{\hspace{1.5em}}| dans le préambule du tableau.

\medskip
\begin{Code}[width=15cm]
\[\begin{NiceArray}{ccc\emph{@{\hspace{1.5em}}}c}[cell-space-limits=2pt,\emph{margin}]
 1           & 1            & 1            & x \\
\dfrac{1}{4} & \dfrac{1}{2} & \dfrac{1}{4} & y \\
 1           & 2            & 3            & z
\CodeAfter
  \emph{\SubMatrix({1-1}{3-3})
  \SubMatrix({1-4}{3-4})}
\end{NiceArray}\]
\end{Code}
\hspace{-4cm}
$\begin{NiceArray}{ccc@{\hspace{1.5em}}c}[cell-space-limits=2pt,margin]
 1          & 1           & 1           & x \\
\dfrac{1}{4} & \dfrac{1}{2} & \dfrac{1}{4} & y \\
 1          & 2           & 3           & z
\CodeAfter
  \SubMatrix({1-1}{3-3})
  \SubMatrix({1-4}{3-4})
\end{NiceArray}$

\medskip
En fait, dans cet exemple, il aurait sans doute été plus simple de mettre des
délimiteurs directement dans le préambule de l'environnement |{NiceArray}| (voir
la section~\ref{delimiters-in-preamble}, p.~\pageref{delimiters-in-preamble})
avec la construction suivante.

\medskip
\begin{scope}
\hfuzz=15cm
\begin{Code}[width=11cm]
$\begin{NiceArray}{\emph{(ccc)(c)}}[cell-space-limits=2pt]
 1           & 1            & 1            & x \\
\dfrac{1}{4} & \dfrac{1}{2} & \dfrac{1}{4} & y \\
 1           & 2            & 3            & z 
\end{NiceArray}$
\end{Code}
\end{scope}
$\begin{NiceArray}{(ccc)(c)}[cell-space-limits=2pt]
 1          & 1           & 1           & x \\
\dfrac{1}{4} & \dfrac{1}{2} & \dfrac{1}{4} & y \\
 1          & 2           & 3           & z 
\end{NiceArray}$



\bigskip
La commande |\SubMatrix| accepte en fait également deux arguments optionnels
spécifiés par les symboles traditionnels |^| et |_| pour des éléments en
exposant et en indice (mais aucun espace n'est réservé pour ces éléments).

\medskip
\begin{scope}
\hfuzz=15cm
\begin{Code}[width=11cm]
$\begin{bNiceMatrix}[right-margin=1em]
1 & 1 & 1 \\
1 & a & b \\
1 & c & d
\CodeAfter
  \emph{\SubMatrix[{2-2}{3-3}]^{T}}
\end{bNiceMatrix}$
\end{Code}
$\begin{bNiceMatrix}[right-margin=1em]
1 & 1 & 1 \\
1 & a & b \\
1 & c & d
\CodeAfter
  \SubMatrix[{2-2}{3-3}]^{T}
\end{bNiceMatrix}$
\end{scope}


\bigskip
Les clés disponibles pour la commande |\SubMatrix| sont les suivantes :
%
\begin{itemize}[beginpenalty=10000]
\item 
\index{left-xshift (clé de \texttt{\textbackslash SubMatrix})}
\index{right-xshift (clé de \texttt{\textbackslash SubMatrix})}
\index{xshift (clé de \texttt{\textbackslash SubMatrix})}
\Definition{left-xshift} et \Definition{right-xshift} déplacent
horizontalement les délimiteurs (il existe aussi la clé \Definition{xshift} qui
permet de régler simultanément ces deux clés) ;
\item \index{extra-height (clé de \texttt{\textbackslash SubMatrix})}
\Definition{extra-height} ajoute une quantité à la hauteur totale des
délimiteurs (hauteur~|\ht| + profondeur |\dp|) ;
\item \index{delimiters!---/color pour \texttt{\textbackslash SubMatrix}}
\Definition{delimiters/color} permet de fixer la couleur des délimiteurs (cette clé
est également disponible dans |\NiceMatrixOptions| et au niveau des
environnements à délimiteurs ou comme option de |\CodeAfter|) ;
\item \index{slim (clé de \texttt{\textbackslash SubMatrix})}
\Definition{slim} qui est une clé booléenne : lorsqu'elle est utilisée la position
horizontale des délimiteurs est calculée uniquement sur le contenu des cases
de la sous-matrice alors, que, dans le cas général, elle est calculée sur le
contenu des cases des colonnes mises en jeu (voir exemple ci-dessous) ;
\item \index{vlines!clé de \texttt{\textbackslash SubMatrix}}
\Definition{vlines} contient une liste de numéros de filets verticaux à tracer dans
la sous-matrice (si cette clé est utilisée sans valeur, tous les filets
verticaux sont tracés) ;
\item \index{hlines!clé de \texttt{\textbackslash SubMatrix}}
\Definition{hlines} est similaire à |vlines| mais pour les filets horizontaux ;
\item \index{hvlines!clé de \texttt{\textbackslash SubMatrix}}
\Definition{hvlines}, qui s'utilise sans valeur, trace tous les filets dans la
sous-matrice ;
\item \index{code (clé de \texttt{\textbackslash SubMatrix})}
\Definition{code} permet d'insérer du code, en particulier du code TikZ, après la
construction de la matrice. Cette clé est décrite en détail plus loin.
\end{itemize}
On remarquera que tous les filets sont dessinés après la construction du tableau
principal : les colonnes et les rangées ne sont pas écartées.

\medskip
Ces clés sont aussi accessibles dans |\NiceMatrixOptions|, au niveau des
environnements de \pkg{nicematrix} ou comme option de |\CodeAfter| avec le
préfixe |sub-matrix|, c'est-à-dire qu'elles sont alors nommées
|sub-matrix/left-xshift|, |sub-matrix/right-xshift|, |sub-matrix/xshift|, etc.

\medskip
\begin{Code}[width=15cm]
$\begin{NiceArray}{cc@{\hspace{5mm}}l}[cell-space-limits=2pt]
  &   & \frac{1}{2} \\
  &   & \frac{1}{4} \\[1mm]
a & b & \frac{1}{2}a+\frac{1}{4}b \\
c & d & \frac{1}{2}c+\frac{1}{4}d \\
\CodeAfter
  \SubMatrix({1-3}{2-3})
  \SubMatrix({3-1}{4-2})
  \SubMatrix({3-3}{4-3})
\end{NiceArray}$
\end{Code}
\hspace{-4cm}
$\begin{NiceArray}{cc@{\hspace{5mm}}l}[cell-space-limits=2pt]
         &   & \frac12 \\
         &      & \frac14 \\[1mm]
a & b & \frac12a+\frac14b \\
c & d & \frac12c+\frac14d \\
\CodeAfter
  \SubMatrix({1-3}{2-3})
  \SubMatrix({3-1}{4-2})
  \SubMatrix({3-3}{4-3})
\end{NiceArray}$

\medskip
Voici le même exemple avec la clé |slim| pour l'une des sous-matrices.

\medskip
\begin{Code}[width=15cm]
$\begin{NiceArray}{cc@{\hspace{5mm}}l}[cell-space-limits=2pt]
  &   & \frac{1}{2} \\
  &   & \frac{1}{4} \\[1mm]
a & b & \frac{1}{2}a+\frac{1}{4}b \\
c & d & \frac{1}{2}c+\frac{1}{4}d \\
\CodeAfter
  \SubMatrix({1-3}{2-3})[\emph{slim}]
  \SubMatrix({3-1}{4-2})
  \SubMatrix({3-3}{4-3})
\end{NiceArray}$
\end{Code}
\hspace{-4cm}
$\begin{NiceArray}{cc@{\hspace{5mm}}l}[cell-space-limits=2pt]
         &   & \frac12 \\
         &      & \frac14 \\[1mm]
a & b & \frac12a+\frac14b \\
c & d & \frac12c+\frac14d \\
\CodeAfter
  \SubMatrix({1-3}{2-3})[slim]
  \SubMatrix({3-1}{4-2})
  \SubMatrix({3-3}{4-3})
\end{NiceArray}$


\medskip
Il existe aussi une clé |name| qui permet de donner un nom à une sous-matrice
créée par une commande |\SubMatrix|. Ce nom est utilisé pour créer des nœuds
PGF-TikZ : voir p.~\pageref{node-sub-matrix}.


\bigskip
La commande |\SubMatrix| est en fait aussi disponible dans le |\CodeBefore|.
L'intérêt d'utiliser |\SubMatrix| dans le |\CodeBefore| est que les délimiteurs
tracés par ces commandes |\SubMatrix| sont alors prises en compte pour limiter les
lignes en pointillés continues (créées par |\Cdots|, |\Vdots|, etc.) qui ont
une extrémité ouverte.

Pour un exemple, voir \ref{ex:submatrix} 
p.~\pageref{ex:submatrix}.

\bigskip
En dépit de son nom, la commande |\SubMatrix| peut également être utilisée dans
|{NiceTabular}| comme dans l'exemple suivant (qui utilise |\bottomrule| et
|\toprule| de l'extension \pkg{booktabs}). 

\smallskip
\begin{Code}[width=8cm]
\begin{NiceTabular}{@{}ll@{}}
\toprule
Part A              & the first part \\
\Block{2-1}{Part B} & a first sub-part \\
                    & a second sub-part \\
\bottomrule
\CodeAfter
  \emph{\SubMatrix{\lbrace}{2-2}{3-2}{.}}
\end{NiceTabular}
\end{Code}
\hspace{2cm}
\begin{NiceTabular}{@{}ll@{}}
\toprule
Part A              & the first part \\
\Block{2-1}{Part B} & a first sub-part \\
                    & a second sub-part \\
\bottomrule
\CodeAfter
  \SubMatrix{\lbrace}{2-2}{3-2}{.}
\end{NiceTabular} 



\vspace{1cm}
\emph{Attention} : La fonctionnalité suivante est fragile et ne fonctionne pas
avec |latex|--|dvips|--|ps2pdf|.

\nobreak
\smallskip
La clé \Definition{code} de la commande |\SubMatrix| permet d'insérer du code
après la création de la matrice. Elle a surtout pour vocation d'être utilisée
pour insérer des instructions TikZ, sachant que, dans les instructions TikZ
insérées dans cette clé, les nœuds de la forme \texttt{i-j.\textsl{anchor}} ou
\verb+i-|j+ sont interprétés avec |i| et |j| étant des numéros de rangée et
colonne \emph{relatifs à la sous-matrice}.\footnote{Attention : la syntaxe
  \texttt{j\string|-i} n'est \emph{pas} autorisée.}

\medskip
\begin{Code}
$\begin{NiceArray}{ccc@{}w{c}{5mm}@{}ccc}
    &   &   && -1 & 1  & 2  \\
    &   &   &&  0 & 3  & 4  \\
    &   &   &&  0 & 0  & 5  \\
  1 & 2 & 3 && -1 & 7  & 25 \\
  0 & 4 & 5 && 0  & 12 & 41 \\
  0 & 0 & 6 && 0  & 0  & 30  
\CodeAfter
  \emph{\NewDocumentCommand{\MyDraw}{}{\tikz \draw [blue] (2-|1) -| (3-|2) -| (4-|3) ;}}
  \SubMatrix({1-5}{3-7})[\emph{code = \MyDraw}]
  \SubMatrix({4-1}{6-3})[\emph{code = \MyDraw}]
  \SubMatrix({4-5}{6-7})[\emph{code = \MyDraw}]
\end{NiceArray}$
\end{Code}



\[\begin{NiceArray}{ccc@{}w{c}{5mm}@{}ccc}
    &   &   && -1 & 1  & 2  \\
    &   &   &&  0 & 3  & 4  \\
    &   &   &&  0 & 0  & 5  \\
  1 & 2 & 3 && -1 & 7  & 25 \\
  0 & 4 & 5 && 0  & 12 & 41 \\
  0 & 0 & 6 && 0  & 0  & 30  
\CodeAfter
  \NewDocumentCommand{\MyDraw}{}{\tikz \draw [blue] (2-|1) -| (3-|2) -| (4-|3) ;}
  \SubMatrix({1-5}{3-7})[code = \MyDraw ]
  \SubMatrix({4-1}{6-3})[code = \MyDraw ]
  \SubMatrix({4-5}{6-7})[code = \MyDraw ]
\end{NiceArray}\]

\medskip
Comme on le voit, le tracé effectué par la commande |\MyDraw| est \emph{relatif}
à la sous-matrice à laquelle elle s'applique.



\subsection{Les commandes \textbackslash OverBrace et \textbackslash
  UnderBrace dans le \textbackslash CodeAfter}

\index{UncerBrace@\texttt{\textbackslash UnderBrace} (commande du 
\texttt{\textbackslash CodeAfter}\newline et du
\texttt{\textbackslash CodeBefore})}
\index{OverBrace@\texttt{\textbackslash OverBrace} (commande du 
\texttt{\textbackslash CodeAfter}\newline et du
\texttt{\textbackslash CodeBefore})}


Les commandes \DefinitionCommande{OverBrace} and \DefinitionCommande{UnderBrace}
permettent de placer des accolades horizontales sur une partie du tableau. Ces
commandes prennent trois arguments :
\begin{itemize}[beginpenalty=10000]
\item le premier argument est le coin supérieur gauche du rectangle de cases
impliquées dans l'accolade avec la syntaxe habituelle $i$|-|$j$ où $i$ est le
numéro de rangée et $j$ le numéro de colonne ;

\item le deuxième argument est le coin inférieur droit avec la même syntaxe ;

\item le troisième argument est le «label» de l'accolade qui sera placé par
\pkg{nicematrix} (avec \textsc{pgf}) au-dessus de l'accolade (pour la commande
|\OverBrace|) ou au-dessous (pour |\UnderBrace|).

Il est possible de mettre des commandes |\\| dans ce dernier argument pour
formater le label sur plusieurs lignes de texte.
\end{itemize}

\bigskip
\begin{Code}[width=9cm]
\begin{pNiceMatrix}
1  & 2  & 3  & 4  & 5  & 6  \\
11 & 12 & 13 & 14 & 15 & 16 \\
\CodeAfter
  \emph{\OverBrace{1-1}{2-3}{A}
  \OverBrace{1-4}{2-6}{B}}
\end{pNiceMatrix}
\end{Code}
$\begin{pNiceMatrix}
1  & 2  & 3  & 4  & 5  & 6  \\
11 & 12 & 13 & 14 & 15 & 16 \\
\CodeAfter
  \OverBrace{1-1}{2-3}{A}
  \OverBrace{1-4}{2-6}{B}
\end{pNiceMatrix}$

\bigskip
Attention : Aucun espace vertical n'est réservé par \pkg{nicematrix} pour ces
accolades, ni pour leurs labels.\footnote{Voir à ce sujet: \url{https://tex.stackexchange.com/questions/685755}}

\bigskip
\index{color!clé de \texttt{\textbackslash OverBrace} et \texttt{\textbackslash
  UnderBrace}}
\index{yshift (clé de \texttt{\textbackslash OverBrace} et \texttt{\textbackslash
  UnderBrace})}
\index{left-shorten (clé de \texttt{\textbackslash OverBrace} et\newline \texttt{\textbackslash
  UnderBrace})}
\index{right-shorten (clé de \texttt{\textbackslash OverBrace} et\newline \texttt{\textbackslash
  UnderBrace})}
Les commandes |\OverBrace| et |\UnderBrace| acceptent en fait un premier
argument optionnel (entre crochets) pour une liste de couples
\textsl{clé=valeur}. Les clés disponibles sont les suivantes :
\begin{itemize}[beginpenalty=10000]
\item \Definition{left-shorten} et \Definition{right-shorten} qui ne prennent
pas de valeur ; quand |left-shorten| est utilisée, l'abscisse de l'extrémité de
gauche de l'accolade est calculée à partir du contenu du sous-tableau concerné
alors que, sinon, c'est la position du filet vertical éventuel qui est utilisée
(de même pour |right-shorten|) ;

\item \Definition{shorten}, qui est la conjonction des clés |left-shorten| et |right-shorten| ;

\item \Definition{yshift}, qui déplace verticalement l'accolade (et son label) ;

\item \Definition{color} qui fixe la couleur de l'accolade et du label.
\end{itemize}

\bigskip
\begin{Code}[width=9cm]
\begin{pNiceMatrix}
1  & 2  & 3  & 4  & 5  & 6  \\
11 & 12 & 13 & 14 & 15 & 16 \\
\CodeAfter
  \OverBrace\emph{[shorten,yshift=3pt]}{1-1}{2-3}{A}
  \OverBrace\emph{[shorten,yshift=3pt]}{1-4}{2-6}{B}
\end{pNiceMatrix}
\end{Code}
$\begin{pNiceMatrix}
1  & 2  & 3  & 4  & 5  & 6  \\
11 & 12 & 13 & 14 & 15 & 16 \\
\CodeAfter
  \OverBrace[shorten,yshift=3pt]{1-1}{2-3}{A}
  \OverBrace[shorten,yshift=3pt]{1-4}{2-6}{B}
\end{pNiceMatrix}$




\subsection{La commande \textbackslash TikzEveryCell dans le \textbackslash CodeAfter}

\index{tikzeverycell@\texttt{\textbackslash TikzEveryCell} (commande du 
\texttt{\textbackslash CodeAfter}\newline et du
\texttt{\textbackslash CodeBefore})|textbf}
\label{TikzEveryCell}
\index{empty (clé de \texttt{\textbackslash TikzEveryCell})}
\index{non-empty (clé de \texttt{\textbackslash TikzEveryCell})}

La commande \DefinitionCommande{TikzEveryCell} exécute avec TikZ le chemin
rectangulaire qui correspond à chaque case du tableau, avec comme paramètres
TikZ l'argument de |\TikzEveryCell|. Cet argument doit être une liste de couples
\textsl{clé=valeur} applicables à un chemin TikZ. En fait, cette commande
s'applique à chaque case du tableau, exceptées celles situées dans les rangées
et colonnes extérieures (cf.~p.~\pageref{exterior}) et celles situées dans les
coins vides (quand la clé |corners| est utilisée: cf.~p.~\pageref{corners}).
Elle s'applique en fait aussi à chaque bloc (sauf ceux qui ont la clé
|transparent|) et ne s'applique pas aux cases individuelles situées dans ces
blocs.

\medskip
En fait, dans la liste des clés passée en argument on peut mettre une clé
\Definition{offset}. Cette clé n'est pas fournie par TikZ mais par
\pkg{nicematrix}. Elle réduit le rectangle correspondant au bloc par une marge
(horizontalement et verticalement) égale à la valeur (passée à |offset|). C'est
ce rectangle réduit qui sera le chemin exécuté par TikZ avec comme options les
autres clés de l'argument de |\TikzEveryCell|.


\medskip
\begingroup
\bigskip
\begin{Code}[width=9cm]
\renewcommand{\arraystretch}{1.3}
\begin{NiceTabular}{ccc}[corners]
  & \Block{1-2}{columns} \\
  \Block{2-1}{rows}
  & cell 1 1 & cell 1 2 \\
  & cell 2 1 & cell 2 2
\CodeAfter
  \emph{\TikzEveryCell{offset=1pt,draw}}
\end{NiceTabular}
\end{Code}
\renewcommand{\arraystretch}{1.3}
\begin{NiceTabular}{ccc}[corners]
  & \Block{1-2}{columns} \\
  \Block{2-1}{rows}
  & cell 1 1 & cell 1 2 \\
  & cell 2 1 & cell 2 2
\CodeAfter
  \TikzEveryCell{offset=1pt,draw}
\end{NiceTabular}
\endgroup


\bigskip
La commande |\TikzEveryCell| possède deux clés, utilisables en argument
optionnel, entre crochets.
\begin{itemize}[beginpenalty=10000]
\item avec la clé \Definition{empty}, la commande ne s'applique qu'aux cases
vides (les cases considérées comme vides sont décrites à la
partie~\ref{empty-cells}, p.~\pageref{empty-cells}) ;
\item avec la clé \Definition{non-empty}, la commande ne s'applique qu'aux
cases non vides.
\end{itemize}

\medskip
\begin{Code}[width=9cm]
\renewcommand{\arraystretch}{1.4}
\begin{NiceTabular}{cccccc}[hvlines]
  P & O & U & R & V & U \\
  O &   &   & E & I &   \\
  M & O & R & F & A & L \\
  E & T & A & L &   & E \\
  L & A & S & E & R & S \\
  O &   & E & X & I & T
\CodeAfter
  \emph{\TikzEveryCell[empty]{fill=gray,draw}}
\end{NiceTabular}
\end{Code}
\begin{scope}
\renewcommand{\arraystretch}{1.4}
\begin{NiceTabular}{cccccc}[hvlines]
  P & O & U & R & V & U \\
  O &   &   & E & I &   \\
  M & O & R & F & A & L \\
  E & T & A & L &   & E \\
  L & A & S & E & R & S \\
  O &   & E & X & I & T
\CodeAfter
  \TikzEveryCell[empty]{fill=gray,draw}
\end{NiceTabular}
\end{scope}



\medskip
La commande |\TikzEveryCell| est en fait aussi disponible dans le |\CodeBefore|.

\index{CodeAfter@\texttt{\textbackslash CodeAfter}|)}




\section{Les légendes et les notes dans les tableaux}

\label{s:notes}

\subsection{La légendes des tableaux}

\label{s:caption}

\index{caption (clé de \texttt{\{NiceTabular\}})}
\index{short-caption}
\index{label (clé de \texttt{\{NiceTabular\}})}
\index{caption-above}
\index{Legende@\textbf{Légende des tableaux}}


L'environnement |{NiceTabular}| propose des clés \Definition{caption},
\Definition{short-caption} et \Definition{label} à utiliser lorsque le
tableau est inséré dans un environnment flottant (typiquement un
environnement |{table}|).

\smallskip
L'intérêt d'utiliser cette clé |caption| plutôt que la commande classique
|\caption| est que la légende, si elle est longue, est justifiée à la largeur du
tableau (hors éventuelles colonnes extérieures spécifiées par |first-col| et
|last-col| : cf.~\ref{exterior}, p.~\pageref{exterior}). Il n'y a pas besoin
d'avoir recours à l'extension \pkg{threeparttable} ou l'extension
\pkg{floatrow}.

\smallskip
Par défaut, la légende est placée au-dessous du tableau. Pour avoir la légende
placée au-dessus, il convient d'utiliser la clé \Definition{caption-above} dans
|\NiceMatrixOptions|. 

\smallskip
La clé |short-caption| correspond à l'argument optionnel de la commande
classique |\caption| et la clé |label| correspond bien sûr à la commande |\label|.

\smallskip
Voir table \ref{t:tabularnote}, p.~\pageref{t:tabularnote}, un exemple
d'utilisation des clés |caption| et |label|.

\smallskip
Ces fonctionnalités sont compatibles avec l'extension \pkg{caption}.

\subsection{Les notes de pied de page}

\index{footnote@\pkg{footnote} (extension)}
\index{footnote (clé)}
\index{footnotehyper@\pkg{footnotehyper} (extension)}
\index{footnotehyper (clé)}

\smallskip
L'extension \pkg{nicematrix} permet, en utilisant \pkg{footnote} ou bien
\pkg{footnotehyper}, d'extraire les notes insérées avec |\footnote| dans un
environnement de \pkg{nicematrix} pour les reporter en pied de page avec les
autres notes du document.

\smallskip
Si \pkg{nicematrix} est chargée avec l'option |footnote| (avec
|\usepackage[footnote]{nicematrix}| ou avec |\PassOptionsToPackage|),
l'extension \pkg{footnote} est chargée (si elle ne l'est pas déjà) et elle est
utilisée pour extraire les notes de pied de page.

\smallskip
Si \pkg{nicematrix} est chargée avec l'option |footnotehyper|, l'extension
\pkg{footnotehyper} est chargée (si elle ne l'est pas déjà) et elle est utilisée
pour extraire les notes de pied de page.

\smallskip
Attention : Les extensions \pkg{footnote} et \pkg{footnotehyper} sont
incompatibles. L'extension \pkg{footnotehyper} est le successeur de l'extension
\pkg{footnote} et devrait être utilisée préférentiellement. L'extension
\pkg{footnote} a quelques défauts ; en particulier, elle doit être chargée après
l'extension \pkg{xcolor} et elle n'est pas parfaitement compatible avec
\pkg{hyperref}.



\subsection{Les notes de tableaux}
\index{nota@\textbf{Notes dans les tableaux}|(}
\label{tabularnote}
\index{tabularnote@\texttt{\textbackslash tabularnote}}

L'extension \pkg{nicematrix} propose aussi une commande
\DefinitionCommande{tabularnote} qui permet de spécifier des notes qui seront
composées à la fin du tableau avec une longueur pour les lignes de texte égale à
la largeur du tableau (hors éventuelles colonnes extérieures spécifiées par
|first-col| et |last-col|: cf.~\ref{exterior}, p.~\pageref{exterior}). Sans
surprise, cette commande n'est disponible que dans |{NiceTabular}|,
|{NiceTabular*}| et |{NiceTabularX}|.


\index{enumitem@\pkg{enumitem} (extension requise pour utiliser\newline
  \texttt{\textbackslash tabularnote})}
En fait, cette commande n'est disponible que si l'extension \pkg{enumitem} a été
chargée (avant ou après \pkg{nicematrix}). Les notes sont en effet composées en
fin de tableau selon un type de liste défini par l'extension \pkg{enumitem}.

\medskip
\begin{Code}
\begin{NiceTabular}{@{}llr@{}}
\toprule \RowStyle{\bfseries}
Nom & Prénom & Date de naissance \\
\midrule
Achard\emph{\tabularnote{La famille Achard est une très ancienne famille du Poitou.}}
& Jacques & 5 juin 1962 \\
Lefebvre\emph{\tabularnote{Le patronyme Lefebvre est une altération de Lefébure.}}
& Mathilde & 23 mai 1988 \\
Vanesse & Stéphanie & 30 octobre 1994 \\
Dupont & Chantal & 15 janvier 1998 \\
\bottomrule
\end{NiceTabular}
\end{Code}

\begin{center}
\begin{NiceTabular}{@{}llr@{}}[no-cell-nodes]
\toprule \RowStyle{\bfseries}
Nom & Prénom & Date de naissance \\
\midrule
Achard\tabularnote{La famille Achard est une très ancienne famille du Poitou.}
& Jacques & 5 juin 1962 \\
Lefebvre\tabularnote{Le patronyme Lefebvre est une altération de Lefébure.}
& Mathilde & 23 mai 1988 \\
Vanesse & Stéphanie & 30 octobre 1994 \\
Dupont & Chantal & 15 janvier 1998 \\
\bottomrule
\end{NiceTabular}
\end{center}



\medskip
\begin{itemize}[beginpenalty=10000]
\item La commande |\tabularnote| est en fait utilisable avant
l'environnement de \pkg{nicematrix}, le but étant de pouvoir l'utiliser sur le
titre inséré par |\caption| dans un environnement |{table}| de LaTeX (ou dans la
commande |\captionof| de l'extension \pkg{caption}). Sans surprise, il est
également possible de l'utiliser dans la légende rentrée avec la clé |caption|
de l'environnement |{NiceTabular}|.

\item Si plusieurs commandes |\tabularnote{...}| se suivent \emph{sans aucun espace
  entre elles}, les appels de notes correspondants sont composés ensemble,
séparés par une virgule (comme avec l'option |multiple| de \pkg{footmisc} pour
les notes de pied de page).

\item Si une commande |\tabularnote{...}| se trouve exactement à la fin d'une
case (sans aucun espace après) et que le mode d'alignement de la colonne est |c|
ou~|r|, l'appel de note est composé en débordement vers la droite (cela peut
permettre de mieux conserver l'alignement des contenus d'une colonne).

\item Si la clé \Definition{notes/para} est utilisée, les notes sont composées à
la fin du tableau en un seul paragraphe.

\item \index{tabularnote (clé de \texttt{\{NiceTabular\}})}
Il existe une clé \Definition{tabularnote} qui permet d'insérer du texte dans la
zone des notes avant les notes numérotées.

\index{tabularnote-env@\texttt{\{TabularNote\}}}
\index{notes (clé pour paramétrer les notes de\newline tableau)}

Une syntaxe alternative est proposée : il est possible d'utiliser
l'environnement |{TabularNote}| à la fin de l'environnement |{NiceTabular}|
(mais \emph{avant} l'éventuel |\CodeAfter|).

\item Si l'extension \pkg{booktabs} a été chargée (avant ou après
\pkg{nicematrix}), la clé \Definition{notes/bottomrule} permet de faire tracer
un |\bottomrule| de \pkg{booktabs} \emph{après} les notes.

\item Lorsque plusieurs commandes |\tabularnote| sont utilisées avec le même
argument, une seule note est insérée en fin de tableau (mais tous les labels
sont marqués). Il est possible de désactiver cette fonctionnalité avec la clé
|notes/detect-duplicates|.\footnote{Pour des raisons techniques, il n'est pas
  autorisé de mettre plusieurs |\tabularnote| avec exactement le même argument
  dans la légende. Ce n'est pas vraiment contraignant.}

\item Il est possible de référencer une note de tableau (avec la commande
|\label| placée après le |\tabularnote|).

\item La commande |\tabularnote| admet un argument optionnel (entre crochets)
qui permet de changer le symbole de l'appel de note.

\emph{Exemple} : |\tabularnote[$\star$]{Une note...}|.
\end{itemize}
%
Voir sur la table \ref{t:tabularnote}, p.~\pageref{t:tabularnote}, certaines de ces
remarques illustrées. Cette table a été composée avec le code suivant
(l'extension \pkg{caption} a été chargée dans ce document).

\bigskip
\begin{scope}
\small
\begin{Code}
\begin{table}[hbt]
\centering
\NiceMatrixOptions{caption-above}
\begin{NiceTabular}{@{}llc@{}}%
  [
   caption = Un tableau dont la légende a été rentrée avec la clé \texttt{caption}%
              \emph{\tabularnote[$\star$]{On peut mettre une note dans la légende.}} ,
   label = t:tabularnote, 
   tabularnote = Un peu de texte avant les notes. ,
   notes/bottomrule
  ]
\toprule
Nom       & Prénom   & Durée de vie \\
\midrule
Barrère   & Bertrand & 86\\
Nightingale\emph{\tabularnote{Souvent considérée comme la première infirmière.}%
           \tabularnote{Surnommée «la Dame à la Lampe».}} 
          & Florence\emph{\tabularnote{Cette note est commune à deux appels de notes.}} & 90 \\
Schœlcher & Victor   & 89\emph{\tabularnote{L’appel de note déborde à droite.}}\\
Touchet   & Marie\emph{\tabularnote{Cette note est commune à deux appels de notes.}} & 89 \\
Wallis    & John     & 87 \\
\bottomrule
\end{NiceTabular}
\end{table}
\end{Code}
\end{scope}


\begin{table}[hbt]
\centering
\NiceMatrixOptions{caption-above}
\begin{NiceTabular}{@{}llc@{}}%
  [
   caption = Un tableau dont la légende a été rentrée avec la clé \texttt{caption}%
              \tabularnote[$\star$]{On peut mettre une note dans la légende.} ,
   label = t:tabularnote, 
   tabularnote = Un peu de texte avant les notes. ,
   notes/bottomrule ,
   no-cell-nodes
  ]
\toprule
Nom & Prénom & Durée de vie \\
\midrule
Barrère & Bertrand &  86\\
Nightingale\tabularnote{Souvent considérée comme la première
  infirmière.}\tabularnote{Surnommée «la Dame à la Lampe».}
& Florence\tabularnote{Cette note est commune à deux appels de notes.} & 90 \\
Schœlcher & Victor & 89\tabularnote{L’appel de note déborde à droite.}\\
Touchet & Marie\tabularnote{Cette note est commune à deux appels de notes.} & 89 \\
Wallis & John & 87 \\
\bottomrule
\end{NiceTabular}
\end{table}




\subsection{Personnalisation des notes de tableau}

\index{para (sous-clé de «notes»)}
\index{bottomrule (sous-clé de «notes»)}
\index{style (sous-clé de «notes»)}
\index{label-in-tabular (sous-clé de «notes»)}
\index{label-in-list (sous-clé de «notes»)}
\index{enumitem-keys (sous-clé de «notes»)}
\index{enumitem-keys-para (sous-clé de «notes»)}
\index{code-before!sous-clé de «notes»}
\index{detect-duplicates (sous-clé de «notes»)}


Les notes de tableau peuvent être personnalisées grâce à un ensemble de clés
disponibles dans |\NiceMatrixOptions|. Ces clés ont un nom préfixé par |notes| :
\begin{itemize}[beginpenalty=10000]
\item |notes/para|
\item |notes/bottomrule|
\item |notes/style|
\item |notes/label-in-tabular|
\item |notes/label-in-list|
\item |notes/enumitem-keys|
\item |notes/enumitem-keys-para|
\item |notes/code-before|
\item |notes/detect-duplicates|
\end{itemize}
Pour la commodité, il est aussi possible de fixer ces clés dans
|\NiceMatrixOptions| via une clé |notes| qui prend en argument une liste de
paires \textsl{clé=valeur} où le nom des clés n'a plus à être préfixé par
|notes|:
\begin{center}
\small
\begin{Code}
\NiceMatrixOptions
  {
    \emph{notes} =
     {
       bottomrule ,
       style = ... ,
       label-in-tabular = ... ,
       enumitem-keys =
        {
          labelsep = ... ,
          align = ... ,
          ...
        }
     }
  }
\end{Code}
\end{center}


\medskip
On détaille maintenant ces clés.

\begin{itemize}[itemsep=\medskipamount,beginpenalty=10000]
\item La clé \Definition{notes/para} demande la composition des notes en fin de
tableau en un seul paragraphe.

Valeur initiale : |false|

Cette clé est également accessible dans un environnement individuel.

\item La clé \Definition{notes/bottomrule} permet de faire tracer un
  |\bottomrule| de \pkg{booktabs} \emph{après} les notes. Ce trait n'est tracé
  que s'il y a effectivement des notes dans le tableau. L'extension
  \pkg{booktabs} doit avoir été chargée (avant ou après l'extension
  \pkg{nicematrix}). Dans le cas contraire, une erreur est générée.

Valeur initiale : |false|

Cette clé est également accessible dans un environnement individuel.

\item La clé \Definition{notes/style} est une commande dont l'argument est
spécifié par |#1| et qui indique le style de numérotation des notes. C'est ce
style qui est utilisé par |\ref| pour faire référence à une note de tableau pour
laquelle on a utilisé un |\label|. Ce sont les labels mis en forme avec ce style
qui sont séparés par des virgules quand on utilise plusieurs commandes
|\tabularnote| successivement. Le marqueur |#1| est censé correspondre à un nom
de compteur LaTeX.

Valeur initiale : |\textit{\alph{#1}}|

Une autre valeur possible pourrait être tout simplement |\arabic{#1}|

\item La clé \Definition{notes/label-in-tabular} est une commande dont
l'argument est spécifié par |#1| et qui sert au formatage de l'appel de note
dans le tableau. En interne, le numéro de note a déjà été formaté par
|notes/style| avant d'être passé en argument à cette commande.

Valeur initiale : |\textsuperscript{#1}|

Pour la composition du français, il est de tradition de mettre un petit espace
avant l'appel de note. On peut faire ce réglage de la manière suivante :

\begin{Code}
\NiceMatrixOptions{notes/label-in-tabular = \,\textsuperscript{#1}}
\end{Code}


\item La clé \Definition{notes/label-in-list} est une commande dont l'argument est
spécifié par |#1| et qui sert au formatage du numéro de note dans la liste des
notes en fin de tableau. En interne, le numéro de note a déjà été formaté par
|notes/style| avant d'être passé en argument à cette commande.

Valeur initiale : |\textsuperscript{#1}|

Pour la composition du français, on ne compose pas les labels des notes en
lettres supérieures dans la liste des notes. On pourra donc prendre le réglage
suivant :

\begin{Code}
\NiceMatrixOptions{notes/label-in-list = #1.\nobreak\hspace{0.25em}}
\end{Code}

La commande |\nobreak| est pour le cas où l'option |para| est utilisée.



\item Les notes sont composées en fin de tableau en utilisant en interne un
style de liste de \pkg{enumitem}. Ce style de liste est défini de la manière
suivante (avec, bien sûr, des clés de \pkg{enumitem}) :

|noitemsep , leftmargin = * , align = left , labelsep = 0pt|

La spécification |align = left| de ce style demande que le label de la note soit
composé à gauche dans la boîte qui lui est dévolue. Ce réglage a l'avantage
d'avoir les notes calées à gauche, ce qui est plaisant si on compose des
tableaux dans l'esprit de \pkg{booktabs} (voir par exemple la table~\ref{t:tabularnote},
p.~\pageref{t:tabularnote}).

\medskip
La clé \Definition{notes/enumitem-keys} fournie par \pkg{nicematrix} permet de
modifier ce type de liste de \pkg{enumitem} (en utilisant en interne la commande
|\setlist*| de \pkg{enumitem}).


\item La clé \Definition{notes/enumitem-keys-para} est similaire à la précédente
mais elle est utilisée pour le type de liste qui sera utilisé quand l'option
|para| est choisie. Bien entendu, quand cette option |para| est active, c'est
une liste de type |inline| (suivant le vocabulaire de \pkg{enumitem}) qui est
utilisée et les paires \textsl{clé=valeur} doivent donc correspondre à une telle
liste de type |inline|.

Initialement, le style de liste utilisé est défini par :\quad 

|afterlabel = \nobreak, itemjoin = \quad|


\item La clé \Definition{notes/code-before} est une liste de tokens qui seront
insérés avant la composition de la liste de notes.

Valeur initiale : \textsl{vide}

Si on souhaite, par exemple, que les notes soient composées en gris et en
|\footnotesize|, c'est cette clé qu'il faut utiliser.
\begin{Verbatim}
\NiceMatrixOptions{notes/code-before = \footnotesize \color{gray}}
\end{Verbatim}
On peut aussi mettre dans cette clé |\raggedright| ou |\RaggedRight| (cette
dernière est une commande de \pkg{ragged2e}).

\item La clé \Definition{notes/detect-duplicates} active la détection des
commandes |\tabularnote| avec le même argument.

Valeur initiale : |true|
\end{itemize}

\index{nota@\textbf{Notes dans les tableaux}|)}


\medskip
Pour un exemple de personnalisation des notes de tableau, voir p.~\pageref{ex:notes}.


\subsection{Utilisation de \{NiceTabular\} avec threeparttable}

\index{threeparttable@\pkg{threeparttable} (extension)}

Si vous souhaitez utiliser les environnements |{NiceTabular}|, |{NiceTabular*}|
ou |{NiceTabularX}| dans un environnement |{threeparttable}| de l'extension
éponyme, vous devez patcher l'environnement |{threeparttable}| avec le code
suivant.

\begin{Code}
\makeatletter
\AddToHook{env/threeparttable/begin}
  {\TPT@hookin{NiceTabular}\TPT@hookin{NiceTabular*}\TPT@hookin{NiceTabularX}}
\makeatother
\end{Code}

Néanmoins, les fonctionnalités proposées par \pkg{nicematrix} rendent peu utile
l'utilisation de \pkg{threeparttable} en conjonction avec \pkg{nicematrix} (voir
la clé |caption| à la partie \ref{s:caption}, p.~\pageref{s:caption}).


\section{Autres fonctionnalités}

\subsection{La clé rounded-corners}

\label{tabular-rounded-corners}
\index{rounded-corners!clé de \texttt{\{NiceTabular\}}}
\index{Coins arrondis!pour un tableau}

La clé |rounded-corners| que l'on décrit maintenant n'a pas de lien direct avec
la clé |corners| (qui sert à spécifier les «coins vides») décrite à la
partie~\ref{corners}, p.~\pageref{corners}.

\smallskip
La clé \Definition{rounded-corners} spécifie que le tableau ou la matrice devra avoir des
coins arrondis avec un rayon égal à la valeur de cette clé (la valeur par défaut est
4~pt\footnote{Cette valeur est la valeur par défaut des «\texttt{rounded
    corners}» de PGF/Tikz.}). Plus précisément, cette clé a deux effets que l'on
décrit maintenant.
\begin{itemize}[beginpenalty=10000]
\item Toutes les commandes de coloriage de cases, colonnes et rangées (que ce
soit dans le |\CodeBefore| ou bien directement dans le tableau respectent ces
coins arrondis pour le tableau. 

\item Quand la clé |hvlines| est utilisée, les filets extérieurs sont tracés
avec des coins arrondis.\footnote{Bien sûr, lorsqu'il s'agit d'un environnement
  avec des délimiteurs (|{pNiceArray}|, |{pNiceMatrix}|, etc.) la clé
  |hvlines| ne trace pas les filets extérieurs.}
\end{itemize}

\bigskip
Cette clé est disponible dans tous les environnements et commandes de
\pkg{nicematrix} (comme par exemple |\pAutoNiceMatrix|) et également dans
|\NiceMatrixOptions|.

\bigskip
\begin{Code}[width=9.5cm]
\begin{NiceTabular}{ccc}[hvlines,\emph{rounded-corners}]
\CodeBefore
  \rowcolor{red!15}{1}
\Body
  Nom & Prénom & Profession \\
  Arvy & Jacques & Dentiste \\
  Jalon & Amandine & Dentiste \\
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}[hvlines,rounded-corners,no-cell-nodes]
\CodeBefore
  \rowcolor{red!15}{1}
\Body
  Nom & Prénom & Profession \\
  Arvy & Jacques & Dentiste \\
  Jalon & Amandine & Dentiste \\
\end{NiceTabular}



\subsection{Commande \textbackslash ShowCellNames}

\index{ShowCellNames@\texttt{\textbackslash ShowCellNames} (commande du 
\texttt{\textbackslash CodeAfter}\newline et du 
\texttt{\textbackslash CodeBefore})}

La commande \DefinitionCommande{ShowCellNames}, utilisable dans le |\CodeBefore|
et le |\CodeAfter| affiche le nom (sous la forme $i$-$j$) de chaque case. Quand elle
est utilisée dans le |\CodeAfter|, cette commande applique un rectangle blanc
semi-transparent pour estomper le tableau (attention : certains lecteurs de
\textsc{pdf} ne prennent pas en charge la transparence).


\medskip
\begin{Code}[width=10.6cm]
\begin{NiceTabular}{ccc}[hvlines,cell-space-limits=3pt]
  \Block{2-2}{} &           & test \\
                &           & blabla \\
                & some text & nothing 
\emph{\CodeAfter \ShowCellNames}
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}[hvlines,cell-space-limits=3pt]
  \Block{2-2}{} &           & test \\
                &           & blabla \\
                & some text & nothing 
\CodeAfter \ShowCellNames
\end{NiceTabular}


\subsection{Utilisation du type de colonne S de siunitx}


\index{S (les colonnes S de \pkg{siunitx})}
\index{siunitx@\pkg{siunitx} (extension)}

Si l'extension \pkg{siunitx} est chargée (avant ou après \pkg{nicematrix}), il
est possible d'utiliser les colonnes de type |S| de \pkg{siunitx} dans les
environnements de \pkg{nicematrix}. 

\medskip
\begin{Code}[width = 10.6cm]
$\begin{pNiceArray}{\emph{S}cW{c}{1cm}c}[nullify-dots,first-row]
{C_1} & \Cdots &  & C_n \\
2.3  & 0 & \Cdots & 0 \\
12.4 & \Vdots & & \Vdots \\
1.45 \\
7.2  & 0 & \Cdots & 0
\end{pNiceArray}$
\end{Code}
$\begin{pNiceArray}{ScW{c}{1cm}c}[nullify-dots,first-row]
{C_1} & \Cdots &  & C_n \\
2.3  & 0 & \Cdots & 0 \\
12.4 & \Vdots & & \Vdots \\
1.45 \\
7.2  & 0 & \Cdots & 0
\end{pNiceArray}$

\medskip
En revanche, les colonnes |d| de l'extension \pkg{dcolumn} ne sont \emph{pas} prises en
charge par \pkg{nicematrix}.



\subsection{Type de colonne par défaut dans \{NiceMatrix\}}

\label{columns-type}
\index{columns-type (clé de \texttt{\{NiceMatrix\}}, etc.)}

Les environnements sans préambule (|{NiceMatrix}|, |{pNiceMatrix}|, etc.) ainsi
que la commande |\pAutoNiceMatrix| et ses variantes, acceptent la clé
\Definition{columns-type} qui indique le type de colonne qui sera utilisé.

\medskip
Les clés \Definition{l} et \Definition{r} sont des raccourcis pour
|columns-type=l| et |columns-type=r|. 

\medskip
\begin{Code}[width=10cm]
$\begin{bNiceMatrix}\emph{[r]}
\cos x & - \sin x \\
\sin x & \cos x
\end{bNiceMatrix}$
\end{Code}
$\begin{bNiceMatrix}[r,no-cell-nodes]
\cos x & - \sin x \\
\sin x & \cos x
\end{bNiceMatrix}$


\medskip
La clé |columns-type| peut être utilisée dans |\NiceMatrixOptions| à condition
de la préfixer par |matrix|, ce qui fait que son nom devient |matrix/columns-type|.


\subsection{La commande \textbackslash rotate}

\label{rotate}
\index{rotate@\texttt{\textbackslash rotate}}

Utilisée au début d'une case, la commande \DefinitionCommande{rotate} (fournie
par \pkg{nicematrix}) compose le contenu après une rotation de 90° dans le sens
direct.

Dans l'exemple suivant, on l'utilise dans le |code-for-first-row|.\footnote{On
  peut aussi l'utiliser dans |\RowStyle| (cf. p.~\pageref{RowStyle}).}

\medskip

\begin{Code}[width=12cm]
\NiceMatrixOptions
 {code-for-first-row = \scriptstyle \emph{\rotate} \text{image de },
  code-for-last-col = \scriptstyle }
$A = \begin{pNiceMatrix}[first-row,last-col=4]
e_1 & e_2 & e_3       \\
1   & 2   & 3   & e_1 \\
4   & 5   & 6   & e_2 \\
7   & 8   & 9   & e_3
\end{pNiceMatrix}$
\end{Code}
\begin{varwidth}{10cm}
\NiceMatrixOptions
 {code-for-first-row = \scriptstyle\rotate \text{image de },
  code-for-last-col = \scriptstyle }
$ A = \begin{pNiceMatrix}[first-row,last-col=4,no-cell-nodes]
e_1 & e_2 & e_3 \\
1   & 2   & 3  & e_1 \\
4   & 5   & 6  & e_2 \\
7   & 8   & 9  & e_3 \\
\end{pNiceMatrix}$
\end{varwidth}

\medskip
\index{first-row|textit}
\index{last-row|textit}
\index{code-for-first-row|textit}
\index{code-for-last-row|textit}
\index{last-col|textit}
\index{code-for-last-col|textit}
Si la commande |\rotate| est utilisée dans la «dernière rangée» (extérieure à la
matrice), les éléments qui subissent cette rotation sont alignés vers le haut.

\medskip
\begin{Code}[width=12cm]
\NiceMatrixOptions
 {code-for-last-row = \scriptstyle \emph{\rotate} ,
  code-for-last-col = \scriptstyle }
$A = \begin{pNiceMatrix}[last-row=4,last-col=4]
1   & 2   & 3   & e_1 \\
4   & 5   & 6   & e_2 \\
7   & 8   & 9   & e_3 \\
\text{image de } e_1 & e_2 & e_3
\end{pNiceMatrix}$
\end{Code}
\begin{varwidth}{10cm}
\NiceMatrixOptions
 {code-for-last-row = \scriptstyle\rotate ,
  code-for-last-col = \scriptstyle }%
$A = \begin{pNiceMatrix}[last-row=4,last-col=4,no-cell-nodes]
1   & 2   & 3  & e_1 \\
4   & 5   & 6  & e_2 \\
7   & 8   & 9  & e_3 \\
\text{image de } e_1 & e_2 & e_3
\end{pNiceMatrix}$
\end{varwidth}

\bigskip
La commande |\rotate| accepte une option |c| entre crochets : |\rotate[c]| (les
espaces sont supprimés après |\rotate[c]|). Quand cette clé est utilisée, le
contenu, après rotation, est composé dans une |\vcenter| (une primitive de TeX),
ce qui fait que, le plus souvent, on obtiendra un centrage vertical.


\medskip
Attention : la commande |\rotate| est prévue pour être utilisée dans un |\Block|
ou bien dans des colonnes de type |l|, |c|, |r|, |w| ou |W|; si elle est
utilisée dans un autre type de colonne (commme |p{...}|), les résultats ne
seront peut-être pas ceux attendus.


\subsection{L'option small}

\label{small}
\index{small (clé pour un environnement)}
\index{smallmatrix@\texttt{\{smallmatrix\}} (environnement de \pkg{amsmath})}


Avec l'option \Definition{small}, les environnements de l'extension
\pkg{nicematrix} sont composés d'une manière proche de ce que propose
l'environnement |{smallmatrix}| de l'\pkg{amsmath} (et les environnements
|{psmallmatrix}|, |{bsmallmatrix}|, etc. de \pkg{mathtools}).

\medskip
\begin{Code}
$\begin{bNiceArray}{cccc|c}[\emph{small},
                            last-col,
                            code-for-last-col = \scriptscriptstyle,
                            columns-width = 3mm ]
1 & -2 & 3 & 4 & 5 \\
0 & 3  & 2 & 1 & 2 & L_2 \gets 2 L_1 - L_2 \\
0 & 1  & 1 & 2 & 3 & L_3 \gets L_1 + L_3
\end{bNiceArray}$
\end{Code}
%
\[\begin{bNiceArray}{cccc|c}%
 [small, last-col, code-for-last-col = \scriptscriptstyle, columns-width=3mm,
  no-cell-nodes]
1 & -2 & 3 & 4 & 5 \\
0 & 3  & 2 & 1 & 2 & L_2 \gets 2 L_1 - L_2 \\
0 & 1  & 1 & 2 & 3 & L_3 \gets L_1 + L_3
\end{bNiceArray}\]



\medskip
On remarquera néanmoins que l'environnement |{NiceMatrix}| avec l'option |small|
ne prétend pas être composé exactement comme l'environnement |{smallmatrix}|.
C'est que les environnements de \pkg{nicematrix} sont tous fondés sur |{array}|
(de \pkg{array}) alors que ce n'est pas le cas de |{smallmatrix}| (fondé
directement sur un |\halign| de TeX).

\medskip
En fait, l'option |small| correspond aux réglages suivants :
\begin{itemize}[beginpenalty=10000]
\item les composantes du tableau sont composées en |\scriptstyle| ;
\item |\arraystretch| est fixé à $0.47$ ;
\item |\arraycolsep| est fixé à $1.45$~pt ;
\item les caractéristiques des lignes en pointillés sont également modifiées.
\end{itemize}

\medskip
Quand la clé |small| est active, certaines fonctionnalités de \pkg{nicematrix}
ne sont plus disponibles: par exemple, il n'est plus possible de mettre des
délimiteurs directement dans le préambule d'un environnement avec préambule (cf. 
partie \ref{delimiters-in-preamble}, p.~\pageref{delimiters-in-preamble}).


\subsection{Les compteurs iRow et jCol}

\label{iRow}
\index{iRow (compteur LaTeX)}
\index{jCol (compteur LaTeX)}

Dans les cases du tableau, il est possible d'utiliser les compteurs LaTeX |iRow|
et |jCol|\footnote{Il s'agit bien de compteurs LaTeX, ce qui fait que les
  compteurs TeX sous-jacents sont |\c@iRow| et |\c@jCol|.} qui représentent le
numéro de la rangée courante et le numéro de la colonne courante. On rappelle
que le numéro de la «première rangée» (si elle existe) est $0$ et que le numéro
de la «première colonne» (si elle existe) est $0$ également. Bien entendu,
l'utilisateur ne doit pas modifier les valeurs de ces compteurs |iRow| et~|jCol|
qui sont utilisés en interne par \pkg{nicematrix}.

Dans le |\CodeBefore| (cf. p. \pageref{code-before}) et dans le |\CodeAfter|
(cf. p. \pageref{code-after}), |iRow| représente le nombre total de rangées
(hors éventuelles rangées extérieures : cf. p.~\pageref{exterior}) et |jCol| le
nombre total de colonnes (hors potentielles colonnes extérieures).

\medskip
\begin{Code}[width=10.6cm]
$\begin{pNiceMatrix}%
    [first-row,
     first-col,
     code-for-first-row = \mathbf{\emph{\alph{jCol}}} ,
     code-for-first-col = \mathbf{\emph{\arabic{iRow}}} ]
&   &    &    &   \\
& 1 & 2  & 3  & 4 \\
& 5 & 6  & 7  & 8 \\
& 9 & 10 & 11 & 12
\end{pNiceMatrix}$
\end{Code}
$\begin{pNiceMatrix}[first-row,
                   first-col,
                   code-for-first-row = \mathbf{\alph{jCol}} ,
                   code-for-first-col = \mathbf{\arabic{iRow}} ,
                   no-cell-nodes]
&   &    &    &   \\
& 1 & 2  & 3  & 4 \\
& 5 & 6  & 7  & 8 \\
& 9 & 10 & 11 & 12
\end{pNiceMatrix}$

\medskip
Si des compteurs LaTeX nommés |iRow| ou |jCol| sont créés dans le document par
d'autres extensions que \pkg{nicematrix} (ou tout simplement par l'utilisateur
final), ces compteurs sont masqués dans les environnements de \pkg{nicematrix}.


\medskip
\indexcommand{AutoNiceMatrix}
\indexcommand{pAutoNiceMatrix}
\indexcommand{bAutoNiceMatrix}
\indexcommand{vAutoNiceMatrix}
\indexcommand{VAutoNiceMatrix}
\indexcommand{BAutoNiceMatrix}
L'extension \pkg{nicematrix} propose aussi des commandes pour composer
automatiquement des matrices à partir d'un motif général. Ces commandes sont
nommées \DefinitionCommande{AutoNiceMatrix},
\DefinitionCommande{pAutoNiceMatrix}, \DefinitionCommande{bAutoNiceMatrix},
\DefinitionCommande{vAutoNiceMatrix}, \DefinitionCommande{VAutoNiceMatrix} et
\DefinitionCommande{BAutoNiceMatrix}. 

Chacune de ces commandes prend deux arguments obligatoires : le premier est la
taille de la matrice, sous la forme $n$-$p$, où $n$ est le nombre de rangées et
$p$ est le nombre de colonnes et le deuxième est le motif (c'est-à-dire
simplement des tokens qui seront insérés dans chaque case de la matrice).


\medskip
\begin{Code}
$C = \emph{\pAutoNiceMatrix}{3-3}{C_{\arabic{iRow},\arabic{jCol}}}$
\end{Code}

\[C = \pAutoNiceMatrix{3-3}{C_{\arabic{iRow},\arabic{jCol}}}\]

Il existe aussi \DefinitionCommande{AutoNiceArrayWithDelims} similaire à
|{NiceArrayWithDelims}|. 

\subsection{L'option light-syntax}

\label{light-syntax}
\index{light-syntax}

L'option \Definition{light-syntax} (inspirée de l'extension \pkg{spalign})
permet d'alléger la saisie des matrices, ainsi que leur lisibilité dans le
source TeX. Lorsque cette option est activée, on doit utiliser le point-virgule
comme marqueur de fin de rangée et séparer les colonnes par des espaces ou des
tabulations. On remarquera toutefois que, comme souvent dans le monde TeX, les
espaces après les séquences de contrôle ne sont pas comptées et que les éléments
entre accolades sont considérés comme un tout.


\medskip
\begin{scope}
\begin{Code}[width=10cm]
$\begin{bNiceMatrix}[\emph{light-syntax},first-row,first-col]
{} a             b                 ;
a  2\cos a       {\cos a + \cos b} ;
b \cos a+\cos b  { 2 \cos b }
\end{bNiceMatrix}$
\end{Code}
\end{scope}
%
$\begin{bNiceMatrix}[light-syntax,first-row,first-col,no-cell-nodes]
{} a             b                 ;
a  2\cos a       {\cos a + \cos b} ;
b \cos a+\cos b  { 2 \cos b }
\end{bNiceMatrix}$

\medskip
\index{end-of-row (à utiliser avec light-syntax)}
On peut changer le caractère utilisé pour indiquer les fins de rangées avec
l'option |end-of-row|. Comme dit précédemment, la valeur initiale de ce
paramètre est un point-virgule.

\medskip
Lorsque l'option |light-syntax| est utilisée, il n'est pas possible de mettre
d'éléments en verbatim (avec par exemple la commande \texttt{\textbackslash verb}) 
dans les cases du tableau.\footnote{La raison en est que lorsque l'option |light-syntax|
  est utilisée, le contenu complet de l'environnement est chargé comme un
  argument de commande TeX. L'environnement ne se comporte plus comme un «vrai»
  environnement de LaTeX qui se contente d'insérer des commandes avant et
  après.}


\medskip
\index{light-syntax-expanded} 
La clé \Definition{light-syntax-expanded} a le même comportement que la clé
|light-syntax| mais avec cette différence que le corps de l'environnement est
complètement développé (au sens de TeX\footnote{Plus précisément, il s'agit
  d'une expansion de type |e| de L3.}) avant découpe en rangées (mais après
l'extraction de l'éventuel |\CodeAfter|).


\subsection{Couleur des délimiteurs}

\index{delimiters!---/color pour un environnement}
\index{color!pour les délimiteurs de matrices}
\index{Couleur!des délimiteurs de matrices}

Pour les environnements avec délimiteurs (|{pNiceArray}|, |{pNiceMatrix}|,
etc.), il est possible de changer la couleur des délimiteurs avec la clé
\Definition{delimiters/color}.

\medskip
\begin{Code}[width=12cm]
$\begin{bNiceMatrix}[\emph{delimiters/color=red}]
1 & 2 \\
3 & 4
\end{bNiceMatrix}$
\end{Code}
$\begin{bNiceMatrix}[delimiters/color=red]
1 & 2 \\
3 & 4
\end{bNiceMatrix}$

\medskip
Cette couleur s'applique aussi aux délimiteurs tracés par |\SubMatrix|
(cf.~p.~\pageref{sub-matrix}) et aux délimiteurs spécifiés directement dans le
préambule des environnements à préambule (cf.~p.~\pageref{delimiters-in-preamble}).


\subsection{L'environnement \{NiceArrayWithDelims\}}

\label{NiceArrayWithDelims}
\index{NiceArrayWithDelims@\texttt{\{NiceArrayWithDelims\}}}

En fait, l'environnement |{pNiceArray}| et ses variantes sont fondés sur un
environnement plus général, appelé \Definition{\{NiceArrayWithDelims\}}. Les
deux premiers arguments obligatoires de cet environnement sont les délimiteurs
gauche et droit qui seront utilisés dans la construction de la matrice. Il est
possible d'utiliser |{NiceArrayWithDelims}| si on a besoin de délimiteurs
atypiques ou asymétriques.

\medskip
\begin{Code}[width=11cm]
$\begin{\emph{NiceArrayWithDelims}}
   {\downarrow}{\uparrow}{ccc}[margin]
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{\emph{NiceArrayWithDelims}}$
\end{Code}
%
$\begin{NiceArrayWithDelims}
   {\downarrow}{\uparrow}{ccc}[margin,no-cell-nodes]
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{NiceArrayWithDelims}$


\subsection{La commande \textbackslash OnlyMainNiceMatrix}

\indexcommand{OnlyMainNiceMatrix}

La commande \DefinitionCommande{OnlyMainNiceMatrix} n'exécute son argument que
si on se trouve dans le tableau principal, c'est-à-dire que l'on est ni dans les
rangées extérieures, ni dans les colonnes extérieures. Si elle est utilisée hors
d'un environnement de \pkg{nicematrix}, elle est sans effet.

Pour un exemple d'utilisation, voir \url{tex.stackexchange.com/questions/488566} 



\section{Utilisation de TikZ avec nicematrix}

\label{name}
\label{PGF-nodes}
\index{tikza@TikZ (utilisation avec \pkg{nicematrix})}
\index{noeud@\textbf{Nœuds PGF/Tikz}|(}

\subsection{Les nœuds correspondant aux contenus des cases}

\index{no-cell-nodes}

L'extension \pkg{nicematrix} crée un nœud PGF-TikZ\footnote{On rappelle que TikZ
  est une sur-couche de PGF. L'extension \pkg{nicematrix} charge PGF et ne
  charge pas TikZ. On parle de «nœud PGF-TikZ» pour rappeler que, en fait, les
  nœuds créés par \pkg{nicematrix} avec PGF sont en fait aussi utilisables avec
  TikZ. L'utilisateur final préférera sans doute les utiliser avec TikZ qu'avec
  PGF.} pour chaque case non vide du tableau considéré. Ces nœuds sont utilisés,
entre autres, pour tracer les lignes en pointillés entre les cases du tableau.

\smallskip
\textbf{Attention} : Par défaut, aucun nœud n'est créé dans une case vide.

\smallskip
Néanmoins, on peut forcer la création d'un nœud avec la commande |\NotEmpty|.\footnote{Il faut toutefois remarquer qu'avec cette commande, la
  case est considérée comme non vide, ce qui a des conséquences sur le tracé des
lignes pointillées (cf.~p.~\pageref{Cdots}) et la détermination des «coins»
(cf. p.~\pageref{corners}).}

\medskip
Comme la création de ces nœuds requiert du temps et de la mémoire, il est
possible de la désactiver ponctuellement avec la clé \Definition{no-cell-nodes}
pour accélérer les compilations. Attention toutefois : ces nœuds sont utilisés
en interne par certaines fonctionnalités de \pkg{nicematrix}. On ne peut donc
utiliser |no-cell-nodes| que si on n'utilise pas ces fonctionnalités, parmi
lesquelles figurent la clé |corners| et les commandes de lignes pointillées
continues (|\Cdots|, etc.).

\medskip
Tous les nœuds du document doivent avoir des noms deux à deux distincts et le
nom de ces nœuds doit donc faire intervenir le numéro de l'environnement
courant. Les environnements créés par \pkg{nicematrix} sont en effet numérotés
par un compteur global interne.

\smallskip
Si l'environnement concerné a le numéro $n$, alors le nœud de la rangée~$i$ et
de la colonne~$j$ a pour nom |nm-|$n$|-|$i$|-|$j$.

\smallskip
\indexcommand{NiceMatrixLastEnv}
La commande \DefinitionCommande{NiceMatrixLastEnv} donne le numéro du dernier de
ces environnements (pour LaTeX, il s'agit d'une commande — complètement
développable — et non d'un compteur).

\smallskip
\index{name!clé pour un environnement}
Il est néanmoins recommandé de passer plutôt par la clé \Definition{name}\footnote{La
  valeur passée à la clé |name| est \emph{développée}, au sens de TeX.}.
Celle-ci permet de donner un nom à l'environnement. Une fois l'environnement
nommé, les nœuds sont accessibles à travers les noms «\textsl{nom}-$i$-$j$» où
\textsl{nom} est le nom donné au tableau et $i$ et $j$ les numéros de rangée et
de colonne de la case considérée. On peut les utiliser avec \textsc{pgf} mais
l'utilisateur final préférera sans doute utiliser TikZ (qui est une sur-couche
de \textsc{pgf}). Il faut néanmoins se souvenir que \pkg{nicematrix} ne charge
pas TikZ par défaut. Dans les exemples qui suivent, on suppose que TikZ a été
chargé par l'utilisateur.

\medskip
\begin{Code}[width=11cm]
$\begin{pNiceMatrix}[name = \emph{ma-matrice}]
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{pNiceMatrix}$
\tikz[remember picture,overlay]
     \draw \emph{(ma-matrice-2-2)} circle (2mm) ;
\end{Code}
$\begin{pNiceMatrix}[name=ma-matrice]
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{pNiceMatrix}$
\tikz[remember picture,overlay]
     \draw (ma-matrice-2-2) circle (2mm) ;

\medskip
Ne pas oublier les options |remember picture| et |overlay|.


\medskip
Dans le |\CodeAfter|, et si TikZ est chargé, les choses sont plus simples. On
peut (et on doit) désigner les nœuds sous la forme $i$-$j$ : il n'y a pas à
préciser l'environnement qui est évidemment l'environnement courant.


\medskip
\begin{Code}[width=11cm]
$\begin{pNiceMatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\CodeAfter
\tikz \draw \emph{(2-2)} circle (2mm) ;
\end{pNiceMatrix}$
\end{Code}
$\begin{pNiceMatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\CodeAfter
\tikz \draw (2-2) circle (2mm) ;
\end{pNiceMatrix}$

\medskip
Les nœuds de la dernière colonne (hors éventuelle «colonne extérieure» spécifiée
par |last-col|\footnote{Pour les colonnes extérieures, cf.
  partie~\ref{exterior}, p.~\pageref{exterior}.}) peuvent aussi être désignés
par $i$-|last|. De même, les nœuds de la dernière rangée peuvent être désignés
par |last|-$j$.


\medskip
Dans l'exemple suivant, nous avons surligné tous les nœuds de la matrice.

\[
\NiceMatrixOptions
  { 
    pgf-node-code = 
     { 
       \pgfsetfillcolor{red!15}%
       \pgfusepathqfill
     } 
  }
\begin{pNiceMatrix}
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a
\end{pNiceMatrix}\]

\bigskip
Puisque ces nœuds sont des nœuds PGF, on ne sera pas étonné d'appendre qu'ils
sont tracés en utilisant un style PGF spécifique. Ce style est nommé
|nicematrix/cell-node| et sa définition dans le fichier source |nicematrix.sty|
est la suivante :

\begin{Code}
\pgfset 
  { 
    \emph{nicematrix / cell-node} /.style = 
     {
       inner sep = 0 pt ,
       minimum width = 0 pt
     }
  }
\end{Code}

L'utilisateur peut modifier ce style en changeant les valeurs des clés |text/rotate|,
|inner xsep|, |inner ysep|, |inner sep|, |outer xsep|, |outer ysep|, |outer sep|,
|minimum width|, |minimum height| et |minimum size|.

\medskip
Pour un exemple d'utilisation, voir la partie \ref{ex:triangular},
p.~\pageref{ex:triangular}. 

\subsubsection{La clé pgf-node-code}

\index{pgf-node-code} 
\textbf{Pour les utilisateurs expérimentés}, \pkg{nicematrix} fournit la clé
\Definition{pgf-node-code} qui correspond à du code PGF qui sera exécuté à la
création, par PGF, des nœuds correspondants aux cases du tableau. Plus
précisément, la valeur fournie à la clé |pgf-node-code| sera passée en cinquième
argument de la commande |\pgfnode|. Cette valeur doit contenir au moins une
instruction comme |\pgfusepath|, |\pgfusepathqstroke|, |\pgfusepathqfill|, etc.

\subsubsection{Les colonnes V de varwidth}

\label{node-V}
\index{V (les colonnes V de \pkg{varwidth})}
\index{varwidth@\pkg{varwidth} (extension)}

Quand l'extension \pkg{varwidth} est chargée, les colonnes de type |V| définies
par \pkg{varwidth} sont prises en charge par \pkg{nicematrix}. Il peut être
intéressant de préciser que, pour une case située dans une colonne de type
|V|, le nœud PGF-TikZ créé par \pkg{nicematrix} pour le contenu de cette case
a une largeur ajustée au contenu de cette case. Cela est en contraste avec le
cas des colonnes de type |p|, |m| ou |b| dans lesquelles les nœuds ont toujours
une largeur égale à la largeur de la colonne. Dans l'exemple suivant, la
commande |\lipsum| est fournie par l'extension éponyme.

\begin{Code}
\begin{NiceTabular}{V{10cm}}
\bfseries \large 
Titre \\
\lipsum[1][1-4]
\CodeAfter 
  \tikz \draw [rounded corners] (1-1) -| (last-|2) -- (last-|1) |- (1-1) ; 
\end{NiceTabular}
\end{Code}

\begin{center}
\begin{NiceTabular}{V{10cm}}
\bfseries \large 
Titre \\
\lipsum[1][1-4]
\CodeAfter 
  \tikz \draw [rounded corners] (1-1) -| (last-|2) -- (last-|1) |- (1-1) ; 
\end{NiceTabular}
\end{center}

On a utilisé les nœuds indiquant la position des filets, qui sont présentés un
peu plus loin, p.~\pageref{nodes-i}.



\subsection{Les «nœuds moyens» et les «nœuds larges»}

\index{create-medium-nodes}
\index{create-large-nodes}
\index{create-extra-nodes}

En fait, l'extension \pkg{nicematrix} peut créer deux séries de nœuds
supplémentaires (\emph{extra nodes} en anglais) : les «nœuds moyens»
(\emph{medium nodes} en anglais) et les «nœuds larges» (\emph{large nodes} en
anglais). Les premiers sont créés avec l'option \Definition{create-medium-nodes}
et les seconds avec l'option \Definition{create-large-nodes}.\footnote{Il existe
  aussi l'option |create-extra-nodes| qui est un alias pour la conjonction de
  |create-medium-nodes| et |create-large-nodes|.}

\medskip
Ces nœuds ne sont pas utilisés par défaut par \pkg{nicematrix}.

\medskip
Les noms des «nœuds moyens» s'obtiennent en ajoutant le suffixe «|-medium|» au
nom des nœuds normaux. Dans l'exemple suivant, on a surligné tous les «nœuds
moyens». Nous considérons que cet exemple se suffit à lui-même comme définition
de ces nœuds.
\[\begin{pNiceMatrix}[create-medium-nodes]
\CodeBefore [create-cell-nodes]
   \begin{tikzpicture}
      [every node/.style = {fill = red!15, inner sep = 0 pt},
       name suffix = -medium]
   \node [fit = (1-1)] {} ;
   \node [fit = (1-2)] {} ;
   \node [fit = (1-3)] {} ;
   \node [fit = (2-1)] {} ;
   \node [fit = (2-2)] {} ;
   \node [fit = (2-3)] {} ;
   \node [fit = (3-1)] {} ;
   \node [fit = (3-2)] {} ;
   \node [fit = (3-3)] {} ;
\end{tikzpicture}
\Body
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a
\end{pNiceMatrix}\]


\medskip
Les noms des «nœuds larges» s'obtiennent en ajoutant le suffixe «|-large|» au
nom des nœuds normaux. Dans l'exemple suivant, on a surligné tous les «nœuds
larges». Nous considérons que cet exemple se suffit à lui-même comme définition
de ces nœuds.\footnote{Il n'y a pas de «nœuds larges» créés dans les rangées et
  colonnes extérieures (pour ces rangées et colonnes, voir
  p.~\pageref{exterior}).}

\[\begin{pNiceMatrix}[create-large-nodes]
\CodeBefore [create-cell-nodes]
   \begin{tikzpicture}
      [every node/.style = { inner sep = 0 pt} ,
       name suffix = -large]
   \node [fit = (1-1),fill = red!15] {} ;
   \node [fit = (1-3),fill = red!15] {} ;
   \node [fit = (2-2),fill = red!15] {} ;
   \node [fit = (3-1),fill = red!15] {} ;
   \node [fit = (3-3),fill = red!15] {} ;
   \node [fit = (1-2),fill = blue!15] {} ;
   \node [fit = (2-1),fill = blue!15] {} ;
   \node [fit = (2-3),fill = blue!15] {} ;
   \node [fit = (3-2),fill = blue!15] {} ;
   \end{tikzpicture}
\Body
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a
\end{pNiceMatrix}\]


\medskip
\index{left-margin}
\index{right-margin}
Les «nœuds larges» de la première colonne et de la dernière colonne peuvent
apparaître trop petits pour certains usages. C'est pourquoi il est possible
d'utiliser les options \Definition{left-margin} et \Definition{right-margin}
pour ajouter de l'espace des deux côtés du tableau et aussi de l'espace dans les
«nœuds larges» de la première colonne et de la dernière colonne. Dans l'exemple
suivant, nous avons utilisé les options |left-margin| et
|right-margin|.\footnote{Les options |left-margin| et |right-margin| prennent
  des dimensions comme valeurs mais, si aucune valeur n'est donnée, c'est la
  valeur par défaut qui est utilisée et elle est égale à |\arraycolsep| (valeur
  initiale : 5~pt). Il existe aussi une option |margin| pour fixer à la fois
  |left-margin| et |right-margin|.} 
\[\begin{pNiceMatrix}[create-large-nodes,left-margin,right-margin]
\CodeBefore [create-cell-nodes]
    \begin{tikzpicture}
       [every node/.style = {inner sep = 0 pt},
        name suffix = -large]
    \node [fit = (1-1),fill = red!15] {} ;
    \node [fit = (1-3),fill = red!15] {} ;
    \node [fit = (2-2),fill = red!15] {} ;
    \node [fit = (3-1),fill = red!15] {} ;
    \node [fit = (3-3),fill = red!15] {} ;
    \node [fit = (1-2),fill = blue!15] {} ;
    \node [fit = (2-1),fill = blue!15] {} ;
    \node [fit = (2-3),fill = blue!15] {} ;
    \node [fit = (3-2),fill = blue!15] {} ;
    \end{tikzpicture}
\Body
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a
\end{pNiceMatrix}\]

\medskip
\index{extra-left-margin}
\index{extra-right-margin}
Il est aussi possible d'ajouter de l'espace sur les côtés du tableau avec les
clés \Definition{extra-left-margin} et \Definition{extra-right-margin}. Ces
marges ne sont pas incorporées dans les «nœuds larges». Dans l'exemple suivant,
nous avons utilisé |extra-left-margin| et |extra-right-margin| avec la valeur $3$~pt.
\[\begin{pNiceMatrix}%
   [create-large-nodes,left-margin,right-margin,extra-right-margin=3pt,
    extra-left-margin=3pt]
\CodeBefore [create-cell-nodes]
    \begin{tikzpicture}
       [every node/.style = {inner sep = 0 pt},
        name suffix = -large]
    \node [fit = (1-1),fill = red!15] {} ;
    \node [fit = (1-3),fill = red!15] {} ;
    \node [fit = (2-2),fill = red!15] {} ;
    \node [fit = (3-1),fill = red!15] {} ;
    \node [fit = (3-3),fill = red!15] {} ;
    \node [fit = (1-2),fill = blue!15] {} ;
    \node [fit = (2-1),fill = blue!15] {} ;
    \node [fit = (2-3),fill = blue!15] {} ;
    \node [fit = (3-2),fill = blue!15] {} ;
\end{tikzpicture}
\Body
a & a + b & a + b + c \\
a & a     & a + b  \\
a & a     & a
\end{pNiceMatrix}\]


\medskip
\textbf{Attention} : Ces nœuds sont reconstruits à partir des contenus des cases
et ne correspondent donc pas nécessairement aux cases délimitées par des filets.

\medskip
\begin{minipage}[c]{7.5cm}
Voici un tableau qui a été composé de la manière suivante :

\medskip
\begin{Code}
\large
\begin{NiceTabular}{wl{2cm}ll}[hvlines]
fraise & amande & abricot \\
prune & pêche & poire  \\[1ex]
noix & noisette & brugnon
\end{NiceTabular}
\end{Code}
\end{minipage}
\hspace{1cm}
\begin{scope}
\large
\begin{NiceTabular}[c]{wl{2cm}ll}[hvlines]
fraise & amande & abricot \\
prune & pêche & poire  \\[1ex]
noix & noisette & brugnon
\end{NiceTabular}
\end{scope}

\vspace{1cm}
\begin{minipage}[c]{7cm}
Ci-contre, on a colorié toutes les cases de ce tableau avec
|\chessboardcolors| (cf.~p.~\pageref{chessboardcolors}).
\end{minipage}
\hspace{1.5cm}
\begin{scope}
\large
\begin{NiceTabular}[c]{wl{2cm}ll}[hvlines,code-before = \chessboardcolors{red!15}{blue!15}]
fraise & amande & abricot \\
prune & pêche & poire  \\[1ex]
noix & noisette & brugnon
\end{NiceTabular}
\end{scope}


\vspace{1cm}
\begin{minipage}[c]{7cm}
Voici maintenant tous les «nœuds larges» de ce tableau (sans utilisation de
|margin| ni de |extra-margin|).
\end{minipage}
\hspace{1.5cm}
\begin{scope}
\large
\begin{NiceTabular}[c]{w{l}{2cm}ll}[hvlines,create-large-nodes]
\CodeBefore [create-cell-nodes]
    \begin{tikzpicture}
       [every node/.style = {inner sep = 0 pt},
        name suffix = -large]
    \node [fit = (1-1),fill = red!15] {} ;
    \node [fit = (1-3),fill = red!15] {} ;
    \node [fit = (2-2),fill = red!15] {} ;
    \node [fit = (3-1),fill = red!15] {} ;
    \node [fit = (3-3),fill = red!15] {} ;
    \node [fit = (1-2),fill = blue!15] {} ;
    \node [fit = (2-1),fill = blue!15] {} ;
    \node [fit = (2-3),fill = blue!15] {} ;
    \node [fit = (3-2),fill = blue!15] {} ;
    \end{tikzpicture}
\Body
fraise & amande & abricot \\
prune & pêche & poire  \\[1ex]
noix & noisette & brugnon
\end{NiceTabular}
\end{scope}


\vspace{1cm}
Les nœuds que l'on vient de décrire ne sont pas accessibles par défaut dans le
|\CodeBefore| (décrit p.~\pageref{code-before}). 

\nobreak
\index{create-cell-nodes (clé de \texttt{\textbackslash CodeBefore})}
On peut rendre ces nœuds accessibles dans le |\CodeBefore| en utilisant la clé
\Definition{create-cell-nodes} du mot-clé |\CodeBefore| (dans ce cas-là, les
nœuds sont créés une première fois avant la construction du tableau en utilisant
des informations écrites dans le fichier |aux| puis recréés lors de la composition
du tableau proprement dit ; ce mécanisme n'est pas actif par défaut pour des
questions d'efficacité).

\bigskip
Voici un exemple d'utilisation de ces nœuds dans le |\CodeAfter|.

\begin{center}
\begin{Code}
\begin{NiceArray}{c@{\;}c@{\;}c@{\;}c@{\;}c}[create-medium-nodes]
    u_1 &-& u_0 &=& r     \\
    u_2 &-& u_1 &=& r     \\
    u_3 &-& u_2 &=& r     \\
    u_4 &-& u_3 &=& r     \\
    \phantom{u_5} & &  \phantom{u_4}    &\smash{\vdots} &       \\
    u_n &-& u_{n-1} &=& r \\[3pt]
    \hline
    u_n &-& u_0 &=& nr \\
\CodeAfter
    \tikz[very thick, red, opacity=0.4, name suffix = -medium]
    \draw (1-1.north west) -- (2-3.south east)
    (2-1.north west) -- (3-3.south east)
    (3-1.north west) -- (4-3.south east)
    (4-1.north west) -- (5-3.south east)
    (5-1.north west) -- (6-3.south east) ;
\end{NiceArray}
\end{Code}
\end{center}
% 
\[\begin{NiceArray}{c@{\;}c@{\;}c@{\;}c@{\;}c}[create-medium-nodes]
    u_1 &-& u_0 &=& r     \\
    u_2 &-& u_1 &=& r     \\
    u_3 &-& u_2 &=& r     \\
    u_4 &-& u_3 &=& r     \\
    \phantom{u_5} & &  \phantom{u_4}    &\smash{\vdots} &       \\
    u_n &-& u_{n-1} &=& r \\[3pt]
    \hline
    u_n &-& u_0 &=& nr \\
    \CodeAfter
    \tikz[very thick, red, opacity=0.4,name suffix = -medium]
    \draw (1-1.north west) -- (2-3.south east)
    (2-1.north west) --(3-3.south east)
    (3-1.north west) -- (4-3.south east)
    (4-1.north west) -- (5-3.south east)
    (5-1.north west) -- (6-3.south east) ;
\end{NiceArray}\]


\subsection{Les nœuds indiquant la position des filets}

\label{nodes-i}

L'extension \pkg{nicematrix} crée un nœud PGF-TikZ nommé simplement $i$ (précédé
du préfixe habituel) à l'intersection du filet horizontal de numéro $i$ et du
filet vertical de numéro~$i$ (ou plutôt la position potentielle de ces filets
car ils ne sont peut-être pas tracés). Le dernier nœud a aussi un alias nommé
simplement |last|. 

\smallskip
Il existe aussi des nœuds nommés $i$|.1|, $i$|.2|, $i$|.25|, $i$|.3|, $i$|.4|,
$i$|.5|, $i$|.6|, $i$|.7|, $i$|.75|, $i$|.8| et $i$|.9| intermédiaires entre le
nœud~$i$ et le nœud~$i+1$.

\smallskip
Ces nœuds sont accessibles dans le
|\CodeAfter| mais aussi dans le |\CodeBefore|.

\begin{center}
\begin{NiceTabular}{ccc}[hvlines,rules={width=1pt,color=gray},no-cell-nodes]
       & tulipe & lys \\
arum   &        & violette mauve \\
muguet & dahlia
\CodeAfter
\tiny
\begin{tikzpicture}
\foreach \i in {1,1.5,2,2.5,3,3.5,4}
  {
    \fill [red] (\i) circle (0.5mm) ;
    \node [red,above right] at (\i) {\i} ;
  }
\end{tikzpicture}
\end{NiceTabular}
\end{center}


\medskip
Si on utilise TikZ (on rappelle que \pkg{nicematrix} ne charge pas TikZ mais
uniquement \textsc{pgf} qui est une sous-couche de TikZ), on peut donc accéder
(dans le |\CodeAfter| mais aussi dans le |\CodeBefore|) à l'intersection du filet
horizontal~$i$ et du filet vertical~$j$ avec la syntaxe |(|$i$\verb+-|+$j$|)|.


\medskip
\begin{Code}
\begin{NiceMatrix}
\CodeBefore
  \emph{\tikz \draw [fill=red!15] (7-|4) |- (8-|5) |- (9-|6) |- cycle ;}
\Body
1 \\
1 & 1 \\
1 & 2 &  1 \\
1 & 3 &  3 &  1 \\
1 & 4 &  6 &  4 &  1 \\
1 & 5 & 10 & 10 &  5 &  1 \\
1 & 6 & 15 & 20 & 15 &  6 &  1 \\
1 & 7 & 21 & 35 & 35 & 21 &  7 & 1 \\
1 & 8 & 28 & 56 & 70 & 56 & 28 & 8 & 1
\end{NiceMatrix}
\end{Code}
%
\[\begin{NiceMatrix}[no-cell-nodes]
\CodeBefore
  \tikz \draw [fill=red!15] (7-|4) |- (8-|5) |- (9-|6) |- cycle ;
\Body
1 \\
1 & 1 \\
1 & 2 &  1 \\
1 & 3 &  3 &  1 \\
1 & 4 &  6 &  4 &  1 \\
1 & 5 & 10 & 10 &  5 &  1 \\
1 & 6 & 15 & 20 & 15 &  6 &  1 \\
1 & 7 & 21 & 35 & 35 & 21 &  7 & 1 \\
1 & 8 & 28 & 56 & 70 & 56 & 28 & 8 & 1
\end{NiceMatrix}\]

\medskip
Les nœuds «décimaux» (comme $i$|.4|) peuvent être utilisés par exemple pour
barrer une rangée (si on a chargé TikZ).

\smallskip
\begin{Code}[width=11cm]
$\begin{pNiceArray}{ccc|c}
2 & 1 & 3 & 0 \\
3 & 3 & 1 & 0 \\
3 & 3 & 1 & 0
\CodeAfter
  \tikz \draw [red] (\emph{3.4}-|1) -- (\emph{3.4}-|last) ;
\end{pNiceArray}$
\end{Code}
$\begin{pNiceArray}{ccc|c}[no-cell-nodes]
2 & 1 & 3 & 0 \\
3 & 3 & 1 & 0 \\
3 & 3 & 1 & 0
\CodeAfter
  \tikz \draw [red] (3.4-|1) -- (3.4-|last) ;
\end{pNiceArray}$


\subsection{Les nœuds correspondant aux commandes \textbackslash SubMatrix}

\label{node-sub-matrix}

La commande |\SubMatrix| disponible dans le |\CodeAfter| a été présentée
p.~\pageref{sub-matrix}.

\index{SubMatrix@\texttt{\textbackslash SubMatrix} (commande du 
\texttt{\textbackslash CodeAfter}\newline et du 
\texttt{\textbackslash CodeBefore})}
\index{name!clé de \texttt{\textbackslash SubMatrix}}


\smallskip
Si une commande |\SubMatrix| est utilisée avec la clé |name| sous la forme
|name=|\textsl{\ttfamily MonNom}, trois nœuds PGF-TikZ sont créés avec les noms
\textsl{\ttfamily MonNom}|-left|, \textsl{\ttfamily MonNom} et \textsl{\ttfamily
  MonNom}|-right|.

\smallskip
Les nœuds \textsl{\ttfamily MonNom}|-left| et \textsl{\ttfamily MonNom}|-right| correspondent aux
délimiteurs gauche et droit et le nœud \textsl{\ttfamily MonNom} correspond à la
sous-matrice elle-même.

\medskip
Dans l'exemple suivant, on a surligné ces trois nœuds (la sous-matrice elle-même
a été créée avec |\SubMatrix\{{2-2}{3-3}\}|).
%
\[\begin{pNiceMatrix}
121 & 23 & 345 & 345\\
45 & 346 & 863 & 444\\
3462 & 38458 & 34 & 294 \\
34 & 7 & 78 & 309 \\
\CodeAfter
\SubMatrix\{{2-2}{3-3}\}[name=A]
\begin{tikzpicture}
   [every node/.style = {blend mode = multiply,
                         inner sep = 0 pt}]
\node [fit = (A),fill = red!15] {} ;
\node [fit = (A-left),fill = blue!15] {} ;
\node [fit = (A-right),fill = blue!15] {} ;
\end{tikzpicture}
\end{pNiceMatrix}\]

\index{noeud@\textbf{Nœuds PGF/Tikz}|)}


\section{API pour les développeurs}

\indexcommand{g\_nicematrix\_code\_before\_tl}
\indexcommand{g\_nicematrix\_code\_after\_tl}

L'extension \pkg{nicematrix} fournit deux variables internes mais publiques\footnote{Conformément aux conventions de LaTeX3,
  toute variable dont le nom commence par |\g_nicematrix| ou |\l_nicematrix| est
  publique alors que toute variable dont le nom débute par |\g__nicematrix| ou
  par |\l__nicematrix| est privée.} :
\begin{itemize}[beginpenalty=10000]
\item |\g_nicematrix_code_before_tl| ;
\item |\g_nicematrix_code_after_tl|.
\end{itemize}

\medskip
Ces variables constituent le code du «|code-before|» (que l'on rentre souvent
avec la syntaxte utilisant |\CodeBefore| et |\Body| en début d'environnement) et
du «|code-after|» (que l'on rentre souvent en fin d'environnement après le
mot-clé |\CodeAfter|). Le développeur peut donc les utiliser pour y ajouter du
code à partir d'une case du tableau (l'affectation devra être globale, ce qui
permettra de sortir de la case, qui est un groupe au sens de TeX).

\medskip
On remarquera que l'utilisation de |\g_nicematrix_code_before_tl| nécessite une
compilation supplémentaire (car les instructions sont écrites dans le fichier
|aux| pour être utilisées à la compilation suivante).

\medskip
\emph{Exemple} : On souhaite écrire une commande |\crossbox| qui barre en croix
la case courante. Cette commande prendra en argument optionnel une liste de
couples \textsl{clé}-\textsl{valeur} qui sera passée à TikZ avant que la croix
ne soit tracée.


On peut alors programmer cette commande |\crossbox| de la manière suivante, qui
utilise explicitement la variable publique |\g_nicematrix_code_before_tl|.


\index{crossbox@\texttt{\textbackslash crossbox} (définie dans un exemple)|textit}



\begin{Code}
\ExplSyntaxOn
\cs_new_protected:Nn \__pantigny_crossbox:nnn
  {
    \tikz \draw [ #3 ]
          ( #1 -| \int_eval:n { #2 + 1 } ) -- ( \int_eval:n { #1 + 1 } -| #2 )
          ( #1 -| #2 ) -- ( \int_eval:n { #1 + 1 } -| \int_eval:n { #2 + 1 } ) ;
  }

\NewDocumentCommand \crossbox { ! O { } }
  {
    \tl_gput_right:Nx \emph{\g_nicematrix_code_before_tl}
      {
        \__pantigny_crossbox:nnn
          { \arabic { iRow } }
          { \arabic { jCol } }
          { \exp_not:n { #1 } }
      }
    \ignorespaces 
  }
\ExplSyntaxOff
\end{Code}



\ExplSyntaxOn
\cs_new_protected:Nn \__pantigny_crossbox:nnn
  {
    \tikz \draw [ #3 ]
          ( #1 -| \int_eval:n { #2 + 1 } ) -- ( \int_eval:n { #1 + 1 } -| #2 )
          ( #1 -| #2 ) -- ( \int_eval:n { #1 + 1 } -| \int_eval:n { #2 + 1 } ) ;
  }


\NewDocumentCommand \crossbox { ! O { } }
  {
    \tl_gput_right:Nx \g_nicematrix_code_before_tl
      {
        \__pantigny_crossbox:nnn
          { \arabic { iRow } }
          { \arabic { jCol } }
          { \exp_not:n { #1 } }
      }
    \ignorespaces 
  }
\ExplSyntaxOff

\medskip
On a utilisé les compteurs LaTeX |iRow| et |jCol| fournis par \pkg{nicematrix} (cf.~p.~\pageref{iRow}).

\medskip
Voici un exemple d'utilisation :

\medskip
\begin{Code}[width=9cm]
\begin{NiceTabular}{ccc}[hvlines]
\CodeBefore
  \arraycolor{gray!10}
\Body
merlan & requin & cabillaud \\
baleine & \emph{\crossbox[red]} & morue \\
mante & raie & poule
\end{NiceTabular}
\end{Code}
\begin{NiceTabular}{ccc}[hvlines,no-cell-nodes]
\CodeBefore
  \arraycolor{gray!10}
\Body
merlan & requin & cabillaud \\
baleine & \crossbox[red] & morue \\
mante & raie & poule
\end{NiceTabular}




\section{Remarques techniques}

Première remarque : l'extension \pkg{nicematrix} doit être chargée après
l'extension \pkg{underscore}. Si elle est chargée avant, une erreur sera levée.

\subsection{Lignes diagonales}

\label{parallelization}
\index{parallelize-diags}
\index{Ddots@\texttt{\textbackslash Ddots}}
\index{Iddots@\texttt{\textbackslash Iddots}}

Par défaut, toutes les lignes diagonales\footnote{On parle des lignes créées par
  |\Ddots| et non des lignes créées par une commande |\line| dans le
  |\CodeAfter|.} d'un même tableau sont «parallélisées». Cela signifie que la
première diagonale est tracée et que, ensuite, les autres lignes sont tracées
parallèlement à la première (par rotation autour de l'extrémité la plus à gauche
de la ligne). C'est pourquoi la position des instructions |\Ddots| dans un
tableau peut avoir un effet marqué sur le résultat final.

\medskip
Dans les exemples suivants, la première instruction |\Ddots| est marquée en couleur :

\medskip
\begin{scope}
\begin{minipage}{9.5cm}
Exemple avec parallélisation (comportement par défaut):
\begin{Code}
$A = \begin{pNiceMatrix}
1      & \Cdots &        & 1      \\
a+b    & \emph{\Ddots} &        & \Vdots \\
\Vdots & \Ddots &        &        \\
a+b    & \Cdots & a+b    & 1
\end{pNiceMatrix}$
\end{Code}
\end{minipage}
$A = \begin{pNiceMatrix}
1      & \Cdots &     & 1      \\
a+b    & \Ddots &     & \Vdots \\
\Vdots & \Ddots &     &        \\
a+b    & \Cdots & a+b & 1
\end{pNiceMatrix}$

\medskip
\NiceMatrixOptions{parallelize-diags=true}%
\begin{minipage}{9.5cm}
\begin{Code}
$A = \begin{pNiceMatrix}
1      & \Cdots &        & 1      \\
a+b    &        &        & \Vdots \\
\Vdots & \emph{\Ddots} & \Ddots &        \\
a+b    & \Cdots & a+b    & 1
\end{pNiceMatrix}$
\end{Code}
\end{minipage}
$A = \begin{pNiceMatrix}
1      & \Cdots &        & 1      \\
a+b    &        &        & \Vdots \\
\Vdots & \Ddots & \Ddots &        \\
a+b    & \Cdots & a+b    & 1
\end{pNiceMatrix}$

\medskip
Il est possible de désactiver la parallélisation avec l'option
\Definition{parallelize-diags} mise à |false|: 

\nobreak
\medskip
\NiceMatrixOptions{parallelize-diags=false}%
\begin{minipage}{9.5cm}
Le même exemple sans parallélisation :
\end{minipage}
$A = \begin{pNiceMatrix}
1      & \Cdots  &     & 1      \\
a+b    & \Ddots  &     & \Vdots \\
\Vdots & \Ddots  &     &        \\
a+b    & \Cdots  & a+b & 1
\end{pNiceMatrix}$

\end{scope}

\medskip
\index{draw-first (clé de \texttt{\textbackslash Ddots} et
  \texttt{\textbackslash Iddots})}
On peut choisir l'instruction |\Ddots| qui sera tracée en premier (et qui
servira pour tracer les suivantes quand la parallélisation est activée) avec la
clé \Definition{draw-first} : |\Ddots[draw-first]|\rlap{.}



\subsection{Les cases «vides»}

\label{empty-cells}

L'extension \pkg{nicematrix} utilise en plusieurs occassions le concept de «case
vide». Par exemple, une instruction comme |\Ldots|, |\Cdots|, etc. essaye de
déterminer la première case non vide de part et d'autre de la case considérée.
De même, quand la clé |corners| (cf.~p.~\pageref{corners}) est utilisée, les
coins qui sont déterminés sont composés de cases vides. 

La définition précise de «case vide» est la suivante.

\begin{itemize}[beginpenalty=10000]
\item Une case implicite est vide. Par exemple, dans la matrice suivante

\begin{Verbatim}
\begin{pmatrix}
a & b \\
c
\end{pmatrix}
\end{Verbatim}

la dernière case (deuxième rangée et deuxième colonne) est vide.

\medskip
\item Pour les colonnes de type |p|, |m|, |b|, |V|\footnote{Les colonnes de type
    |V| sont fournies par l'extension \pkg{varwidth}, qui doit être chargée :
    cf.~p.~\pageref{varwidth}} ou |X|\footnote{Pour les colonnes |X|, voir
    p.~\pageref{colonne-X}}, la case est vide si (et seulement si) son contenu
  dans le codage TeX est vide (il n'y a que des espaces entre les deux
  esperluettes |&|).

\medskip
\item Pour les colonnes de type |c|, |l|, |r|, |w{...}{...}| ou |W{...}{...}|,
la case est vide si (et seulement si) son rendu TeX est de largeur nulle.

\medskip
\item Une case qui contient la commande |\NotEmpty| est non vide (et un nœud
PGF-TikZ est créé pour cette case).

\medskip
\item Une case avec seulement une commande |\Hspace| (ou |\Hspace*|) est vide.
Cette commande |\Hspace| est une commande définie par l'extension
\pkg{nicematrix} avec la même signification que |\hspace| excepté que la case où
cette commande est utilisée est considérée comme vide. Cette commande peut être
utilisée pour fixer la largeur des colonnes sans interférer avec le tracé des
lignes en pointillés par \pkg{nicematrix}.
\end{itemize}




\subsection{L'option exterior-arraycolsep}

\index{exterior-arraycolsep}

L'environnement |{array}| insère un espace horizontal égal à |\arraycolsep|
avant et après chaque colonne. En particulier, il y a un espace égal à
|\arraycolsep| avant et après le tableau. Cette caractéristique de
l'environnement |{array}| n'était probablement pas une bonne idée\footnote{Dans
  la documentation de l'\pkg{amsmath}, on peut lire : {\itshape The extra space
    of |\arraycolsep| that \pkg{array} adds on each side is a waste so we remove
    it [in |{matrix}|] (perhaps we should instead remove it from array in
    general, but that's a harder task).}}. L'environnement |{matrix}| et ses
variantes (|{pmatrix}|, |{vmatrix}|, etc.) de \pkg{amsmath} préfèrent supprimer
ces espaces avec des instructions explicites |\hskip -\arraycolsep|\footnote{Et
  non en insérant |@{}| de part et d'autre du préambule, ce qui fait que la
  longueur des |\hline| n'est pas modifiée et elle peut paraître trop longue,
  surtout avec des crochets.}. L'extension \pkg{nicematrix} fait de même dans
\emph{tous} ses environnements y compris l'environnement |{NiceArray}|.
Néanmoins, si l'utilisateur souhaite que l'environnement |{NiceArray}| se
comporte par défaut comme l'environnement |{array}| de \pkg{array} (par exemple
pour faciliter l'adaptation d'un document existant), il peut contrôler ce
comportement avec l'option \Definition{exterior-arraycolsep} accessible via la
commande |\NiceMatrixOptions|. Avec cette option, des espaces extérieurs de
longueur |\arraycolsep| seront insérés dans les environnements |{NiceArray}|
(les autres environnements de l'extension \pkg{nicematrix} ne sont pas
affectés).




\subsection{Incompatibilités}

\index{Incompatibilités}

Il peut y avoir des incompatibilités de \pkg{nicematrix} avec \pkg{babel} pour
les langues qui activent (au sens de TeX) certains caractères, en particulier le
caractère~|<|. 

Par exemple, pour l'espagnol, il vaut mieux désactiver au chargement les
abréviations avec :

\begin{Code}
\usepackage[spanish,es-noshorthands]{babel}
\end{Code}

\medskip
L'extension \pkg{nicematrix} est incompatible avec certaines classes qui
redéfinissent les environnements |{tabular}| et |{array}|. C'est en particulier
le cas de la classe |socg-lipics-v2021|. Néanmoins, dans ce cas-là, il est
possible de charger la classe avec l'option |notab| qui requiert justement que
|{tabular}| ne soit pas redéfini.


\medskip
L'extension \pkg{nicematrix} n'est pas compatible avec la classe \cls{ieeeaccess}
car cette classe n'est pas compatible avec PGF-TikZ. Il existe néanmoins une
parade simple qui consiste à écrire:\footnote{Voir
  \url{https://tex.stackexchange.com/questions/528975}}

\nobreak
\begin{Code}
\let\TeXyear\year
\documentclass{IEEEaccess}
\let\year\TeXyear
\end{Code}



\medskip
% l'information suivante est toujours d'actualité le 23 avril 2024
Pour pouvoir utiliser \pkg{nicematrix} avec la classe \cls{aastex631} (de
l'\emph{American Astronomical Society}), on doit ajouter dans le préambule du
fichier les instructions suivantes :

% La construction suivante a pour but d'éviter que la fontification de Emacs ne
% soit perturbée.
\begin{scope}\ttfamily \color{gray}
\textbackslash BeforeBegin\{NiceTabular\}\{\textbackslash
let\textbackslash begin\textbackslash BeginEnvironment\textbackslash
let\textbackslash end\textbackslash EndEnvironment\}

\textbackslash BeforeBegin\{NiceArray\}\{\textbackslash
let\textbackslash begin\textbackslash BeginEnvironment\}

\textbackslash BeforeBegin\{NiceMatrix\}\{\textbackslash
let\textbackslash begin\textbackslash BeginEnvironment\}
\end{scope}


\medskip
L'extension \pkg{nicematrix} n'est pas parfaitement compatible avec les classes
et extensions de LuaTeX-ja: la détection des coins vides (cf.
p.~\pageref{corners}) risque d'être erronée dans certaines circonstances.



\medskip
L'extension \pkg{nicematrix} n'est pas parfaitement compatible avec l'extension
\pkg{arydshln} (parce que cette extension redéfinit de nombreuses commandes
internes de \pkg{array}) et les colonnes |V| de l'extension \pkg{boldline} ne
sont pas prises en charge (car la lettre |V| est réservée pour les colonnes |V|
de \pkg{varwidth}). De toutes manières, \pkg{nicematrix} fournit, avec la clé
|custom-line| (cf. partie \ref{custom-line}, p.~\pageref{custom-line}) des
outils pour définir des filets en tiretés ou de différentes épaisseurs.

\medskip
Les colonnes |d| de l'extension \pkg{dcolumn} ne sont pas prises en compte (mais
on peut utiliser les colonnes |S| de \pkg{siunitx}). 



\subsection{Compatibilité avec le Tagging Project de LaTeX}

\index{Tagging Project}
\label{Tagging Project}

\colorbox{yellow!50}{\bfseries Nouveau 7.0}

Depuis la version 7.0, l'extension \pkg{nicematrix} est compatible avec le
\emph{Tagging Project} de LaTeX visant à la création automatique de PDF balisés.
Pour le moment, seuls les tableaux simples sont correctement balisés.

Voici un exemple de code qui va produire un PDF correctement balisé.


\bigskip
\begin{center}
\small
\begin{Code}
\DocumentMetadata{
  lang        = en,
  pdfversion  = 2.0,
  pdfstandard = ua-2,
  pdfstandard = a-4f, 
  \emph{testphase   = {phase-III, table, math}}
}
\documentclass{article}
\usepackage{lmodern}
\usepackage{nicematrix}

\begin{document}

\begin{center}
\emph{\tagpdfsetup{table/header-rows=1}}
\begin{NiceTabular}{ccc}[hvlines]
First name & Last name & Age \\
Paul       & Imbert    & $66$ \\
John       & Sarrus    & $23$ \\
Liz        & Taylor    & $100$ \\
George     & Adams     & $34$ 
\end{NiceTabular}
\end{center}

\end{document}
\end{Code}
\end{center}


\section{Exemples}

\subsection{Utilisation de la clé «tikz» de la commande \textbackslash Block}

\index{tikzz@tikz!clé de \texttt{\textbackslash Block}|textit}

\label{ex:tikz-key}

La clé |tikz| de la commande |\Block| n'est disponible que lorsque TikZ est
chargé.\footnote{Par défaut, \pkg{nicematrix} ne charge que \textsc{pgf}, qui
  est une sous-couche de TikZ.}

Pour l'exemple suivant, la bibliothèque \pkg{patterns} de TikZ doit aussi être chargée.

\begin{Verbatim}
\usetikzlibrary{patterns}
\end{Verbatim}

\begin{Code}
\ttfamily \small
\begin{NiceTabular}{X[m]X[m]X[m]}[hvlines,cell-space-limits=3pt,rounded-corners]
  \Block[\emph{tikz={pattern=grid,pattern color=lightgray}}]{}
    {pattern = grid,\\ pattern color = lightgray}
& \Block[\emph{tikz={pattern = north west lines,pattern color=blue}}]{}
    {pattern = north west lines,\\ pattern color = blue}
& \Block[\emph{tikz={outer color = red!50, inner color=white }}]{2-1}
    {outer color = red!50,\\ inner color = white} \\
  \Block[\emph{tikz={pattern = sixpointed stars, pattern color = blue!15}}]{}
    {pattern = sixpointed stars,\\ pattern color = blue!15}
& \Block[\emph{tikz={left color = blue!50}}]{}
    {left color = blue!50} \\
\end{NiceTabular}
\end{Code}

\begin{center}
\ttfamily \small
\begin{NiceTabular}{X[m]X[m]X[m]}[hvlines,cell-space-limits=3pt,rounded-corners,no-cell-nodes]
  \Block[tikz={pattern=grid,pattern color=lightgray}]{}
    {pattern = grid,\\ pattern color = lightgray}
& \Block[tikz={pattern = north west lines,pattern color=blue}]{}
    {pattern = north west lines,\\ pattern color = blue}
& \Block[tikz={outer color = red!50, inner color=white }]{2-1}
    {outer color = red!50,\\ inner color = white} \\
  \Block[tikz={pattern = sixpointed stars, pattern color = blue!15}]{}
    {pattern = sixpointed stars,\\ pattern color = blue!15}
& \Block[tikz={left color = blue!50}]{}
    {left color = blue!50} \\
\end{NiceTabular}
\end{center}


\bigskip

Dans l'exemple suivant, on utilise la clé |tikz| pour hachurer une rangée du
tableau. On remarquera que l'on utilise la clé |transparent| de la commande
|\Block| pour que les filets soient tracés dans le bloc.\footnote{Par défaut,
  les filets ne sont pas tracés dans les blocs créés avec la commande
  \texttt{\textbackslash Block} (cf.~section~\ref{rules} p.~\pageref{rules}) :
  la clé |transparent| permet qu'ils le soient (le block devient ainsi
  \emph{transparent} aux filets extérieurs).}

\index{transparent (clé de \texttt{\textbackslash Block})|textit}
\index{columncolor@\texttt{\textbackslash columncolor}!commande du
  \texttt{\textbackslash CodeBefore}|textit}


\begin{Code}
\begin{NiceTabular}{ccc}[hvlines]
\CodeBefore
  \columncolor[RGB]{169,208,142}{2}
\Body
un & deux & trois \\
\Block[\emph{transparent, tikz={pattern = north west lines, pattern color = gray}}]{1-*}{}
quatre & cinq & six \\
sept & huit & neuf
\end{NiceTabular}
\end{Code}

\begin{center}
\begin{NiceTabular}{ccc}[hvlines]
\CodeBefore
  \columncolor[RGB]{169,208,142}{2}
\Body
un & deux & trois \\
\Block[transparent, tikz={pattern = north west lines, pattern color = gray}]{1-*}{}
quatre & cinq & six \\
sept & huit & neuf
\end{NiceTabular}
\end{center}



\subsection{Utilisation avec tcolorbox}

\label{ex:tcolorbox}
\index{tcolorbox@\pkg{tcolorbox} (extension)|textit}

Voici un exemple d'utilisation de |{NiceTabular}| dans une commande |\tcbox| de
\pkg{tcolorbox}. On a utilisé la clé |hvlines-except-borders| pour faire afficher
tous les filets sauf ceux sur les bords (qui sont, bien entendu, ajoutés par
\pkg{tcolorbox}). 

\medskip
\begin{Code}
\tcbset
  {
    colframe = blue!50!black ,
    colback = white ,
    fonttitle = \bfseries ,
    nobeforeafter ,
    center title
  }

\tcbox
  [
    left = 0mm ,
    right = 0mm ,
    top = 0mm ,
    bottom = 0mm ,
    boxsep = 0mm ,
    toptitle = 0.5mm ,
    bottomtitle = 0.5mm ,
    title = My table
  ]
  {
    \renewcommand{\arraystretch}{1.2}% <-- the % is mandatory here
    \begin{NiceTabular}{rcl}[\emph{hvlines-except-borders},rules/color=blue!50!black]
    \CodeBefore
      \rowcolor{red!15}{1}
    \Body
      One & Two & Three \\
      Men & Mice & Lions \\
      Upper & Middle & Lower
    \end{NiceTabular}
  }
\end{Code}



\index{hvlines-except-borders|textit}
\index{rules (clé pour un environnement)|textit}
\index{rowcolor@\texttt{\textbackslash rowcolor}!commande du
  \texttt{\textbackslash CodeBefore}|textit}

\medskip
\begin{center}
\tcbset
  {
    colframe = blue!50!black ,
    colback = white ,
    fonttitle = \bfseries ,
    nobeforeafter ,
    center title
  }

\tcbox
  [
    left = 0mm ,
    right = 0mm ,
    top = 0mm ,
    bottom = 0mm ,
    boxsep = 0mm ,
    toptitle = 0.5mm ,
    bottomtitle = 0.5mm ,
    title = My table
  ]
  {
    \renewcommand{\arraystretch}{1.2}%
    \begin{NiceTabular}{rcl}[hvlines-except-borders,rules/color=blue!50!black]
    \CodeBefore
      \rowcolor{red!15}{1}
    \Body
      One & Two & Three \\
      Men & Mice & Lions \\
      Upper & Middle & Lower
    \end{NiceTabular}
  }
\end{center}




\subsection{Notes dans les tableaux}

\index{nota@\textbf{Notes dans les tableaux}|textit}
\index{tabularnote@\texttt{\textbackslash tabularnote}|textit}
\index{notes (clé pour paramétrer les notes de\newline tableau)|textit}
\index{style (sous-clé de «notes»)|textit}
\index{enumitem-keys (sous-clé de «notes»)|textit}
\index{enumitem@\pkg{enumitem} (extension requise pour utiliser\newline
  \texttt{\textbackslash tabularnote})|textit}
\label{ex:notes}

Les outils de \pkg{nicematrix} pour les notes dans les tableaux ont été
présentés à la partie \ref{s:notes} p.~\pageref{s:notes}.

\medskip
Imaginons que l'on souhaite numéroter les notes de tableau (celles construites
avec |\tabularnote|) avec des astérisques.\footnote{Bien entendu, il faut qu'il
  y en ait très peu : trois paraît un maximum.}

On commence par écrire une commande |\stars| similaire aux commandes classiques
|\arabic|, |\alph|, |\Alph|, etc. mais qui produit un nombre d'astérisques égal
à son argument.\footnote{Ou plutôt : à la valeur de son argument.}

\medskip
\begin{Code}
\ExplSyntaxOn
\NewDocumentCommand { \emph{\stars} } { m }
  { \prg_replicate:nn { \value { #1 } } { \( \star \) } }
\ExplSyntaxOff
\end{Code}

\medskip
Bien entendu, on change le style des notes avec la clé |notes/style|. Mais, il
serait bon aussi de changer certains paramètres du type de liste (au sens de
\pkg{enumitem}) utilisé pour composer les notes après le tableau. On demande de
composer les labels avec une largeur égale à celle du plus grand des labels. Or,
le label le plus large est bien entendu celui avec le maximum d'astérisques.
On connaît ce nombre : il est égal à |\value{tabularnote}| (car |tabularnote|
est le compteur LaTeX utilisé par |\tabularnote| et il est donc égal à la fin au
nombre total de notes dans le tableau). On utilise alors la clé |widest*| de
\pkg{enumitem} pour demander une largeur de label correspondante :
|widest*=\value{tabularnote}|.

\smallskip
\begin{Code}
\NiceMatrixOptions
  {
    notes =
     {
       \emph{style = \stars{#1} , 
       enumitem-keys = 
        { 
          widest* = \value{tabularnote} ,
          align = right 
        } }
     }
  }
\end{Code}



\begin{scope}
\ExplSyntaxOn
\NewDocumentCommand \stars { m }
  { \prg_replicate:nn { \value { #1 } } { \( \star \) } }
\NiceMatrixOptions
  {
    notes =
     {
       style = \stars{#1} ,
       enumitem-keys =
        {
          widest* = \value{tabularnote} ,
          align = right
        }
     }
  }
\ExplSyntaxOff

\begin{Code}
\begin{NiceTabular}{@{}llr@{}}
\toprule \RowStyle{\bfseries}
Nom & Prénom & Date de naissance \\
\midrule
Achard\emph{\tabularnote{La famille Achard est une très ancienne famille du Poitou.}}
& Jacques & 5 juin 1962 \\
Lefèbvre\emph{\tabularnote{Le patronyme Lefebvre est une altération de Lefébure.}}
& Mathilde & 23 mai 1988 \\
Vanesse & Stéphanie & 30 octobre 1994 \\
Dupont & Chantal & 15 janvier 1998 \\
\bottomrule
\end{NiceTabular}
\end{Code}

\begin{center}
\begin{NiceTabular}{@{}llr@{}}[no-cell-nodes]
\toprule \RowStyle{\bfseries}
Nom & Prénom & Date de naissance \\
\midrule
Achard\tabularnote{La famille Achard est une très ancienne famille du Poitou.}
& Jacques & 5 juin 1962 \\
Lefebvre\tabularnote{Le patronyme Lefebvre est une altération de Lefébure.}
& Mathilde & 23 mai 1988 \\
Vanesse & Stéphanie & 30 octobre 1994 \\
Dupont & Chantal & 15 janvier 1998 \\
\bottomrule
\end{NiceTabular}
\end{center}
\end{scope}




\subsection{Lignes en pointillés}

\index{Pointillés@\textbf{Pointillés (lignes en ---)}|textit}


Un exemple pour le résultant de deux polynômes :

\nobreak
\medskip
\begin{Code}
\setlength{\extrarowheight}{1mm}
\begin{vNiceArray}{cccc:ccc}[columns-width=6mm]
a_0   &      &&       &b_0    &      &     \\
a_1   &\Ddots&&       &b_1    &\Ddots&     \\
\Vdots&\Ddots&&       &\Vdots &\Ddots&b_0  \\
a_p   &      &&a_0    &       &      &b_1   \\
      &\Ddots&&a_1    &b_q    &      &\Vdots\\
      &      &&\Vdots &       &\Ddots&      \\
      &      &&a_p     &       &      &b_q
\end{vNiceArray}
\end{Code}



\index{Ddots@\texttt{\textbackslash Ddots}|textit}

\medskip

\begin{scope}
\setlength{\extrarowheight}{1mm}
\[\begin{vNiceArray}{cccc:ccc}[columns-width=6mm]
a_0   &      &&       &b_0    &      &     \\
a_1   &\Ddots&&       &b_1    &\Ddots&     \\
\Vdots&\Ddots&&       &\Vdots &\Ddots&b_0  \\
a_p   &      &&a_0    &       &      &b_1   \\
      &\Ddots&&a_1    &b_q    &      &\Vdots\\
      &      &&\Vdots &       &\Ddots&      \\
      &      &&a_p     &       &      &b_q
\end{vNiceArray}\]
\end{scope}

\vspace{2cm}
Un exemple avec un système linéaire:

\index{last-col|textit}
\index{code-for-last-col|textit}

\begin{Verbatim}
$\begin{pNiceArray}{*6{c}|c}[nullify-dots,last-col,code-for-last-col=\scriptstyle]
1      & 1 & 1 &\Cdots &   & 1      & 0      & \\
0      & 1 & 0 &\Cdots &   & 0      &        & L_2 \gets L_2-L_1 \\
0      & 0 & 1 &\Ddots &   & \Vdots &        & L_3 \gets L_3-L_1 \\
       &   &   &\Ddots &   &        & \Vdots & \Vdots \\
\Vdots &   &   &\Ddots &   & 0      & \\
0      &   &   &\Cdots & 0 & 1      & 0      & L_n \gets L_n-L_1
\end{pNiceArray}$
\end{Verbatim}


\[\begin{pNiceArray}{*6{c}|c}[nullify-dots,last-col,code-for-last-col=\scriptstyle]
1      & 1 & 1 &\Cdots &   & 1      & 0      & \\
0      & 1 & 0 &\Cdots &   & 0      &        & L_2 \gets L_2-L_1 \\
0      & 0 & 1 &\Ddots &   & \Vdots &        & L_3 \gets L_3-L_1 \\
       &   &   &\Ddots &   &        & \Vdots & \Vdots \\
\Vdots &   &   &\Ddots &   & 0      & \\
0      &   &   &\Cdots & 0 & 1      & 0      & L_n \gets L_n-L_1
\end{pNiceArray}\]



\subsection{Des lignes pointillées qui ne sont plus pointillées}

\label{ex:no-longer-dotted-rules}

L'option |line-style| permet de changer le style des lignes tracées par
|\Ldots|, |\Cdots|, etc. On peut de ce fait tracer des lignes qui ne sont plus
pointillées (TikZ doit être chargé).

\index{line-style (clé pour les lignes pointillées)|textit}

\begin{scope}
\small
\begin{Verbatim}
\setcounter{MaxMatrixCols}{12}
\newcommand{\blue}{\color{blue}}
\[\begin{pNiceMatrix}[last-row,last-col,nullify-dots,xdots/line-style={dashed,blue}]
1& & & \Vdots & & & & \Vdots \\
& \Ddots[line-style=standard] \\
& & 1 \\
\Cdots & & & \blue 0 & \Cdots & & & \blue 1 & & & \Cdots & \blue \leftarrow i \\
& & & & 1 \\
& & &\Vdots & & \Ddots[line-style=standard] & & \Vdots \\
& & & & & & 1 \\
\Cdots & & & \blue 1 & \Cdots & & \Cdots & \blue 0 & & & \Cdots & \blue \leftarrow j \\
& & & & & & & & 1 \\
& & & & & & & & & \Ddots[line-style=standard] \\
& & & \Vdots & & & & \Vdots & & & 1 \\
& & & \blue \overset{\uparrow}{i} & & & & \blue \overset{\uparrow}{j} \\
\end{pNiceMatrix}\]
\end{Verbatim}
\end{scope}

\index{code-for-first-row|textit}
\index{code-for-last-col|textit}

\begin{scope}
\setcounter{MaxMatrixCols}{12}
\newcommand{\blue}{\color{blue}}
\[\begin{pNiceMatrix}[last-row,last-col,nullify-dots,xdots/line-style={dashed,blue}]
1& & & \Vdots & & & & \Vdots \\
& \Ddots[line-style=standard] \\
& & 1 \\
\Cdots & & & \blue 0 & \Cdots & & & \blue 1 & & & \Cdots & \blue \leftarrow i \\
& & & & 1 \\
& & &\Vdots & & \Ddots[line-style=standard] & & \Vdots \\
& & & & & & 1 \\
\Cdots & & & \blue 1 & \Cdots & & \Cdots & \blue 0 & & & \Cdots & \blue \leftarrow j \\
& & & & & & & & 1 \\
& & & & & & & & & \Ddots[line-style=standard] \\
& & & \Vdots & & & & \Vdots & & & 1 \\
& & & \blue \overset{\uparrow}{i} & & & & \blue \overset{\uparrow}{j} \\
\end{pNiceMatrix}\]
\end{scope}



\interitem
On peut même tracer des lignes continues.\footnote{Dans ce document, la
  bibliothèque \pkg{arrows.meta} de TikZ a été chargée, ce qui a une incidence
  sur la forme des pointes de flèches.}

\medskip
\begin{Code}
\NiceMatrixOptions{xdots={horizontal-labels,line-style = <->}}
\end{Code}
\begin{Code}[width=11cm]
$\begin{pNiceArray}{ccc|cc}[first-row,last-col,margin]
\emph{\Hdotsfor{3}^{3}} & \emph{\Hdotsfor{2}^{2}} \\
2 & 1 & 1 & 1 & 1 & \emph{\Vdotsfor{3}^{3}}\\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & \emph{\Vdotsfor{2}^{2}}\\
1 & 1 & 1 & 1 & 1 \\
\end{pNiceArray}$
\end{Code}
{\NiceMatrixOptions{xdots={horizontal-labels,line-style = <->}}
$\begin{pNiceArray}{ccc|cc}[first-row,last-col,margin]
\Hdotsfor{3}^{3} & \Hdotsfor{2}^{2} \\
2 & 1 & 1 & 1 & 1 & \Vdotsfor{3}^{3}\\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & \Vdotsfor{2}^{2}\\
1 & 1 & 1 & 1 & 1 \\
\end{pNiceArray}$}


\interitem
\label{ex:colon}
Si on veut mettre les labels sur les flèches, il convient d'utiliser le
caractère spécial~«|:|» au lieu de~«|^|»:

\medskip
\begin{Code}
\NiceMatrixOptions{xdots={horizontal-labels,line-style = <->}}
\end{Code}
\begin{Code}[width=11cm]
$\begin{pNiceArray}{ccc|cc}[first-row,last-col,margin]
\emph{\Hdotsfor{3}:{3}} & \emph{\Hdotsfor{2}:{2}} \\
2 & 1 & 1 & 1 & 1 & \emph{\Vdotsfor{3}:{3}} \\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & 
\emph{\Vdotsfor{2}:{2 \rlap{ \smash{lignes}}}} \\
1 & 1 & 1 & 1 & 1 \\
\end{pNiceArray}$
\end{Code}
{\NiceMatrixOptions{xdots={horizontal-labels,line-style = <->}}
$\begin{pNiceArray}{ccc|cc}[first-row,last-col,margin]
\Hdotsfor{3}:{3} & \Hdotsfor{2}:{2} \\
2 & 1 & 1 & 1 & 1 & \Vdotsfor{3}:{3}\\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & \Vdotsfor{2}:{2 \rlap{ \smash{lignes}}}\\
1 & 1 & 1 & 1 & 1 \\
\end{pNiceArray}$}


\interitem
\label{ex:hbrace}
Si on préfère des accolades comme celles proposées par la bibliothèque
\pkg{decorations.pathreplacing} de TikZ, le mieux est d'utiliser les commandes
|\Hbrace| et |\Vbrace| proposées par \pkg{nicematrix} (cf.
p.~\pageref{Hbrace}).\footnote{Ces commandes ne sont disponibles que si TikZ a
  été chargée ainsi que la bibliothèque \pkg{decorations.pathreplacing} de TikZ
  : |\usepackage{TikZ}| |\usetikzlibrary{decorations.pathreplacing}|.}


\medskip
\begin{Code}
\NiceMatrixOptions{xdots/horizontal-labels}
\end{Code}
\begin{Code}[width=11cm]
$\begin{pNiceArray}{ccc|cc}[first-row,last-col,margin]
\emph{\Hbrace{3}{3}} & \emph{\Hbrace{2}{2}} \\
2 & 1 & 1 & 1 & 1 & \emph{\Vbrace{3}{3}} \\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & \emph{\Vbrace{2}{2}} \\
1 & 1 & 1 & 1 & 1 \\
\end{pNiceArray}$
\end{Code}
{\NiceMatrixOptions{xdots/horizontal-labels}
$\begin{pNiceArray}{ccc|cc}[first-row,last-col,margin]
\Hbrace{3}{3} & \Hbrace{2}{2} \\
2 & 1 & 1 & 1 & 1 & \Vbrace{3}{3}\\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & \Vbrace{2}{2}\\
1 & 1 & 1 & 1 & 1 \\
\end{pNiceArray}$}



Il est possible de changer le style TikZ des accolades en changeant le style
|nicematrix/brace|. Dans l'exemple suivant, on suppose que l'extension
\pkg{calligraphy} de TikZ a été chargée:

\smallskip
\begin{Verbatim}
\usetikzlibrary{calligraphy}
\end{Verbatim}



\medskip
\begin{Code}
\NiceMatrixOptions{xdots/horizontal-labels}
\tikzset
  {
    nicematrix/brace/.style = 
      { 
        decoration = 
          { 
            calligraphic brace , 
            amplitude = 0.4 em , 
            raise = -0.25 em 
          } , 
        line width = 0.1 em ,
        decorate , 
      } 
  }
\end{Code}
\begin{Code}[width=11cm]
$\begin{pNiceArray}{ccc|cc}[first-row,last-col,margin]
\emph{\Hbrace{3}{3}} & \emph{\Hbrace{2}{2}} \\
2 & 1 & 1 & 1 & 1 & \emph{\Vbrace{3}{3}} \\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & \emph{\Vbrace{2}{2}} \\
1 & 1 & 1 & 1 & 1 \\
\end{pNiceArray}$
\end{Code}
{\NiceMatrixOptions{xdots/horizontal-labels}
\tikzset
  {
    nicematrix/brace/.style = 
      { 
        decoration = 
          { 
            calligraphic brace , 
            amplitude = 0.4 em , 
            raise = -0.25 em 
          } , 
        line width = 0.1 em ,
        decorate , 
      } 
  }
$\begin{pNiceArray}{ccc|cc}[first-row,last-col,margin]
\Hbrace{3}{3} & \Hbrace{2}{2} \\
2 & 1 & 1 & 1 & 1 & \Vbrace{3}{3}\\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & \Vbrace{2}{2}\\
1 & 1 & 1 & 1 & 1 \\
\end{pNiceArray}$}



\interitem
Si on préfère les accolades de la fonte mathématique courante, il convient
d'utiliser les commandes |\SubMatrix|, |\OverBrace| et |\UnderBrace| dans le
|\CodeAfter|.

\medskip
\begin{Code}[width=11cm]
$\begin{pNiceArray}{ccc|cc}[margin,last-col]
2 & 1 & 1 & 1 & 1 & \Block{3-1}{\quad 3} \\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & \Block{2-1}{\quad 2} \\
1 & 1 & 1 & 1 & 1 \\
\CodeAfter
  \emph{\OverBrace[shorten,yshift=1.5mm]{1-1}{1-3}{3}}
  \emph{\OverBrace[shorten,yshift=1.5mm]{1-4}{1-5}{2}}
  \emph{\SubMatrix{.}{1-1}{3-5}{\rbrace}[xshift=3.5mm]}
  \emph{\SubMatrix{.}{4-1}{5-5}{\rbrace}[xshift=3.5mm]}
\end{pNiceArray}$
\end{Code}
$\begin{pNiceArray}{ccc|cc}[margin,last-col]
2 & 1 & 1 & 1 & 1 & \Block{3-1}{\quad 3} \\
1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 \\
\Hline
1 & 1 & 1 & 1 & 1 & \Block{2-1}{\quad 2} \\
1 & 1 & 1 & 1 & 1 \\
\CodeAfter
  \OverBrace[shorten,yshift=1.5mm]{1-1}{1-3}{3}
  \OverBrace[shorten,yshift=1.5mm]{1-4}{1-5}{2}
  \SubMatrix{.}{1-1}{3-5}{\}}[xshift=3.5mm]
  \SubMatrix{.}{4-1}{5-5}{\}}[xshift=3.5mm]
\end{pNiceArray}$




\subsection{Lignes en tiretés}

\label{ex:tiretes}

\index{tikzz@tikz!clé de «borders» de \texttt{\textbackslash Block}|textit}

Dans l'exemple suivant, on utilise des commandes |\Block| pour tracer des filets
en tiretés. Cet exemple nécessite que TikZ soit chargé (par
|\usepackage{tikz}|). 

\medskip
\begin{Code}
\begin{pNiceMatrix}
\emph{\Block[borders={bottom,right,tikz=dashed}]{2-2}{}}
1 & 2 & 0  & 0 & 0 & 0 \\
4 & 5 & 0  & 0 & 0 & 0 \\
0 & 0 & \emph{\Block[borders={bottom,top,right,left,tikz=dashed}]{2-2}{}}
        7  & 1 & 0 & 0 \\
0 & 0 & -1 & 2 & 0 & 0 \\
0 & 0 & 0  & 0 & \emph{\Block[borders={left,top,tikz=dashed}]{2-2}{}}
                 3 & 4 \\
0 & 0 & 0  & 0 & 1 & 4 
\end{pNiceMatrix}
\end{Code}



\[\begin{pNiceMatrix}
\Block[borders={bottom,right,tikz=dashed}]{2-2}{}
1 & 2 & 0  & 0 & 0 & 0 \\
4 & 5 & 0  & 0 & 0 & 0 \\
0 & 0 & \Block[borders={bottom,top,right,left,tikz=dashed}]{2-2}{}
        7  & 1 & 0 & 0 \\
0 & 0 & -1 & 2 & 0 & 0 \\
0 & 0 & 0  & 0 & \Block[borders={left,top,tikz=dashed}]{2-2}{}
                 3 & 4 \\
0 & 0 & 0  & 0 & 1 & 4 
\end{pNiceMatrix}\]



\subsection{Empilements de matrices}

On a souvent besoin de présenter des matrices empilées les unes au-dessus des
autres (par exemple pour la résolution  de systèmes linéaires).


\medskip
Pour avoir les colonnes alignées les unes sous les autres, on peut imposer une
largeur commune à toutes les colonnes, ce que l'on fait dans l'exemple suivant
avec l'environnement |{NiceMatrixBlock}| et l'option |auto-columns-width|.

\index{NiceMatrixBlock@\texttt{\{NiceMatrixBlock\}}|textit}

\bigskip



\begin{scope}
\small
\begin{Code}
\emph{\begin{NiceMatrixBlock}[auto-columns-width]}
\NiceMatrixOptions
  {
    light-syntax,
    last-col, code-for-last-col = \color{blue}\scriptstyle,
    vlines = 5 ,
    matrix/columns-type = r ,
    no-cell-nodes % facultatif
  }
\setlength{\extrarowheight}{1mm}

\quad $\begin{pNiceMatrix}
12  -8  7  5   3 {} ;
 3 -18 12  1   4    ;
-3 -46 29 -2 -15    ;
 9  10 -5  4   7
\end{pNiceMatrix}$

\smallskip
\quad $\begin{pNiceMatrix}
12  -8   7  5   3 ;
0   64 -41  1  19  { L_2 \gets L_1-4L_2  } ;
0 -192 123 -3 -57  { L_3 \gets L_1+4L_3  } ;
0 -64   41 -1 -19  { L_4 \gets 3L_1-4L_4 } ;
\end{pNiceMatrix}$

\smallskip
\quad $\begin{pNiceMatrix}
12 -8   7 5  3 ;
0  64 -41 1 19 ;
0   0   0 0  0 { L_3 \gets 3 L_2 + L_3 }
\end{pNiceMatrix}$

\smallskip
\quad $\begin{pNiceMatrix}
12 -8   7 5  3 {} ;
0  64 -41 1 19    ;
\end{pNiceMatrix}$
\emph{\end{NiceMatrixBlock}}
\end{Code}
\end{scope}




\medskip
\index{auto-columns-width!(clé de \texttt{\{NiceMatrixBlock\}})|textit}
\begin{NiceMatrixBlock}[auto-columns-width]
\NiceMatrixOptions
  {
    light-syntax,
    last-col, code-for-last-col = \color{blue}\scriptstyle,
    vlines = 5 ,
    matrix/columns-type = r ,
    no-cell-nodes
  }
\setlength{\extrarowheight}{1mm}

\quad $\begin{pNiceMatrix}
12  -8  7  5   3 {} ;
 3 -18 12  1   4    ;
-3 -46 29 -2 -15    ;
 9  10 -5  4   7
\end{pNiceMatrix}$

\smallskip
\quad $\begin{pNiceMatrix}
12  -8   7  5   3                      ;
0   64 -41  1  19  { L_2 \gets L_1-4L_2  } ;
0 -192 123 -3 -57  { L_3 \gets L_1+4L_3  } ;
0 -64   41 -1 -19  { L_4 \gets 3L_1-4L_4 } ;
\end{pNiceMatrix}$

\smallskip
\quad $\begin{pNiceMatrix}
12 -8   7 5  3 ;
0  64 -41 1 19 ;
0   0   0 0  0 { L_3 \gets 3 L_2 + L_3 }
\end{pNiceMatrix}$

\smallskip
\quad $\begin{pNiceMatrix}
12 -8   7 5  3 {} ;
0  64 -41 1 19    ;
\end{pNiceMatrix}$
\end{NiceMatrixBlock}

\medskip
On constate que la dernière matrice n'est pas parfaitement alignée avec les
précédentes. C'est que les parenthèses, en LaTeX, n'ont pas toutes la même
largeur suivant leur taille.

\medskip
\index{max-width (sous-clé de «delimiters»)}
\index{delimiters!---/max-width}
Pour résoudre ce problème, on peut demander que les délimiteurs soient composés
avec leur largeur maximale grâce à la clé booléenne
\Definition{delimiters/max-width}. 

\medskip

\begin{scope}
\small
\begin{Code}
\emph{\begin{NiceMatrixBlock}[auto-columns-width]}
\NiceMatrixOptions
  {
    \emph{delimiters/max-width},
    light-syntax,
    last-col, code-for-last-col = \color{blue}\scriptstyle,
    vlines = 5 ,
    matrix/columns-type = r ,
    no-cell-nodes % facultatif
  }
\setlength{\extrarowheight}{1mm}

\quad $\begin{pNiceMatrix}
12  -8  7  5   3 {} ;
 3 -18 12  1   4    ;
-3 -46 29 -2 -15    ;
 9  10 -5  4   7
\end{pNiceMatrix}$
...
\emph{\end{NiceMatrixBlock}}
\end{Code}
\end{scope}



\medskip
\begin{NiceMatrixBlock}[auto-columns-width]
\NiceMatrixOptions
  {
    delimiters/max-width,
    light-syntax,
    last-col, code-for-last-col = \color{blue}\scriptstyle,
    vlines = 5 ,
    matrix/columns-type = r ,
    no-cell-nodes
  }
\setlength{\extrarowheight}{1mm}

\quad $\begin{pNiceMatrix}
12  -8  7  5   3 {} ;
 3 -18 12  1   4    ;
-3 -46 29 -2 -15    ;
 9  10 -5  4   7
\end{pNiceMatrix}$

\smallskip
\quad $\begin{pNiceMatrix}
12  -8   7  5   3                      ;
0   64 -41  1  19  { L_2 \gets L_1-4L_2  } ;
0 -192 123 -3 -57  { L_3 \gets L_1+4L_3  } ;
0 -64   41 -1 -19  { L_4 \gets 3L_1-4L_4 } ;
\end{pNiceMatrix}$

\smallskip
\quad $\begin{pNiceMatrix}
12 -8   7 5  3 ;
0  64 -41 1 19 ;
0   0   0 0  0 { L_3 \gets 3 L_2 + L_3 }
\end{pNiceMatrix}$

\smallskip
\quad $\begin{pNiceMatrix}
12 -8   7 5  3 {} ;
0  64 -41 1 19    ;
\end{pNiceMatrix}$
\end{NiceMatrixBlock}


\interitem
Si on souhaite un alignement des colonnes des différentes matrices sans imposer
la même largeur à toutes les colonnes, on peut utiliser un grand tableau unique
et placer les parenthèses avec des commandes |\SubMatrix| dans le |\CodeAfter|.
Bien sûr, ce tableau ne pourra pas être coupé par un saut de page.

\medskip
\index{SubMatrix@\texttt{\textbackslash SubMatrix} (commande du 
\texttt{\textbackslash CodeAfter}\newline et du 
\texttt{\textbackslash CodeBefore})|textit}
\begin{Code}
\setlength{\extrarowheight}{1mm}
\[\begin{NiceMatrix}%
  [ r, last-col=6, code-for-last-col = \scriptstyle \color{blue} ]
12 &  -8  &  7 & 5 &  3 \\
 3 & -18  & 12 & 1 &  4 \\
-3 & -46  & 29 &-2 &-15 \\
 9 & 10   &-5  &4  & 7 \\[1mm]
12 & -8   & 7  &5  & 3 \\
0  & 64   &-41 & 1 & 19 & L_2 \gets L_1-4L_2  \\
0  & -192 &123 &-3 &-57 & L_3 \gets L_1+4L_3  \\
0  & -64  & 41 &-1 &-19 & L_4 \gets 3L_1-4L_4 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 &1  &19 \\
0  &  0   &0   &0  & 0 & L_3 \gets 3L_2+L_3 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 & 1 & 19 \\
\emph{\CodeAfter [sub-matrix/vlines=4]
   \SubMatrix({1-1}{4-5})
   \SubMatrix({5-1}{8-5})
   \SubMatrix({9-1}{11-5})
   \SubMatrix({12-1}{13-5})}
\end{NiceMatrix}\]
\end{Code}

\medskip
\begin{scope}
\setlength{\extrarowheight}{1mm}
\[\begin{NiceMatrix}%
  [ r, last-col=6, code-for-last-col = \scriptstyle \color{blue}]
12 &  -8  &  7 & 5 &  3 \\
 3 & -18  & 12 & 1 &  4 \\
-3 & -46  & 29 &-2 &-15 \\
 9 & 10   &-5  &4  & 7 \\[1mm]
12 & -8   & 7  &5  & 3 \\
0  & 64   &-41 & 1 & 19 & L_2 \gets L_1-4L_2  \\
0  & -192 &123 &-3 &-57 & L_3 \gets L_1+4L_3  \\
0  & -64  & 41 &-1 &-19 & L_4 \gets 3L_1-4L_4 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 &1  &19 \\
0  &  0   &0   &0  & 0 & L_3 \gets 3L_2+L_3 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 & 1 & 19 \\
\CodeAfter [sub-matrix/vlines=4]
   \SubMatrix({1-1}{4-5})
   \SubMatrix({5-1}{8-5})
   \SubMatrix({9-1}{11-5})
   \SubMatrix({12-1}{13-5})
\end{NiceMatrix}\]
\end{scope}

\medskip
Dans ce tableau, les instructions |\SubMatrix| sont exécutées après la
composition du tableau et les traits verticaux sont donc tracés sans espacer les
colonnes.

\medskip
\index{vlines-in-sub-matrix}
En fait, on peut avec la clé \Definition{vlines-in-sub-matrix} choisir un
spécificateur dans le préambule du tableau pour indiquer des filets verticaux
qui seront tracés dans les |\SubMatrix| uniquement (en espaçant les colonnes).

\medskip
\begin{Code}
\setlength{\extrarowheight}{1mm}
\[\begin{NiceArray}
   [
     \emph{vlines-in-sub-matrix=I},
     last-col,
     code-for-last-col = \scriptstyle \color{blue}
   ]
  {rrrrIr}
12 &  -8  &  7 & 5 &  3 \\
 3 & -18  & 12 & 1 &  4 \\
-3 & -46  & 29 &-2 &-15 \\
 9 & 10   &-5  &4  & 7 \\[1mm]
12 & -8   & 7  &5  & 3 \\
0  & 64   &-41 & 1 & 19 & L_2 \gets L_1-4L_2  \\
0  & -192 &123 &-3 &-57 & L_3 \gets L_1+4L_3  \\
0  & -64  & 41 &-1 &-19 & L_4 \gets 3L_1-4L_4 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 &1  &19 \\
0  &  0   &0   &0  & 0 & L_3 \gets 3L_2+L_3 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 & 1 & 19 \\
\CodeAfter
   \SubMatrix({1-1}{4-5})
   \SubMatrix({5-1}{8-5})
   \SubMatrix({9-1}{11-5})
   \SubMatrix({12-1}{13-5})
\end{NiceArray}\]
\end{Code}



\medskip
\begin{scope}
\setlength{\extrarowheight}{1mm}
\[\begin{NiceArray}
   [
     vlines-in-sub-matrix=I,
     last-col,
     code-for-last-col = \scriptstyle \color{blue}
   ]
  {rrrrIr}
12 &  -8  &  7 & 5 &  3 \\
 3 & -18  & 12 & 1 &  4 \\
-3 & -46  & 29 &-2 &-15 \\
 9 & 10   &-5  &4  & 7 \\[1mm]
12 & -8   & 7  &5  & 3 \\
0  & 64   &-41 & 1 & 19 & L_2 \gets L_1-4L_2  \\
0  & -192 &123 &-3 &-57 & L_3 \gets L_1+4L_3  \\
0  & -64  & 41 &-1 &-19 & L_4 \gets 3L_1-4L_4 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 &1  &19 \\
0  &  0   &0   &0  & 0 & L_3 \gets 3L_2+L_3 \\[1mm]
12 & -8   &7   &5  & 3 \\
0  & 64   &-41 & 1 & 19 \\
\CodeAfter
   \SubMatrix({1-1}{4-5})
   \SubMatrix({5-1}{8-5})
   \SubMatrix({9-1}{11-5})
   \SubMatrix({12-1}{13-5})
\end{NiceArray}\]
\end{scope}




\subsection{Comment surligner les cases d'une matrice}


\index{draw (clé de \texttt{\textbackslash Block})|textit}

\medskip
Pour mettre en évidence une case d'une matrice, il est possible de «dessiner»
cette case avec la clé |draw| de la commande |\Block| (c'est l'un des usages des
blocs mono-case\footnote{On rappelle que si le premier argument obligatoire de
la commande |\Block| est laissé vide, le bloc est considéré comme mono-case.}).



\begin{Code}
$\begin{pNiceArray}{>{\strut}cccc}[margin,rules/color=blue,no-cell-nodes]
\emph{\Block[draw]{}{a_{11}}} & a_{12} & a_{13} & a_{14} \\
a_{21} & \emph{\Block[draw]{}{a_{22}}} & a_{23} & a_{24} \\
a_{31} & a_{32} & \emph{\Block[draw]{}{a_{33}}} & a_{34} \\
a_{41} & a_{42} & a_{43} & \emph{\Block[draw]{}{a_{44}}} \\
\end{pNiceArray}$
\end{Code}
%
\[\begin{pNiceArray}{>{\strut}cccc}[margin,rules/color=blue,no-cell-nodes]
\Block[draw]{}{a_{11}} & a_{12} & a_{13} & a_{14} \\
a_{21} & \Block[draw]{}{a_{22}} & a_{23} & a_{24} \\
a_{31} & a_{32} & \Block[draw]{}{a_{33}} & a_{34} \\
a_{41} & a_{42} & a_{43} & \Block[draw]{}{a_{44}} \\
\end{pNiceArray}\]


On remarquera que les traits que l'on vient de tracer sont dessinés \emph{après}
la matrice sans modifier la position des composantes de celle-ci. En revanche,
les traits tracés par |\hline|, |\Hline|, le spécificateur «\verb+|+» ou les
options |hlines|, |vlines|, |hvlines| et |hvlines-except-borders| «écartent» les
composantes de la matrice.\footnote{Pour la commande |\cline|, voir la remarque
  p.~\pageref{cline}.}

\vspace{1cm}
Il est possible de colorier une rangée avec |\rowcolor| dans le |\CodeBefore|
(ou avec |\rowcolor| dans une case de la rangée).

\index{rowcolor@\texttt{\textbackslash rowcolor}!commande en tableau|textit}

\begin{Code}
\begin{pNiceArray}{>{\strut}cccc}% <-- % obligatoire
    [margin, extra-margin=2pt,no-cell-nodes]
  \emph{\rowcolor{red!15}}A_{11} & A_{12} & A_{13} & A_{14} \\
  A_{21} & \emph{\rowcolor{red!15}}A_{22} & A_{23} & A_{24} \\
  A_{31} & A_{32} & \emph{\rowcolor{red!15}}A_{33} & A_{34} \\
  A_{41} & A_{42} & A_{43} & \emph{\rowcolor{red!15}}A_{44}
\end{pNiceArray}
\end{Code}



\[\begin{pNiceArray}{>{\strut}cccc}[margin, extra-margin=2pt,no-cell-nodes]
  \rowcolor{red!15}A_{11} & A_{12} & A_{13} & A_{14} \\
  A_{21} & \rowcolor{red!15}A_{22} & A_{23} & A_{24} \\
  A_{31} & A_{32} & \rowcolor{red!15}A_{33} & A_{34} \\
  A_{41} & A_{42} & A_{43} & \rowcolor{red!15}A_{44}
\end{pNiceArray}\]


\medskip
Les possibilités de réglages sont néanmoins limitées. C'est
pourquoi nous présentons ici une autre méthode pour surligner une rangée d'une
matrice.

\medskip
Cet exemple et les suivants nécessitent d'avoir chargé TikZ (\pkg{nicematrix} ne
charge que \textsc{pgf}, qui est une sous-couche de TikZ) ainsi que la
bibliothèque TikZ |fit|, ce qui peut se faire avec les deux instructions
suivantes dans le préambule du document :

\begin{verbatim}
\usepackage{tikz}
\usetikzlibrary{fit}
\end{verbatim}

\medskip
Nous créons un nœud TikZ rectangulaire qui englobe les nœuds de la deuxième
rangée en utilisant les outils de la bibliothèque TikZ \pkg{fit}. Ces nœuds ne
sont pas créés par défaut dans le |\CodeBefore| (par souci d'efficacité). Il
faut utiliser la clé |create-cell-nodes| du |\CodeBefore| pour demander leur création.

\tikzset{highlight/.style={rectangle,
                           fill=red!15,
                           rounded corners = 0.5 mm,
                           inner sep=1pt,
                           fit=#1}}

\medskip
\index{highlight (style TikZ défini dans\newline un exemple)|textit}
\begin{Code}
\tikzset{highlight/.style={rectangle,
                           fill=red!15,
                           rounded corners = 0.5 mm,
                           inner sep=1pt,
                           fit=#1}}

$\begin{bNiceMatrix}
\emph{\CodeBefore [create-cell-nodes] 
  \tikz \node [highlight = (2-1) (2-last)] {} ; 
\Body }
0 & \Cdots & 0 \\
1 & \Cdots & 1 \\
0 & \Cdots & 0 \\
\end{bNiceMatrix}$
\end{Code}

\index{create-cell-nodes (clé de \texttt{\textbackslash CodeBefore})|textit}
\index{CodeBefore@\texttt{\textbackslash CodeBefore}...\texttt{\textbackslash Body}|textit}

\[\begin{bNiceMatrix}
\CodeBefore [create-cell-nodes]
  \tikz \node [highlight = (2-1) (2-last)] {} ;
\Body
0 & \Cdots & 0 \\
1 & \Cdots & 1 \\
0 & \Cdots & 0 \\
\end{bNiceMatrix}\]




\vspace{1cm}
On considère maintenant la matrice suivante. Si on veut surligner chaque rangée
de la matrice, on peut utiliser la technique précédente trois fois.

\begin{Code}
\[\begin{pNiceArray}{ccc}[last-col, margin = 2pt]
\CodeBefore [create-cell-nodes]
  \begin{tikzpicture}
  \emph{\node [highlight = (1-1) (1-last)] {} ;
  \node [highlight = (2-1) (2-last)] {} ;
  \node [highlight = (3-1) (3-last)] {} ;}
  \end{tikzpicture}
\Body
a & a + b & a + b + c & L_1 \\
a & a     & a + b     & L_2 \\
a & a     & a         & L_3
\end{pNiceArray}\]
\end{Code}

\[\begin{pNiceArray}{ccc}[last-col, margin = 2pt]
\CodeBefore [create-cell-nodes]
  \begin{tikzpicture}
  \node [highlight = (1-1) (1-last)] {} ;
  \node [highlight = (2-1) (2-last)] {} ;
  \node [highlight = (3-1) (3-last)] {} ;
  \end{tikzpicture}
\Body
a & a + b & a + b + c & L_1 \\
a & a     & a + b     & L_2 \\
a & a     & a         & L_3
\end{pNiceArray}\]

\medskip
Le résultat peut paraître décevant. On peut l'améliorer en utilisant les «nœuds
moyens» au lieu des «nœuds normaux».

\index{create-medium-nodes|textit}
\index{create-cell-nodes (clé de \texttt{\textbackslash CodeBefore})|textit}

\begin{Code}
\[\begin{pNiceArray}{ccc}[last-col, margin = 2pt, create-medium-nodes]
\CodeBefore [create-cell-nodes]
  \begin{tikzpicture} \emph{[name suffix = -medium]}
  \node [highlight = (1-1) (1-last)] {} ;
  \node [highlight = (2-1) (2-last)] {} ;
  \node [highlight = (3-1) (3-last)] {} ;
  \end{tikzpicture}
\Body
a & a + b & a + b + c & L_1 \\
a & a     & a + b     & L_2 \\
a & a     & a         & L_3
\end{pNiceArray}\]
\end{Code}


\[\begin{pNiceArray}{ccc}[last-col, margin = 2pt, create-medium-nodes]
\CodeBefore [create-cell-nodes]
  \begin{tikzpicture} [name suffix = -medium]
  \node [highlight = (1-1) (1-last)] {} ;
  \node [highlight = (2-1) (2-last)] {} ;
  \node [highlight = (3-1) (3-last)] {} ;
  \end{tikzpicture}
\Body
a & a + b & a + b + c & L_1 \\
a & a     & a + b     & L_2 \\
a & a     & a         & L_3
\end{pNiceArray}\]



\subsection{Utilisation de \textbackslash SubMatrix dans le \textbackslash CodeBefore}

\index{SubMatrix@\texttt{\textbackslash SubMatrix} (commande du 
\texttt{\textbackslash CodeAfter}\newline et du 
\texttt{\textbackslash CodeBefore})|textit}
\index{CodeBefore@\texttt{\textbackslash CodeBefore}...\texttt{\textbackslash Body}|textit}
\index{CodeAfter@\texttt{\textbackslash CodeAfter}|textit}
\index{create-cell-nodes (clé de \texttt{\textbackslash CodeBefore})|textit}


\label{ex:submatrix}

Dans l'exemple suivant, on illustre le produit mathématique de deux matrices.

L'ensemble de la figure est un environnement |{NiceArray}| et les trois paires
de parenthèses ont été rajoutées avec |\SubMatrix| dans le |\CodeBefore|.


\tikzset{highlight/.style={rectangle,
                           fill=red!15,
                           rounded corners = 0.5 mm,
                           inner sep=1pt,
                           fit=#1}}%
%
%
\[\begin{NiceArray}{*{6}{c}@{\hspace{6mm}}*{5}{c}}[nullify-dots]
\CodeBefore [create-cell-nodes]
  \SubMatrix({2-7}{6-last})
  \SubMatrix({7-2}{last-6})
  \SubMatrix({7-7}{last-last})
  \begin{tikzpicture}
    \node [highlight = (9-2) (9-6)] { } ;
    \node [highlight = (2-9) (6-9)] { } ;
  \end{tikzpicture}
\Body
    &        &        &        &        &        &        &        & \color{blue}\scriptstyle C_j \\
    &        &        &        &        &        & b_{11} & \Cdots & b_{1j} & \Cdots & b_{1n} \\
    &        &        &        &        &        & \Vdots &        & \Vdots &        & \Vdots \\
    &        &        &        &        &        &        &        & b_{kj} \\
    &        &        &        &        &        &        &        & \Vdots \\
    &        &        &        &        &        & b_{n1} & \Cdots & b_{nj} & \Cdots & b_{nn} \\[3mm]
    & a_{11} & \Cdots &        &        & a_{1n} \\
    & \Vdots &        &        &        & \Vdots &        &        & \Vdots \\
\color{blue}\scriptstyle L_i
    & a_{i1} & \Cdots & a_{ik} & \Cdots & a_{in} & \Cdots &        & c_{ij} \\
    & \Vdots &        &        &        & \Vdots \\
    & a_{n1} & \Cdots &        &        & a_{nn}  \\
\CodeAfter
\tikz \draw [gray,shorten > = 1mm, shorten < = 1mm] (9-4.north) to [bend left] (4-9.west) ;
\end{NiceArray}\]


\vspace{1cm}
\begin{Verbatim}
\tikzset{highlight/.style={rectangle,
                           fill=red!15,
                           rounded corners = 0.5 mm,
                           inner sep=1pt,
                           fit=~#1}}
\end{Verbatim}

\begin{scope}
\footnotesize
\begin{Code}
\[\begin{NiceArray}{*{6}{c}@{\hspace{6mm}}*{5}{c}}[nullify-dots]
\CodeBefore [create-cell-nodes]
  \SubMatrix({2-7}{6-last})
  \SubMatrix({7-2}{last-6})
  \SubMatrix({7-7}{last-last})
  \begin{tikzpicture}
    \node [highlight = (9-2) (9-6)] { } ;
    \node [highlight = (2-9) (6-9)] { } ;
  \end{tikzpicture}
\Body
    &        &        &        &        &        &        &        & \color{blue}\scriptstyle C_j \\
    &        &        &        &        &        & b_{11} & \Cdots & b_{1j} & \Cdots & b_{1n} \\
    &        &        &        &        &        & \Vdots &        & \Vdots &        & \Vdots \\
    &        &        &        &        &        &        &        & b_{kj} \\
    &        &        &        &        &        &        &        & \Vdots \\
    &        &        &        &        &        & b_{n1} & \Cdots & b_{nj} & \Cdots & b_{nn} \\[3mm]
    & a_{11} & \Cdots &        &        & a_{1n} \\
    & \Vdots &        &        &        & \Vdots &        &        & \Vdots \\
\color{blue}\scriptstyle L_i
    & a_{i1} & \Cdots & a_{ik} & \Cdots & a_{in} & \Cdots &        & c_{ij} \\
    & \Vdots &        &        &        & \Vdots \\
    & a_{n1} & \Cdots &        &        & a_{nn}  \\
\CodeAfter
\tikz \draw [gray,shorten > = 1mm, shorten < = 1mm] (9-4.north) to [bend left] (4-9.west) ;
\end{NiceArray}\]
\end{Code}
\end{scope}


\subsection{Un tableau triangulaire}

\label{ex:triangular}
\index{pgf-node-code|textit}
\index{Coins (les --- vides)|textit}
\index{chessboardcolors@\texttt{\textbackslash chessboardcolors}!(commande
  du \texttt{\textbackslash CodeBefore})|textit}
\index{CodeBefore@\texttt{\textbackslash CodeBefore}...\texttt{\textbackslash Body}|textit}

Dans l'exemple suivant, on utilise le style PGF/Tikz |nicematrix/cell-node| pour faire
tourner le contenu des cases (rotation que l'on compense ensuite en faisant
tourner tout le tableau avec la commande |\adjustbox| de l'extension éponyme,
qui doit donc être chargée préalablement).

\medskip
\begin{Code}
\pgfset 
  { 
    \emph{nicematrix/cell-node}/.append style = 
      { text/rotate = 45, minimum size = 6 mm }
  }

\setlength{\tabcolsep}{0pt}

\emph{\adjustbox}{rotate = -45, set depth = 6mm + 1.414 \arrayrulewidth}
  {\begin{NiceTabular} [ hvlines, corners=SE, baseline = line-9 ] { cccccccc }
   \CodeBefore
     \chessboardcolors{red!15}{blue!15}
   \Body
     1 & 1 & 1  & 1  & 1  & 1 & 1 & 1 \\
     1 & 2 & 3  & 4  & 5  & 6 & 7 \\
     1 & 3 & 6  & 10 & 15 & 21 \\
     1 & 4 & 10 & 20 & 35 \\
     1 & 5 & 15 & 35 \\
     1 & 6 & 21 \\
     1 & 7 \\
     1 
   \end{NiceTabular}}
\end{Code}



\begin{center}
\pgfset 
  { 
    nicematrix/cell-node/.append style = 
      { text/rotate = 45, minimum size = 6 mm }
  }%
\setlength{\tabcolsep}{0pt}%
\adjustbox{rotate = -45, set depth = 6mm + 1.414 \arrayrulewidth}
  {\begin{NiceTabular} [ hvlines, corners=SE, baseline = line-9 ] { cccccccc }
   \CodeBefore
     \chessboardcolors{red!15}{blue!15}
   \Body
     1 & 1 & 1  & 1  & 1  & 1 & 1 & 1 \\
     1 & 2 & 3  & 4  & 5  & 6 & 7 \\
     1 & 3 & 6  & 10 & 15 & 21 \\
     1 & 4 & 10 & 20 & 35 \\
     1 & 5 & 15 & 35 \\
     1 & 6 & 21 \\
     1 & 7 \\
     1 
   \end{NiceTabular}}
\end{center}

\cleardoublepage

\phantomsection
\addcontentsline{toc}{section}{Index}

\printindex

\section*{Autre documentation}

Le document |nicematrix.pdf| (fourni avec l'extension \pkg{nicematrix}) contient
une traduction anglaise de la documentation ici présente ainsi qu'un historique
des versions.

Le document |nicematrix-code.pdf| (fourni également avec l'extension
\pkg{nicematrix}) contient le code LaTeX commenté (à partir du fichier
|nicematrix-code.dtx|).

\medskip
Le développement de l'extension \pkg{nicematrix} se fait sur le dépôt GitHub
suivant :

\nolinkurl{https://github.com/fpantigny/nicematrix}


\medskip
Les versions successives du fichier |nicematrix.sty| fournies par
TeXLive sont également disponibles sur le serveur \textsc{svn} de TeXLive :

\smallskip
{
\small
\nolinkurl{www.tug.org/svn/texlive/trunk/Master/texmf-dist/tex/latex/nicematrix/nicematrix.sty}
}

\vspace{2cm}

\tableofcontents

\end{document}

% Local Variables:
% LaTeX-verbatim-environments-local: ("Code")
% fill-column: 80
% End:



